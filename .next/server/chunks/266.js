"use strict";exports.id=266,exports.ids=[266],exports.modules={74266:(e,t,n)=>{let i,r;n.d(t,{NF:()=>t7});var a=Object.defineProperty,s=(e,t,n)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,o=(e,t,n)=>s(e,"symbol"!=typeof t?t+"":t,n),l=n(97742);if(void 0!==globalThis.Deno){let e=globalThis.Request,t=function(t,n){if(n&&"object"==typeof n){let i={...n};return"client"in i&&delete i.client,new e(t,i)}return new e(t,n)};Object.setPrototypeOf(t,e),Object.defineProperty(t,"prototype",{value:e.prototype,writable:!1}),globalThis.Request=t}var c=["ids","embeddings","metadatas","documents","uris","ids"],d=((i=d||{}).distances="distances",i.documents="documents",i.embeddings="embeddings",i.metadatas="metadatas",i.uris="uris",i),u=class{constructor({documents:e,embeddings:t,ids:n,include:i,metadatas:r,uris:a}){this.documents=e,this.embeddings=t,this.ids=n,this.include=i,this.metadatas=r,this.uris=a}rows(){return this.ids.map((e,t)=>({id:e,document:this.include.includes("documents")?this.documents[t]:void 0,embedding:this.include.includes("embeddings")?this.embeddings[t]:void 0,metadata:this.include.includes("metadatas")?this.metadatas[t]:void 0,uri:this.include.includes("uris")?this.uris[t]:void 0}))}},h=class{constructor({distances:e,documents:t,embeddings:n,ids:i,include:r,metadatas:a,uris:s}){this.distances=e,this.documents=t,this.embeddings=n,this.ids=i,this.include=r,this.metadatas=a,this.uris=s}rows(){let e=[];for(let t=0;t<this.ids.length;t++){let n=this.ids[t].map((e,n)=>({id:e,document:this.include.includes("documents")?this.documents[t][n]:void 0,embedding:this.include.includes("embeddings")?this.embeddings[t][n]:void 0,metadata:this.include.includes("metadatas")?this.metadatas[t][n]:void 0,uri:this.include.includes("uris")?this.uris[t][n]:void 0,distance:this.include.includes("distances")?this.distances[t][n]:void 0}));e.push(n)}return e}},p=async(e,t)=>{let n="function"==typeof t?await t(e):t;if(n)return"bearer"===e.scheme?`Bearer ${n}`:"basic"===e.scheme?`Basic ${btoa(n)}`:n},f={bodySerializer:e=>JSON.stringify(e,(e,t)=>"bigint"==typeof t?t.toString():t)},m=e=>{switch(e){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}},g=e=>{switch(e){case"form":default:return",";case"pipeDelimited":return"|";case"spaceDelimited":return"%20"}},w=e=>{switch(e){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}},y=({allowReserved:e,explode:t,name:n,style:i,value:r})=>{if(!t){let t=(e?r:r.map(e=>encodeURIComponent(e))).join(g(i));switch(i){case"label":return`.${t}`;case"matrix":return`;${n}=${t}`;case"simple":return t;default:return`${n}=${t}`}}let a=m(i),s=r.map(t=>"label"===i||"simple"===i?e?t:encodeURIComponent(t):b({allowReserved:e,name:n,value:t})).join(a);return"label"===i||"matrix"===i?a+s:s},b=({allowReserved:e,name:t,value:n})=>{if(null==n)return"";if("object"==typeof n)throw Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");return`${t}=${e?n:encodeURIComponent(n)}`},v=({allowReserved:e,explode:t,name:n,style:i,value:r})=>{if(r instanceof Date)return`${n}=${r.toISOString()}`;if("deepObject"!==i&&!t){let t=[];Object.entries(r).forEach(([n,i])=>{t=[...t,n,e?i:encodeURIComponent(i)]});let a=t.join(",");switch(i){case"form":return`${n}=${a}`;case"label":return`.${a}`;case"matrix":return`;${n}=${a}`;default:return a}}let a=w(i),s=Object.entries(r).map(([t,r])=>b({allowReserved:e,name:"deepObject"===i?`${n}[${t}]`:t,value:r})).join(a);return"label"===i||"matrix"===i?a+s:s},x=/\{[^{}]+\}/g,C=({path:e,url:t})=>{let n=t,i=t.match(x);if(i)for(let t of i){let i=!1,r=t.substring(1,t.length-1),a="simple";r.endsWith("*")&&(i=!0,r=r.substring(0,r.length-1)),r.startsWith(".")?(r=r.substring(1),a="label"):r.startsWith(";")&&(r=r.substring(1),a="matrix");let s=e[r];if(null==s)continue;if(Array.isArray(s)){n=n.replace(t,y({explode:i,name:r,style:a,value:s}));continue}if("object"==typeof s){n=n.replace(t,v({explode:i,name:r,style:a,value:s}));continue}if("matrix"===a){n=n.replace(t,`;${b({name:r,value:s})}`);continue}let o=encodeURIComponent("label"===a?`.${s}`:s);n=n.replace(t,o)}return n},$=({allowReserved:e,array:t,object:n}={})=>i=>{let r=[];if(i&&"object"==typeof i)for(let a in i){let s=i[a];if(null!=s){if(Array.isArray(s)){r=[...r,y({allowReserved:e,explode:!0,name:a,style:"form",value:s,...t})];continue}if("object"==typeof s){r=[...r,v({allowReserved:e,explode:!0,name:a,style:"deepObject",value:s,...n})];continue}r=[...r,b({allowReserved:e,name:a,value:s})]}}return r.join("&")},_=e=>{if(!e)return"stream";let t=e.split(";")[0]?.trim();if(t){if(t.startsWith("application/json")||t.endsWith("+json"))return"json";if("multipart/form-data"===t)return"formData";if(["application/","audio/","image/","video/"].some(e=>t.startsWith(e)))return"blob";if(t.startsWith("text/"))return"text"}},k=async({security:e,...t})=>{for(let n of e){let e=await p(n,t.auth);if(!e)continue;let i=n.name??"Authorization";switch(n.in){case"query":t.query||(t.query={}),t.query[i]=e;break;case"cookie":t.headers.append("Cookie",`${i}=${e}`);break;default:t.headers.set(i,e)}return}},E=e=>S({baseUrl:e.baseUrl,path:e.path,query:e.query,querySerializer:"function"==typeof e.querySerializer?e.querySerializer:$(e.querySerializer),url:e.url}),S=({baseUrl:e,path:t,query:n,querySerializer:i,url:r})=>{let a=(e??"")+(r.startsWith("/")?r:`/${r}`);t&&(a=C({path:t,url:a}));let s=n?i(n):"";return s.startsWith("?")&&(s=s.substring(1)),s&&(a+=`?${s}`),a},I=(e,t)=>{let n={...e,...t};return n.baseUrl?.endsWith("/")&&(n.baseUrl=n.baseUrl.substring(0,n.baseUrl.length-1)),n.headers=O(e.headers,t.headers),n},O=(...e)=>{let t=new Headers;for(let n of e)if(n&&"object"==typeof n)for(let[e,i]of n instanceof Headers?n.entries():Object.entries(n))if(null===i)t.delete(e);else if(Array.isArray(i))for(let n of i)t.append(e,n);else void 0!==i&&t.set(e,"object"==typeof i?JSON.stringify(i):i);return t},T=class{constructor(){o(this,"_fns"),this._fns=[]}clear(){this._fns=[]}exists(e){return -1!==this._fns.indexOf(e)}eject(e){let t=this._fns.indexOf(e);-1!==t&&(this._fns=[...this._fns.slice(0,t),...this._fns.slice(t+1)])}use(e){this._fns=[...this._fns,e]}},j=()=>({error:new T,request:new T,response:new T}),A=$({allowReserved:!1,array:{explode:!0,style:"form"},object:{explode:!0,style:"deepObject"}}),F={"Content-Type":"application/json"},N=(e={})=>({...f,headers:F,parseAs:"auto",querySerializer:A,...e}),V=(e={})=>{let t=I(N(),e),n=()=>({...t}),i=j(),r=async e=>{let n={...t,...e,fetch:e.fetch??t.fetch??globalThis.fetch,headers:O(t.headers,e.headers)};n.security&&await k({...n,security:n.security}),n.body&&n.bodySerializer&&(n.body=n.bodySerializer(n.body)),(void 0===n.body||""===n.body)&&n.headers.delete("Content-Type");let r=new Request(E(n),{redirect:"follow",...n});for(let e of i.request._fns)r=await e(r,n);let a=n.fetch,s=await a(r);for(let e of i.response._fns)s=await e(s,r,n);let o={request:r,response:s};if(s.ok){if(204===s.status||"0"===s.headers.get("Content-Length"))return{data:{},...o};let e=("auto"===n.parseAs?_(s.headers.get("Content-Type")):n.parseAs)??"json";if("stream"===e)return{data:s.body,...o};let t=await s[e]();return"json"===e&&(n.responseValidator&&await n.responseValidator(t),n.responseTransformer&&(t=await n.responseTransformer(t))),{data:t,...o}}let l=await s.text();try{l=JSON.parse(l)}catch{}let c=l;for(let e of i.error._fns)c=await e(l,s,r,n);if(c=c||{},n.throwOnError)throw c;return{error:c,...o}};return{buildUrl:E,connect:e=>r({...e,method:"CONNECT"}),delete:e=>r({...e,method:"DELETE"}),get:e=>r({...e,method:"GET"}),getConfig:n,head:e=>r({...e,method:"HEAD"}),interceptors:i,options:e=>r({...e,method:"OPTIONS"}),patch:e=>r({...e,method:"PATCH"}),post:e=>r({...e,method:"POST"}),put:e=>r({...e,method:"PUT"}),request:r,setConfig:e=>(t=I(t,e),n()),trace:e=>r({...e,method:"TRACE"})}},z=V(N({baseUrl:"http://localhost:8000",throwOnError:!0})),q=class{static getUserIdentity(e){return(e?.client??z).get({url:"/api/v2/auth/identity",...e})}static getCollectionByCrn(e){return(e.client??z).get({url:"/api/v2/collections/{crn}",...e})}static healthcheck(e){return(e?.client??z).get({url:"/api/v2/healthcheck",...e})}static heartbeat(e){return(e?.client??z).get({url:"/api/v2/heartbeat",...e})}static preFlightChecks(e){return(e?.client??z).get({url:"/api/v2/pre-flight-checks",...e})}static reset(e){return(e?.client??z).post({url:"/api/v2/reset",...e})}static createTenant(e){return(e.client??z).post({url:"/api/v2/tenants",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static getTenant(e){return(e.client??z).get({url:"/api/v2/tenants/{tenant_name}",...e})}static updateTenant(e){return(e.client??z).patch({url:"/api/v2/tenants/{tenant_name}",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static listDatabases(e){return(e.client??z).get({url:"/api/v2/tenants/{tenant}/databases",...e})}static createDatabase(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static deleteDatabase(e){return(e.client??z).delete({url:"/api/v2/tenants/{tenant}/databases/{database}",...e})}static getDatabase(e){return(e.client??z).get({url:"/api/v2/tenants/{tenant}/databases/{database}",...e})}static listCollections(e){return(e.client??z).get({url:"/api/v2/tenants/{tenant}/databases/{database}/collections",...e})}static createCollection(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static deleteCollection(e){return(e.client??z).delete({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}",...e})}static getCollection(e){return(e.client??z).get({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}",...e})}static updateCollection(e){return(e.client??z).put({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static collectionAdd(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/add",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static detachFunction(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/attached_functions/{name}/detach",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static collectionCount(e){return(e.client??z).get({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/count",...e})}static collectionDelete(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/delete",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static forkCollection(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/fork",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static attachFunction(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/functions/attach",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static getAttachedFunction(e){return(e.client??z).get({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/functions/{function_name}",...e})}static collectionGet(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/get",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static collectionQuery(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/query",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static collectionSearch(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/search",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static collectionUpdate(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/update",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static collectionUpsert(e){return(e.client??z).post({url:"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/upsert",...e,headers:{"Content-Type":"application/json",...e?.headers}})}static countCollections(e){return(e.client??z).get({url:"/api/v2/tenants/{tenant}/databases/{database}/collections_count",...e})}static version(e){return(e?.client??z).get({url:"/api/v2/version",...e})}},D=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaConnectionError"}},J=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaServerError"}},R=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaClientError"}},P=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaAuthError"}},K=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaForbiddenError"}},U=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaNotFoundError"}},B=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaValueError"}},L=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaUniqueError"}},M=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaQuotaExceededError"}},H=class extends Error{constructor(e,t){super(e),this.cause=t,this.name="ChromaRateLimitError"}},G={host:"localhost",port:8e3,ssl:!1,tenant:"default_tenant",database:"default_database"},W=e=>{if(e)switch(e.toUpperCase()){case"GET":return"GET";case"POST":return"POST";case"PUT":return"PUT";case"DELETE":return"DELETE";case"HEAD":return"HEAD";case"CONNECT":return"CONNECT";case"OPTIONS":return"OPTIONS";case"PATCH":return"PATCH";case"TRACE":return"TRACE"}},Q=e=>{let t=Object.entries(e).filter(([e,t])=>c.includes(e)&&void 0!==t).map(([e,t])=>[e,t.length]);if(0===t.length)throw new B(`At least one of ${c.join(", ")} must be provided`);let n=t.filter(([e,t])=>0===t).map(([e,t])=>e);if(n.length>0)throw new B(`Non-empty lists are required for ${n.join(", ")}`);if(new Set(t.map(([e,t])=>t)).size>1)throw new B(`Unequal lengths for fields ${t.map(([e,t])=>e).join(", ")}`)},Y=({embeddings:e,fieldName:t="embeddings"})=>{if(!Array.isArray(e))throw new B(`Expected '${t}' to be an array, but got ${typeof e}`);if(0===e.length)throw new B("Expected embeddings to be an array with at least one item");if(!e.filter(e=>e.every(e=>"number"==typeof e)))throw new B("Expected each embedding to be an array of numbers");e.forEach((e,t)=>{if(0===e.length)throw new B(`Expected each embedding to be a non-empty array of numbers, but got an empty array at index ${t}`)})},X=({documents:e,nullable:t=!1,fieldName:n="documents"})=>{if(!Array.isArray(e))throw new B(`Expected '${n}' to be an array, but got ${typeof e}`);if(0===e.length)throw new B(`Expected '${n}' to be a non-empty list`);e.forEach(e=>{if(!t&&"string"!=typeof e&&!e)throw new B(`Expected each document to be a string, but got ${typeof e}`)})},Z=e=>{if(!Array.isArray(e))throw new B(`Expected 'ids' to be an array, but got ${typeof e}`);if(0===e.length)throw new B("Expected 'ids' to be a non-empty list");let t=e.map((e,t)=>[e,t]).filter(([e,t])=>"string"!=typeof e).map(([e,t])=>t);if(t.length>0)throw new B(`Found non-string IDs at ${t.join(", ")}`);let n=new Set,i=e.filter(e=>{if(n.has(e))return e;n.add(e)}),r="Expected IDs to be unique, but found duplicates of";if(i.length>0&&i.length<=5)throw new B(`${r} ${i.join(", ")}`);if(i.length>0)throw new B(`${r} ${i.slice(0,5).join(", ")}, ..., ${i.slice(i.length-5).join(", ")}`)},ee=e=>{if("object"!=typeof e||null===e)return!1;let t=e.indices,n=e.values;return!!(Array.isArray(t)&&Array.isArray(n))&&t.every(e=>"number"==typeof e)&&n.every(e=>"number"==typeof e)},et=e=>{if(e){if(0===Object.keys(e).length)throw new B("Expected metadata to be non-empty");if(!Object.values(e).every(e=>null==e||"string"==typeof e||"number"==typeof e||"boolean"==typeof e||ee(e)))throw new B("Expected metadata to be a string, number, boolean, SparseVector, or nullable")}},en="sparse_vector",ei=e=>({"#type":en,indices:e.indices,values:e.values}),er=e=>{if(void 0===e)return;if(null===e)return null;let t={};return Object.entries(e).forEach(([e,n])=>{ee(n)?t[e]=ei(n):t[e]=n??null}),t},ea=e=>void 0===e?void 0:null===e?null:e.map(e=>er(e)??null),es=e=>"object"==typeof e&&null!==e&&e["#type"]===en&&ee(e),eo=e=>es(e)?{indices:e.indices,values:e.values}:e,el=e=>{if(void 0===e)return;if(null===e)return null;let t={};return Object.entries(e).forEach(([e,n])=>{t[e]=eo(n)}),t},ec=e=>void 0===e?void 0:null===e?null:e.map(e=>el(e)??null),ed=e=>void 0===e?void 0:null===e?null:e.map(e=>null===e?null:ec(e)??[]),eu=e=>{if(!Array.isArray(e))throw new B(`Expected metadatas to be an array, but got ${typeof e}`);e.forEach(e=>et(e))},eh=({recordSet:e,update:t=!1,embeddingsField:n="embeddings",documentsField:i="documents"})=>{if(!e.embeddings&&!e.documents&&!t)throw new B(`At least one of '${n}' and '${i}' must be provided`);e.embeddings&&Y({embeddings:e.embeddings,fieldName:n}),e.documents&&X({documents:e.documents,fieldName:i}),e.metadatas&&eu(e.metadatas)},ep=(e,t)=>{if(e>t)throw new B(`Record set length ${e} exceeds max batch size ${t}`)},ef=e=>{if("object"!=typeof e)throw new B("Expected where to be a non-empty object");if(1!=Object.keys(e).length)throw new B(`Expected 'where' to have exactly one operator, but got ${Object.keys(e).length}`);Object.entries(e).forEach(([e,t])=>{if("$and"!==e&&"$or"!==e&&"$in"!==e&&"$nin"!==e&&!["string","number","boolean","object"].includes(typeof t))throw new B(`Expected 'where' value to be a string, number, boolean, or an operator expression, but got ${t}`);if("$and"===e||"$or"===e){if(Object.keys(t).length<=1)throw new B(`Expected 'where' value for $and or $or to be a list of 'where' expressions, but got ${t}`);t.forEach(e=>ef(e));return}if("object"==typeof t){if(1!=Object.keys(t).length)throw new B(`Expected operator expression to have one operator, but got ${t}`);let[e,n]=Object.entries(t)[0];if(["$gt","$gte","$lt","$lte"].includes(e)&&"number"!=typeof n)throw new B(`Expected operand value to be a number for ${e}, but got ${typeof n}`);if(["$in","$nin"].includes(e)&&!Array.isArray(n))throw new B(`Expected operand value to be an array for ${e}, but got ${n}`);if(!["$gt","$gte","$lt","$lte","$ne","$eq","$in","$nin"].includes(e))throw new B(`Expected operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, but got ${e}`);if(!["string","number","boolean"].includes(typeof n)&&!Array.isArray(n))throw new B("Expected operand value to be a string, number, boolean, or a list of those types");if(Array.isArray(n)&&(0===n.length||!n.every(e=>typeof e==typeof n[0])))throw new B("Expected 'where' operand value to be a non-empty list and all values to be of the same type")}})},em=e=>{if("object"!=typeof e)throw new B("Expected 'whereDocument' to be a non-empty object");if(1!=Object.keys(e).length)throw new B(`Expected 'whereDocument' to have exactly one operator, but got ${e}`);let[t,n]=Object.entries(e)[0];if(!["$contains","$not_contains","$matches","$not_matches","$regex","$not_regex","$and","$or"].includes(t))throw new B(`Expected 'whereDocument' operator to be one of $contains, $not_contains, $matches, $not_matches, $regex, $not_regex, $and, or $or, but got ${t}`);if("$and"===t||"$or"===t){if(!Array.isArray(n))throw new B(`Expected operand for ${t} to be a list of 'whereDocument' expressions, but got ${n}`);if(n.length<=1)throw new B(`Expected 'whereDocument' operand for ${t} to be a list with at least two 'whereDocument' expressions`);n.forEach(e=>em(e))}if(("$contains"===n||"$not_contains"===n||"$regex"===n||"$not_regex"===n)&&("string"!=typeof t||0===t.length))throw new B(`Expected operand for ${t} to be a non empty string, but got ${n}`)},eg=({include:e,exclude:t})=>{if(!Array.isArray(e))throw new B("Expected 'include' to be a non-empty array");let n=Object.keys(d);e.forEach(e=>{if("string"!=typeof e)throw new B("Expected 'include' items to be strings");if(!n.includes(e))throw new B(`Expected 'include' items to be one of ${n.join(", ")}, but got ${e}`);if(t?.includes(e))throw new B(`${e} is not allowed for this operation`)})},ew=e=>{if("number"!=typeof e)throw new B(`Expected 'nResults' to be a number, but got ${typeof e}`);if(e<=0)throw new B("Number of requested results has to positive")},ey=e=>{try{let t=new URL(e),n="https:"===t.protocol,i=t.hostname,r=t.port;return{ssl:n,host:i,port:Number(r)}}catch{throw new B(`Invalid URL: ${e}`)}},eb=e=>{let t=new ArrayBuffer(4*e.length),n=new Float32Array(t);for(let t=0;t<e.length;t++)n[t]=e[t];return t},ev=e=>e.map(e=>btoa(Array.from(new Uint8Array(eb(e)),e=>String.fromCharCode(e)).join(""))),ex=new Map,eC={onnx_mini_lm_l6_v2:"default-embed",default:"default-embed",together_ai:"together-ai",sentence_transformer:"sentence-transformer"},e$=new Set(["amazon_bedrock","baseten","langchain","google_palm","huggingface","instructor","open_clip","roboflow","text2vec"]),e_=new Map,ek={chroma_bm25:"chroma-bm25"},eE=new Set(["bm25","fastembed_sparse","huggingface_sparse"]),eS=(e,t)=>{if(ex.has(e))throw new B(`Embedding function with name ${e} is already registered.`);ex.set(e,t)},eI=async e=>{let{collectionName:t,client:i,efConfig:r}=e;if(!r||"legacy"===r.type){console.warn(`No embedding function configuration found for collection ${t}. 'add' and 'query' will fail unless you provide them embeddings directly.`);return}if("unknown"===r.type){console.warn(`Unknown embedding function configuration for collection ${t}. 'add' and 'query' will fail unless you provide them embeddings directly.`);return}if("known"!==r.type)return;if(e$.has(r.name)){console.warn(`Embedding function ${r.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.`);return}let a=eC[r.name]||r.name;"default-embed"===a&&await ej();let s=ex.get(a);if(!s){try{let e=`@chroma-core/${a}`;await n(56572)(e),s=ex.get(a)}catch(e){}if(!s){console.warn(`Collection ${t} was created with the ${a} embedding function. However, the @chroma-core/${a} package is not installed. 'add' and 'query' will fail unless you provide them embeddings directly, or install the @chroma-core/${a} package.`);return}}let o="known"===r.type?r.config:{};try{if(s.buildFromConfig)return s.buildFromConfig(o,i);console.warn(`Embedding function ${a} does not define a 'buildFromConfig' function. 'add' and 'query' will fail unless you provide them embeddings directly.`);return}catch(e){console.warn(`Embedding function ${a} failed to build with config: ${o}. 'add' and 'query' will fail unless you provide them embeddings directly. Error: ${e}`);return}},eO=async(e,t,i)=>{if(!i||"legacy"===i.type||"known"!==i.type)return;if(eE.has(i.name)){console.warn("Embedding function ${efConfig.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.");return}let r=ek[i.name]||i.name,a=e_.get(r);if(!a){try{let e=`@chroma-core/${r}`;await n(56572)(e),a=e_.get(r)}catch(e){}if(!a){console.warn(`Collection ${e} was created with the ${r} sparse embedding function. However, the @chroma-core/${r} package is not installed.`);return}}let s="known"===i.type?i.config:{};try{if(a.buildFromConfig)return a.buildFromConfig(s,t);console.warn(`Sparse embedding function ${r} does not define a 'buildFromConfig' function.`);return}catch(e){console.warn(`Sparse embedding function ${r} failed to build with config: ${s}. Error: ${e}`);return}},eT=({embeddingFunction:e,configEmbeddingFunction:t})=>{if(e&&t)throw new B("Embedding function provided when already defined in the collection configuration");if(!e&&!t)return;let n=e||t;return n.getConfig&&n.name&&n.constructor.buildFromConfig?(n.validateConfig&&n.validateConfig(n.getConfig()),{name:n.name,type:"known",config:n.getConfig()}):{type:"legacy"}},ej=async()=>{try{let{DefaultEmbeddingFunction:e}=await n.e(994).then(n.bind(n,5994));ex.has("default-embed")||eS("default-embed",e)}catch(e){console.warn("Cannot instantiate a collection with the DefaultEmbeddingFunction. Please install @chroma-core/default-embed, or provide a different embedding function")}return{name:"default",type:"known",config:{}}},eA=async({configuration:e,embeddingFunction:t,metadata:n,schema:i})=>{let r;if(i&&(r=i.resolveEmbeddingFunction()),e?.hnsw&&e?.spann)throw new B("Cannot specify both HNSW and SPANN configurations");let a=eT({embeddingFunction:t??void 0,configEmbeddingFunction:e?.embeddingFunction});a||null===t||void 0!==r||(a=await ej());let s=t||e?.embeddingFunction;if(s&&s.defaultSpace&&s.supportedSpaces&&(e?.hnsw===void 0&&e?.spann===void 0&&(void 0===n||n?.["hnsw:space"]===void 0)&&(e||(e={}),e.hnsw={space:s.defaultSpace()}),e?.hnsw&&!e.hnsw.space&&s.defaultSpace&&(e.hnsw.space=s.defaultSpace()),e?.spann&&!e.spann.space&&s.defaultSpace&&(e.spann.space=s.defaultSpace()),s.supportedSpaces)){let t=s.supportedSpaces();e?.hnsw?.space&&!t.includes(e.hnsw.space)&&console.warn(`Space '${e.hnsw.space}' is not supported by embedding function '${s.name||"unknown"}'. Supported spaces: ${t.join(", ")}`),e?.spann?.space&&!t.includes(e.spann.space)&&console.warn(`Space '${e.spann.space}' is not supported by embedding function '${s.name||"unknown"}'. Supported spaces: ${t.join(", ")}`),e?.hnsw||e?.spann||!n||"string"!=typeof n["hnsw:space"]||t.includes(n["hnsw:space"])||console.warn(`Space '${n["hnsw:space"]}' from metadata is not supported by embedding function '${s.name||"unknown"}'. Supported spaces: ${t.join(", ")}`)}return{...e||{},embedding_function:a}},eF=async({collectionName:e,currentConfiguration:t,currentEmbeddingFunction:n,newConfiguration:i,client:r})=>{if(i.hnsw&&"object"!=typeof i.hnsw)throw new B("Invalid HNSW config provided in UpdateCollectionConfiguration");if(i.spann&&"object"!=typeof i.spann)throw new B("Invalid SPANN config provided in UpdateCollectionConfiguration");let a=n||await eI({collectionName:e,client:r,efConfig:t.embeddingFunction??void 0}),s=i.embeddingFunction;return a&&a.validateConfigUpdate&&s&&s.getConfig&&a.validateConfigUpdate(s.getConfig()),{updateConfiguration:{hnsw:i.hnsw,spann:i.spann,embedding_function:s&&eT({embeddingFunction:s})},updateEmbeddingFunction:s}},eN=e=>{if("object"!=typeof e||null===e||Array.isArray(e))return!1;let t=Object.getPrototypeOf(e);return t===Object.prototype||null===t},eV=e=>JSON.parse(JSON.stringify(e)),ez=e=>Array.isArray(e)?e.slice():Array.from(e),eq=(e,t)=>{if(0===e.length)throw Error(t)},eD=class{and(e){let t=eJ.from(e);return t?eR.combine(this,t):this}or(e){let t=eJ.from(e);return t?eP.combine(this,t):this}},eJ=class e extends eD{static from(t){if(t instanceof e)return t;if(null!=t){if(!eN(t))throw TypeError("Where input must be a WhereExpression or plain object");return eB(t)}}},eR=class e extends eJ{constructor(e){super(),this.conditions=e}toJSON(){return{$and:this.conditions.map(e=>e.toJSON())}}get operands(){return this.conditions.slice()}static combine(t,n){let i=[],r=t=>{t instanceof e?i.push(...t.operands):i.push(t)};return(r(t),r(n),1===i.length)?i[0]:new e(i)}},eP=class e extends eJ{constructor(e){super(),this.conditions=e}toJSON(){return{$or:this.conditions.map(e=>e.toJSON())}}get operands(){return this.conditions.slice()}static combine(t,n){let i=[],r=t=>{t instanceof e?i.push(...t.operands):i.push(t)};return(r(t),r(n),1===i.length)?i[0]:new e(i)}},eK=class extends eJ{constructor(e,t,n){super(),this.key=e,this.operator=t,this.value=n}toJSON(){return{[this.key]:{[this.operator]:this.value}}}},eU=new Map([["$eq",(e,t)=>new eK(e,"$eq",t)],["$ne",(e,t)=>new eK(e,"$ne",t)],["$gt",(e,t)=>new eK(e,"$gt",t)],["$gte",(e,t)=>new eK(e,"$gte",t)],["$lt",(e,t)=>new eK(e,"$lt",t)],["$lte",(e,t)=>new eK(e,"$lte",t)],["$in",(e,t)=>new eK(e,"$in",t)],["$nin",(e,t)=>new eK(e,"$nin",t)],["$contains",(e,t)=>new eK(e,"$contains",t)],["$not_contains",(e,t)=>new eK(e,"$not_contains",t)],["$regex",(e,t)=>new eK(e,"$regex",t)],["$not_regex",(e,t)=>new eK(e,"$not_regex",t)]]),eB=e=>{if("$and"in e){if(1!==Object.keys(e).length)throw Error("$and cannot be combined with other keys");let t=e.$and;if(!Array.isArray(t)||0===t.length)throw TypeError("$and must be a non-empty array");let n=t.map((e,t)=>{let n=eJ.from(e);if(!n)throw TypeError(`Invalid where clause at index ${t}`);return n});return 1===n.length?n[0]:n.slice(1).reduce((e,t)=>eR.combine(e,t),n[0])}if("$or"in e){if(1!==Object.keys(e).length)throw Error("$or cannot be combined with other keys");let t=e.$or;if(!Array.isArray(t)||0===t.length)throw TypeError("$or must be a non-empty array");let n=t.map((e,t)=>{let n=eJ.from(e);if(!n)throw TypeError(`Invalid where clause at index ${t}`);return n});return 1===n.length?n[0]:n.slice(1).reduce((e,t)=>eP.combine(e,t),n[0])}let t=Object.entries(e);if(1!==t.length)throw Error("Where dictionary must contain exactly one field");let[n,i]=t[0];if(!eN(i))return new eK(n,"$eq",i);let r=Object.entries(i);if(1!==r.length)throw Error(`Operator dictionary for field "${n}" must contain exactly one operator`);let[a,s]=r[0],o=eU.get(a);if(!o)throw Error(`Unsupported where operator: ${a}`);return o(n,s)},eL=(e,t,n)=>new eK(e,t,n),eM=class{constructor(e){this.name=e}eq(e){return eL(this.name,"$eq",e)}ne(e){return eL(this.name,"$ne",e)}gt(e){return eL(this.name,"$gt",e)}gte(e){return eL(this.name,"$gte",e)}lt(e){return eL(this.name,"$lt",e)}lte(e){return eL(this.name,"$lte",e)}isIn(e){let t=ez(e);return eq(t,"$in requires at least one value"),eL(this.name,"$in",t)}notIn(e){let t=ez(e);return eq(t,"$nin requires at least one value"),eL(this.name,"$nin",t)}contains(e){if("string"!=typeof e)throw TypeError("$contains requires a string value");return eL(this.name,"$contains",e)}notContains(e){if("string"!=typeof e)throw TypeError("$not_contains requires a string value");return eL(this.name,"$not_contains",e)}regex(e){if("string"!=typeof e)throw TypeError("$regex requires a string pattern");return eL(this.name,"$regex",e)}notRegex(e){if("string"!=typeof e)throw TypeError("$not_regex requires a string pattern");return eL(this.name,"$not_regex",e)}};eM.ID=new eM("#id"),eM.DOCUMENT=new eM("#document"),eM.EMBEDDING=new eM("#embedding"),eM.METADATA=new eM("#metadata"),eM.SCORE=new eM("#score"),(()=>{let e=e=>new eM(e);return e.ID=eM.ID,e.DOCUMENT=eM.DOCUMENT,e.EMBEDDING=eM.EMBEDDING,e.METADATA=eM.METADATA,e.SCORE=eM.SCORE})();var eH=class e{constructor(e={}){let{offset:t=0,limit:n}=e;if(!Number.isInteger(t)||t<0)throw TypeError("Limit offset must be a non-negative integer");if(null!=n){if(!Number.isInteger(n)||n<=0)throw TypeError("Limit must be a positive integer when provided");this.limit=n}this.offset=t}static from(t,n){if(t instanceof e)return new e({offset:t.offset,limit:t.limit});if("number"==typeof t)return new e({limit:t,offset:n??0});if(null==t)return new e;if("object"==typeof t)return new e(t);throw TypeError("Invalid limit input")}toJSON(){let e={offset:this.offset};return void 0!==this.limit&&(e.limit=this.limit),e}},eG=class e{constructor(e=[]){let t=new Set;for(let n of e){let e=n instanceof eM?n.name:n;if("string"!=typeof e)throw TypeError("Select keys must be strings or Key instances");t.add(e)}this.keys=Array.from(t)}static from(t){if(t instanceof e)return new e(t.keys);if(null==t)return new e;if(Symbol.iterator in Object(t))return new e(t);if("object"==typeof t&&"keys"in t){let{keys:n}=t;return new e(n??[])}throw TypeError("Unsupported select input")}static all(){return new e([eM.DOCUMENT,eM.EMBEDDING,eM.METADATA,eM.SCORE])}get values(){return this.keys.slice()}toJSON(){return{keys:this.values}}},eW=class{add(...e){if(0===e.length)return this;let t=[this,...e.map((e,t)=>e3(e,`add operand ${t}`))];return eZ.create(t)}subtract(e){return new e0(this,e3(e,"subtract operand"))}multiply(...e){if(0===e.length)return this;let t=[this,...e.map((e,t)=>e3(e,`multiply operand ${t}`))];return e1.create(t)}divide(e){return new e2(this,e3(e,"divide operand"))}negate(){return this.multiply(-1)}abs(){return new e4(this)}exp(){return new e5(this)}log(){return new e6(this)}max(...e){if(0===e.length)return this;let t=[this,...e.map((e,t)=>e3(e,`max operand ${t}`))];return e9.create(t)}min(...e){if(0===e.length)return this;let t=[this,...e.map((e,t)=>e3(e,`min operand ${t}`))];return e7.create(t)}},eQ=class e extends eW{static from(t){if(t instanceof e)return t;if(null!=t){if("number"==typeof t)return new eX(t);if(eN(t))return new eY(t);throw TypeError("Rank input must be a RankExpression, number, or plain object")}}},eY=class extends eQ{constructor(e){super(),this.raw=e}toJSON(){return eV(this.raw)}},eX=class extends eQ{constructor(e){super(),this.value=e}toJSON(){return{$val:this.value}}},eZ=class e extends eQ{constructor(e){super(),this.ranks=e}static create(t){let n=[];for(let i of t)i instanceof e?n.push(...i.operands):n.push(i);return 1===n.length?n[0]:new e(n)}get operands(){return this.ranks.slice()}toJSON(){return{$sum:this.ranks.map(e=>e.toJSON())}}},e0=class extends eQ{constructor(e,t){super(),this.left=e,this.right=t}toJSON(){return{$sub:{left:this.left.toJSON(),right:this.right.toJSON()}}}},e1=class e extends eQ{constructor(e){super(),this.ranks=e}static create(t){let n=[];for(let i of t)i instanceof e?n.push(...i.operands):n.push(i);return 1===n.length?n[0]:new e(n)}get operands(){return this.ranks.slice()}toJSON(){return{$mul:this.ranks.map(e=>e.toJSON())}}},e2=class extends eQ{constructor(e,t){super(),this.left=e,this.right=t}toJSON(){return{$div:{left:this.left.toJSON(),right:this.right.toJSON()}}}},e4=class extends eQ{constructor(e){super(),this.operand=e}toJSON(){return{$abs:this.operand.toJSON()}}},e5=class extends eQ{constructor(e){super(),this.operand=e}toJSON(){return{$exp:this.operand.toJSON()}}},e6=class extends eQ{constructor(e){super(),this.operand=e}toJSON(){return{$log:this.operand.toJSON()}}},e9=class e extends eQ{constructor(e){super(),this.ranks=e}static create(t){let n=[];for(let i of t)i instanceof e?n.push(...i.operands):n.push(i);return 1===n.length?n[0]:new e(n)}get operands(){return this.ranks.slice()}toJSON(){return{$max:this.ranks.map(e=>e.toJSON())}}},e7=class e extends eQ{constructor(e){super(),this.ranks=e}static create(t){let n=[];for(let i of t)i instanceof e?n.push(...i.operands):n.push(i);return 1===n.length?n[0]:new e(n)}get operands(){return this.ranks.slice()}toJSON(){return{$min:this.ranks.map(e=>e.toJSON())}}},e3=(e,t)=>{let n=eQ.from(e);if(!n)throw TypeError(`${t} must be a rank expression`);return n},e8=class e{static from(t){if(t instanceof e)return t;if(eN(t)){if("$min_k"in t){let e=t.$min_k;return new te(e.keys.map(e=>new eM(e)),e.k)}if("$max_k"in t){let e=t.$max_k;return new tt(e.keys.map(e=>new eM(e)),e.k)}}throw TypeError("Aggregate input must be an Aggregate instance or object with $min_k or $max_k")}static minK(e,t){return new te(e.map(e=>e instanceof eM?e:new eM(e)),t)}static maxK(e,t){return new tt(e.map(e=>e instanceof eM?e:new eM(e)),t)}},te=class extends e8{constructor(e,t){if(super(),this.keys=e,this.k=t,0===e.length)throw Error("MinK keys cannot be empty");if(t<=0)throw Error("MinK k must be positive")}toJSON(){return{$min_k:{keys:this.keys.map(e=>e.name),k:this.k}}}},tt=class extends e8{constructor(e,t){if(super(),this.keys=e,this.k=t,0===e.length)throw Error("MaxK keys cannot be empty");if(t<=0)throw Error("MaxK k must be positive")}toJSON(){return{$max_k:{keys:this.keys.map(e=>e.name),k:this.k}}}},tn=class e{constructor(e,t){if(this.keys=e,this.aggregate=t,0===e.length)throw Error("GroupBy keys cannot be empty")}static from(t){if(null!=t){if(t instanceof e)return t;if(eN(t)){if(!t.keys||!Array.isArray(t.keys))throw TypeError("GroupBy requires 'keys' array");if(!t.aggregate)throw TypeError("GroupBy requires 'aggregate'");return new e(t.keys.map(e=>new eM(e)),e8.from(t.aggregate))}throw TypeError("GroupBy input must be a GroupBy instance or plain object")}}toJSON(){return{keys:this.keys.map(e=>e.name),aggregate:this.aggregate.toJSON()}}},ti=class e{constructor(e={}){this._where=e.where?eJ.from(e.where):void 0,this._rank=e.rank?eQ.from(e.rank):void 0,this._groupBy=e.groupBy?tn.from(e.groupBy):void 0,this._limit=eH.from(e.limit??void 0),this._select=eG.from(e.select??void 0)}clone(t){let n=Object.create(e.prototype);return n._where=t.where??this._where,n._rank=t.rank??this._rank,n._groupBy=t.groupBy??this._groupBy,n._limit=t.limit??this._limit,n._select=t.select??this._select,n}where(e){return this.clone({where:eJ.from(e)})}rank(e){return this.clone({rank:eQ.from(e??void 0)})}groupBy(e){return this.clone({groupBy:tn.from(e)})}limit(e,t){return"number"==typeof e?this.clone({limit:eH.from(e,t)}):this.clone({limit:eH.from(e??void 0)})}select(e,...t){if(Array.isArray(e)||e instanceof Set||e instanceof eG||"object"==typeof e&&null!==e&&"keys"in e)return this.clone({select:eG.from(e)});let n=[];return void 0!==e&&n.push(e),t.length&&n.push(...t),this.clone({select:eG.from(n)})}selectAll(){return this.clone({select:eG.all()})}get whereClause(){return this._where}get rankExpression(){return this._rank}get groupByConfig(){return this._groupBy}get limitConfig(){return this._limit}get selectConfig(){return this._select}toPayload(){let e={limit:this._limit.toJSON(),select:this._select.toJSON()};return this._where&&(e.filter=this._where.toJSON()),this._rank&&(e.rank=this._rank.toJSON()),this._groupBy&&(e.group_by=this._groupBy.toJSON()),e}},tr=e=>e instanceof ti?e:new ti(e),ta=(e,t)=>{if(!e)return Array(t).fill(null);if(e.length===t)return e.map(e=>e?e.slice():null);let n=e.map(e=>e?e.slice():null);for(;n.length<t;)n.push(null);return n},ts=class{constructor(e){this.ids=e.ids;let t=this.ids.length;this.documents=ta(e.documents,t),this.embeddings=ta(e.embeddings,t);let n=ta(e.metadatas,t);this.metadatas=n.map(e=>e?ec(e)??[]:null),this.scores=ta(e.scores,t),this.select=e.select??[]}rows(){let e=[];for(let t=0;t<this.ids.length;t+=1){let n=this.ids[t],i=this.documents[t]??[],r=this.embeddings[t]??[],a=this.metadatas[t]??[],s=this.scores[t]??[],o=n.map((e,t)=>{let n={id:e},o=i[t];null!=o&&(n.document=o);let l=r[t];null!=l&&(n.embedding=l);let c=a[t];null!=c&&(n.metadata=c);let d=s[t];return null!=d&&(n.score=d),n});e.push(o)}return e}},to="#document",tl="#embedding",tc=((r=tc||{}).GCP="gcp",r),td=class e{constructor(e,t){this.provider=e,this.resource=t}static gcp(t){return new e("gcp",t)}validatePattern(){return"gcp"===this.provider&&e.GCP_PATTERN.test(this.resource)}toJSON(){if("gcp"===this.provider)return{gcp:this.resource};throw Error(`Unknown CMEK provider: ${this.provider}`)}static fromJSON(t){if("gcp"in t&&"string"==typeof t.gcp)return e.gcp(t.gcp);throw Error(`Unsupported or missing CMEK provider in data: ${JSON.stringify(t)}`)}};td.GCP_PATTERN=/^projects\/.+\/locations\/.+\/keyRings\/.+\/cryptoKeys\/.+$/;var tu="string",th="float_list",tp="sparse_vector",tf="float",tm="bool",tg="fts_index",tw="string_inverted_index",ty="vector_index",tb="sparse_vector_index",tv="int_inverted_index",tx="float_inverted_index",tC="bool_inverted_index",t$=class{constructor(){this.type="FtsIndexConfig"}},t_=class{constructor(){this.type="StringInvertedIndexConfig"}},tk=class{constructor(){this.type="IntInvertedIndexConfig"}},tE=class{constructor(){this.type="FloatInvertedIndexConfig"}},tS=class{constructor(){this.type="BoolInvertedIndexConfig"}},tI=class{constructor(e={}){this.type="VectorIndexConfig",this.space=e.space??null,this.embeddingFunction=e.embeddingFunction,this.sourceKey=e.sourceKey instanceof eM?e.sourceKey.name:e.sourceKey??null,this.hnsw=e.hnsw??null,this.spann=e.spann??null}},tO=class{constructor(e={}){this.type="SparseVectorIndexConfig",this.embeddingFunction=e.embeddingFunction,this.sourceKey=e.sourceKey instanceof eM?e.sourceKey.name:e.sourceKey??null,this.bm25=e.bm25??null}},tT=class{constructor(e,t){this.enabled=e,this.config=t}},tj=class{constructor(e,t){this.enabled=e,this.config=t}},tA=class{constructor(e,t){this.enabled=e,this.config=t}},tF=class{constructor(e,t){this.enabled=e,this.config=t}},tN=class{constructor(e,t){this.enabled=e,this.config=t}},tV=class{constructor(e,t){this.enabled=e,this.config=t}},tz=class{constructor(e,t){this.enabled=e,this.config=t}},tq=class{constructor(e=null,t=null){this.ftsIndex=e,this.stringInvertedIndex=t}},tD=class{constructor(e=null){this.vectorIndex=e}},tJ=class{constructor(e=null){this.sparseVectorIndex=e}},tR=class{constructor(e=null){this.intInvertedIndex=e}},tP=class{constructor(e=null){this.floatInvertedIndex=e}},tK=class{constructor(e=null){this.boolInvertedIndex=e}},tU=class{constructor(){this.string=null,this.floatList=null,this.sparseVector=null,this.intValue=null,this.floatValue=null,this.boolean=null}},tB=e=>null==e||"object"!=typeof e?e:Array.isArray(e)?e.map(e=>tB(e)):Object.fromEntries(Object.entries(e).map(([e,t])=>[e,tB(t)])),tL=e=>{if(e){if("function"==typeof e.name)try{let t=e.name();return"string"==typeof t?t:void 0}catch(e){return}if("string"==typeof e.name)return e.name}},tM=e=>{if(!e)return{type:"legacy"};let t=tL(e),n="function"==typeof e.getConfig?e.getConfig.bind(e):void 0,i=e.constructor?.buildFromConfig;if(!t||!n||"function"!=typeof i)return{type:"legacy"};let r=n();return"function"==typeof e.validateConfig&&e.validateConfig(r),{type:"known",name:t,config:r}},tH=e=>e??new tU,tG=e=>(e.string||(e.string=new tq),e.string),tW=e=>(e.floatList||(e.floatList=new tD),e.floatList),tQ=e=>(e.sparseVector||(e.sparseVector=new tJ),e.sparseVector),tY=e=>(e.intValue||(e.intValue=new tR),e.intValue),tX=e=>(e.floatValue||(e.floatValue=new tP),e.floatValue),tZ=e=>(e.boolean||(e.boolean=new tK),e.boolean),t0=class e{constructor(){this.defaults=new tU,this.keys={},this.cmek=null,this.initializeDefaults(),this.initializeKeys()}setCmek(e){return this.cmek=e,this}createIndex(e,t){let n=null!=e,i=null!=t;if(!n&&!i)throw Error("Cannot enable all index types globally. Must specify either config or key.");if(i&&t&&(t===tl||t===to))throw Error(`Cannot create index on special key '${t}'. These keys are managed automatically by the system.`);if(e instanceof tI){if(!i)return this.setVectorIndexConfig(e),this;throw Error("Vector index cannot be enabled on specific keys. Use createIndex(config=VectorIndexConfig(...)) without specifying a key to configure the vector index globally.")}if(e instanceof t$){if(!i)return this.setFtsIndexConfig(e),this;throw Error("FTS index cannot be enabled on specific keys. Use createIndex(config=FtsIndexConfig(...)) without specifying a key to configure the FTS index globally.")}if(e instanceof tO&&!i)throw Error("Sparse vector index must be created on a specific key. Please specify a key using: createIndex(config=SparseVectorIndexConfig(...), key='your_key')");if(!n&&i&&t)throw Error(`Cannot enable all index types for key '${t}'. Please specify a specific index configuration.`);return n&&!i?this.setIndexInDefaults(e,!0):n&&i&&t&&this.setIndexForKey(t,e,!0),this}deleteIndex(e,t){let n=null!=e,i=null!=t;if(!n&&!i)throw Error("Cannot disable all indexes. Must specify either config or key.");if(i&&t&&(t===tl||t===to))throw Error(`Cannot delete index on special key '${t}'. These keys are managed automatically by the system.`);if(e instanceof tI)throw Error("Deleting vector index is not currently supported.");if(e instanceof t$)throw Error("Deleting FTS index is not currently supported.");if(e instanceof tO)throw Error("Deleting sparse vector index is not currently supported.");if(i&&!n&&t)throw Error(`Cannot disable all index types for key '${t}'. Please specify a specific index configuration.`);return i&&n&&t?this.setIndexForKey(t,e,!1):!i&&n&&this.setIndexInDefaults(e,!1),this}serializeToJSON(){let e=this.serializeValueTypes(this.defaults),t={};for(let[e,n]of Object.entries(this.keys))t[e]=this.serializeValueTypes(n);let n={defaults:e,keys:t};return null!==this.cmek&&(n.cmek=this.cmek.toJSON()),n}static async deserializeFromJSON(t,n){if(null==t)return;let i=Object.create(e.prototype);for(let[r,a]of(i.defaults=await e.deserializeValueTypes(t.defaults??{},n),i.keys={},Object.entries(t.keys??{})))i.keys[r]=await e.deserializeValueTypes(a,n);return i.cmek=null,t.cmek&&"object"==typeof t.cmek&&(i.cmek=td.fromJSON(t.cmek)),i}setVectorIndexConfig(e){let t=tW(this.defaults),n=t.vectorIndex??new tA(!1,new tI);t.vectorIndex=new tA(n.enabled,new tI({space:e.space??null,embeddingFunction:e.embeddingFunction,sourceKey:e.sourceKey??null,hnsw:e.hnsw?tB(e.hnsw):null,spann:e.spann?tB(e.spann):null}));let i=tH(this.keys[tl]);this.keys[tl]=i;let r=tW(i),a=r.vectorIndex??new tA(!0,new tI({sourceKey:to})),s=a.config.sourceKey??to;r.vectorIndex=new tA(a.enabled,new tI({space:e.space??null,embeddingFunction:e.embeddingFunction,sourceKey:s,hnsw:e.hnsw?tB(e.hnsw):null,spann:e.spann?tB(e.spann):null}))}setFtsIndexConfig(e){let t=tG(this.defaults),n=t.ftsIndex??new tT(!1,new t$);t.ftsIndex=new tT(n.enabled,e);let i=tH(this.keys[to]);this.keys[to]=i;let r=tG(i),a=r.ftsIndex??new tT(!0,new t$);r.ftsIndex=new tT(a.enabled,e)}setIndexInDefaults(e,t){e instanceof t$?tG(this.defaults).ftsIndex=new tT(t,e):e instanceof t_?tG(this.defaults).stringInvertedIndex=new tj(t,e):e instanceof tI?tW(this.defaults).vectorIndex=new tA(t,e):e instanceof tO?tQ(this.defaults).sparseVectorIndex=new tF(t,e):e instanceof tk?tY(this.defaults).intInvertedIndex=new tN(t,e):e instanceof tE?tX(this.defaults).floatInvertedIndex=new tV(t,e):e instanceof tS&&(tZ(this.defaults).boolInvertedIndex=new tz(t,e))}setIndexForKey(e,t,n){t instanceof tO&&n&&(this.validateSingleSparseVectorIndex(e),this.validateSparseVectorConfig(t));let i=this.keys[e]=tH(this.keys[e]);t instanceof t_?tG(i).stringInvertedIndex=new tj(n,t):t instanceof t$?tG(i).ftsIndex=new tT(n,t):t instanceof tO?tQ(i).sparseVectorIndex=new tF(n,t):t instanceof tI?tW(i).vectorIndex=new tA(n,t):t instanceof tk?tY(i).intInvertedIndex=new tN(n,t):t instanceof tE?tX(i).floatInvertedIndex=new tV(n,t):t instanceof tS&&(tZ(i).boolInvertedIndex=new tz(n,t))}enableAllIndexesForKey(e){if(e===tl||e===to)throw Error(`Cannot enable all indexes for special key '${e}'. These keys are managed automatically by the system.`);let t=this.keys[e]=tH(this.keys[e]);t.string=new tq(new tT(!0,new t$),new tj(!0,new t_)),t.floatList=new tD(new tA(!0,new tI)),t.sparseVector=new tJ(new tF(!1,new tO)),t.intValue=new tR(new tN(!0,new tk)),t.floatValue=new tP(new tV(!0,new tE)),t.boolean=new tK(new tz(!0,new tS))}disableAllIndexesForKey(e){if(e===tl||e===to)throw Error(`Cannot disable all indexes for special key '${e}'. These keys are managed automatically by the system.`);let t=this.keys[e]=tH(this.keys[e]);t.string=new tq(new tT(!1,new t$),new tj(!1,new t_)),t.floatList=new tD(new tA(!1,new tI)),t.sparseVector=new tJ(new tF(!1,new tO)),t.intValue=new tR(new tN(!1,new tk)),t.floatValue=new tP(new tV(!1,new tE)),t.boolean=new tK(new tz(!1,new tS))}validateSingleSparseVectorIndex(e){for(let[t,n]of Object.entries(this.keys)){if(t===e)continue;let i=n.sparseVector?.sparseVectorIndex;if(i?.enabled)throw Error(`Cannot enable sparse vector index on key '${e}'. A sparse vector index is already enabled on key '${t}'. Only one sparse vector index is allowed per collection.`)}}validateSparseVectorConfig(e){if(null!==e.sourceKey&&void 0!==e.sourceKey&&!e.embeddingFunction)throw Error(`If sourceKey is provided then embeddingFunction must also be provided since there is no default embedding function. Config: ${JSON.stringify(e)}`)}initializeDefaults(){this.defaults.string=new tq(new tT(!1,new t$),new tj(!0,new t_)),this.defaults.floatList=new tD(new tA(!1,new tI)),this.defaults.sparseVector=new tJ(new tF(!1,new tO)),this.defaults.intValue=new tR(new tN(!0,new tk)),this.defaults.floatValue=new tP(new tV(!0,new tE)),this.defaults.boolean=new tK(new tz(!0,new tS))}initializeKeys(){this.keys[to]=new tU,this.keys[to].string=new tq(new tT(!0,new t$),new tj(!1,new t_)),this.keys[tl]=new tU,this.keys[tl].floatList=new tD(new tA(!0,new tI({sourceKey:to})))}serializeValueTypes(e){let t={};if(e.string){let n=this.serializeStringValueType(e.string);Object.keys(n).length>0&&(t[tu]=n)}if(e.floatList){let n=this.serializeFloatListValueType(e.floatList);Object.keys(n).length>0&&(t[th]=n)}if(e.sparseVector){let n=this.serializeSparseVectorValueType(e.sparseVector);Object.keys(n).length>0&&(t[tp]=n)}if(e.intValue){let n=this.serializeIntValueType(e.intValue);Object.keys(n).length>0&&(t.int=n)}if(e.floatValue){let n=this.serializeFloatValueType(e.floatValue);Object.keys(n).length>0&&(t[tf]=n)}if(e.boolean){let n=this.serializeBoolValueType(e.boolean);Object.keys(n).length>0&&(t[tm]=n)}return t}serializeStringValueType(e){let t={};return e.ftsIndex&&(t[tg]={enabled:e.ftsIndex.enabled,config:this.serializeConfig(e.ftsIndex.config)}),e.stringInvertedIndex&&(t[tw]={enabled:e.stringInvertedIndex.enabled,config:this.serializeConfig(e.stringInvertedIndex.config)}),t}serializeFloatListValueType(e){let t={};return e.vectorIndex&&(t[ty]={enabled:e.vectorIndex.enabled,config:this.serializeConfig(e.vectorIndex.config)}),t}serializeSparseVectorValueType(e){let t={};return e.sparseVectorIndex&&(t[tb]={enabled:e.sparseVectorIndex.enabled,config:this.serializeConfig(e.sparseVectorIndex.config)}),t}serializeIntValueType(e){let t={};return e.intInvertedIndex&&(t[tv]={enabled:e.intInvertedIndex.enabled,config:this.serializeConfig(e.intInvertedIndex.config)}),t}serializeFloatValueType(e){let t={};return e.floatInvertedIndex&&(t[tx]={enabled:e.floatInvertedIndex.enabled,config:this.serializeConfig(e.floatInvertedIndex.config)}),t}serializeBoolValueType(e){let t={};return e.boolInvertedIndex&&(t[tC]={enabled:e.boolInvertedIndex.enabled,config:this.serializeConfig(e.boolInvertedIndex.config)}),t}serializeConfig(e){return e instanceof tI?this.serializeVectorConfig(e):e instanceof tO?this.serializeSparseVectorConfig(e):{}}serializeVectorConfig(e){let t={},n=e.embeddingFunction,i=tM(n);t.embedding_function=i;let r=e.space??null;return!r&&n?.defaultSpace&&(r=n.defaultSpace()),r&&n?.supportedSpaces&&!n.supportedSpaces().includes(r)&&console.warn(`Space '${r}' is not supported by embedding function '${tL(n)??"unknown"}'. Supported spaces: ${n.supportedSpaces().join(", ")}`),r&&(t.space=r),e.sourceKey&&(t.source_key=e.sourceKey),e.hnsw&&(t.hnsw=tB(e.hnsw)),e.spann&&(t.spann=tB(e.spann)),t}serializeSparseVectorConfig(e){let t={},n=e.embeddingFunction;return t.embedding_function=tM(n),e.sourceKey&&(t.source_key=e.sourceKey),"boolean"==typeof e.bm25&&(t.bm25=e.bm25),t}static async deserializeValueTypes(t,n){let i=new tU;return t[tu]&&(i.string=e.deserializeStringValueType(t[tu])),t[th]&&(i.floatList=await e.deserializeFloatListValueType(t[th],n)),t[tp]&&(i.sparseVector=await e.deserializeSparseVectorValueType(t[tp],n)),t.int&&(i.intValue=e.deserializeIntValueType(t.int)),t[tf]&&(i.floatValue=e.deserializeFloatValueType(t[tf])),t[tm]&&(i.boolean=e.deserializeBoolValueType(t[tm])),i}static deserializeStringValueType(e){let t=null,n=null;return e[tg]&&(t=new tT(!!e[tg].enabled,new t$)),e[tw]&&(n=new tj(!!e[tw].enabled,new t_)),new tq(t,n)}static async deserializeFloatListValueType(t,n){let i=null;if(t[ty]){let r=t[ty];i=new tA(!!r.enabled,await e.deserializeVectorConfig(r.config??{},n))}return new tD(i)}static async deserializeSparseVectorValueType(t,n){let i=null;if(t[tb]){let r=t[tb];i=new tF(!!r.enabled,await e.deserializeSparseVectorConfig(r.config??{},n))}return new tJ(i)}static deserializeIntValueType(e){let t=null;return e[tv]&&(t=new tN(!!e[tv].enabled,new tk)),new tR(t)}static deserializeFloatValueType(e){let t=null;return e[tx]&&(t=new tV(!!e[tx].enabled,new tE)),new tP(t)}static deserializeBoolValueType(e){let t=null;return e[tC]&&(t=new tz(!!e[tC].enabled,new tS)),new tK(t)}static async deserializeVectorConfig(e,t){let n=new tI({space:e.space??null,sourceKey:e.source_key??null,hnsw:e.hnsw?tB(e.hnsw):null,spann:e.spann?tB(e.spann):null});return n.embeddingFunction=await eI({collectionName:"schema deserialization",client:t,efConfig:e.embedding_function}),!n.space&&n.embeddingFunction?.defaultSpace&&(n.space=n.embeddingFunction.defaultSpace()),n}static async deserializeSparseVectorConfig(e,t){let n=new tO({sourceKey:e.source_key??null,bm25:"boolean"==typeof e.bm25?e.bm25:null}),i=await eO("schema deserialization",t,e.embedding_function)??n.embeddingFunction??void 0;return n.embeddingFunction=i??null,n}resolveEmbeddingFunction(){let e=this.keys[tl]?.floatList?.vectorIndex?.config.embeddingFunction;return void 0!==e?e:this.defaults.floatList?.vectorIndex?.config.embeddingFunction}},t1=class e{constructor({chromaClient:e,apiClient:t,id:n,tenant:i,database:r,name:a,metadata:s,configuration:o,embeddingFunction:l,schema:c}){this.chromaClient=e,this.apiClient=t,this.id=n,this.tenant=i,this.database=r,this._name=a,this._metadata=s,this._configuration=o,this._embeddingFunction=l,this._schema=c}get name(){return this._name}set name(e){this._name=e}get configuration(){return this._configuration}set configuration(e){this._configuration=e}get metadata(){return this._metadata}set metadata(e){this._metadata=e}get embeddingFunction(){return this._embeddingFunction}set embeddingFunction(e){this._embeddingFunction=e}get schema(){return this._schema}set schema(e){this._schema=e}async path(){return{tenant:this.tenant,database:this.database,collection_id:this.id}}async embed(e,t){let n=this._embeddingFunction??this.getSchemaEmbeddingFunction();if(!n)throw new B("Embedding function must be defined for operations requiring embeddings.");return t&&n.generateForQueries?await n.generateForQueries(e):await n.generate(e)}async sparseEmbed(e,t,n){return n&&e.generateForQueries?await e.generateForQueries(t):await e.generate(t)}getSparseEmbeddingTargets(){let e=this._schema;if(!e)return{};let t={};for(let[n,i]of Object.entries(e.keys)){let e=i.sparseVector,r=e?.sparseVectorIndex;if(!r?.enabled)continue;let a=r.config;a.embeddingFunction&&a.sourceKey&&(t[n]=a)}return t}async applySparseEmbeddingsToMetadatas(e,t){let n=this.getSparseEmbeddingTargets();if(0===Object.keys(n).length)return e;if(!e){if(!t)return;e=Array(t.length).fill(null).map(()=>({}))}let i=e.map(e=>null!=e?{...e}:{}),r=t?[...t]:void 0;for(let[e,t]of Object.entries(n)){let n=t.sourceKey,a=t.embeddingFunction;if(!n||!a)continue;let s=[],o=[];if(n===to){if(!r||(i.forEach((t,n)=>{if(!(e in t)&&n<r.length){let e=r[n];"string"==typeof e&&(s.push(e),o.push(n))}}),0===s.length))continue;let t=await this.sparseEmbed(a,s,!1);if(t.length!==o.length)throw new B("Sparse embedding function returned unexpected number of embeddings.");o.forEach((n,r)=>{i[n][e]=t[r]});continue}if(i.forEach((t,i)=>{if(e in t)return;let r=t[n];"string"==typeof r&&(s.push(r),o.push(i))}),0===s.length)continue;let l=await this.sparseEmbed(a,s,!1);if(l.length!==o.length)throw new B("Sparse embedding function returned unexpected number of embeddings.");o.forEach((t,n)=>{i[t][e]=l[n]})}return i.map(e=>0===Object.keys(e).length?null:e)}async embedKnnLiteral(e){let t=e.query;if("string"!=typeof t)return{...e};let n=e.key,i="string"==typeof n?n:tl;if(i===tl){let n=await this.embed([t],!0);if(!n||1!==n.length)throw new B("Embedding function returned unexpected number of embeddings.");return{...e,query:n[0]}}let r=this._schema;if(!r)throw new B(`Cannot embed string query for key '${i}': schema is not available. Provide an embedded vector or configure an embedding function.`);let a=r.keys[i];if(!a)throw new B(`Cannot embed string query for key '${i}': key not found in schema. Provide an embedded vector or configure an embedding function.`);let s=a.sparseVector?.sparseVectorIndex;if(s?.enabled&&s.config.embeddingFunction){let n=s.config.embeddingFunction,i=await this.sparseEmbed(n,[t],!0);if(!i||1!==i.length)throw new B("Sparse embedding function returned unexpected number of embeddings.");return{...e,query:i[0]}}let o=a.floatList?.vectorIndex;if(o?.enabled&&o.config.embeddingFunction){let n=o.config.embeddingFunction,i=n.generateForQueries?await n.generateForQueries([t]):await n.generate([t]);if(!i||1!==i.length)throw new B("Embedding function returned unexpected number of embeddings.");return{...e,query:i[0]}}throw new B(`Cannot embed string query for key '${i}': no embedding function configured. Provide an embedded vector or configure an embedding function.`)}async embedRankLiteral(e){return null==e?e:Array.isArray(e)?Promise.all(e.map(e=>this.embedRankLiteral(e))):eN(e)?Object.fromEntries(await Promise.all(Object.entries(e).map(async([e,t])=>"$knn"===e&&eN(t)?[e,await this.embedKnnLiteral(t)]:[e,await this.embedRankLiteral(t)]))):e}async embedSearchPayload(e){if(!e.rank)return e;let t=await this.embedRankLiteral(e.rank);return eN(t)?{...e,rank:t}:e}getSchemaEmbeddingFunction(){let e=this._schema;if(!e)return;let t=e.keys[tl];return t?.floatList?.vectorIndex?.config.embeddingFunction||(e.defaults.floatList?.vectorIndex?.config.embeddingFunction??void 0)}async prepareRecords({recordSet:e,update:t=!1}){let n=await this.chromaClient.getMaxBatchSize();Q(e),Z(e.ids),eh({recordSet:e,update:t}),ep(e.ids.length,n),!e.embeddings&&e.documents&&(e.embeddings=await this.embed(e.documents,!1));let i=await this.applySparseEmbeddingsToMetadatas(e.metadatas,e.documents),r={...e,metadatas:i};return await this.chromaClient.supportsBase64Encoding()&&e.embeddings&&(r.embeddings=ev(e.embeddings)),r}validateGet(e,t,n,i){eg({include:e,exclude:["distances"]}),t&&Z(t),n&&ef(n),i&&em(i)}async prepareQuery(e,t,n,i,r,a){let s;return eh({recordSet:e,embeddingsField:"queryEmbeddings",documentsField:"queryTexts"}),eg({include:t}),n&&Z(n),i&&ef(i),r&&em(r),a&&ew(a),s=e.embeddings?e.embeddings:await this.embed(e.documents,!0),{...e,ids:n,embeddings:s}}validateDelete(e,t,n){e&&Z(e),t&&ef(t),n&&em(n)}async count(){let{data:e}=await q.collectionCount({client:this.apiClient,path:await this.path()});return e}async add({ids:e,embeddings:t,metadatas:n,documents:i,uris:r}){let a=await this.prepareRecords({recordSet:{ids:e,embeddings:t,documents:i,metadatas:n,uris:r}});await q.collectionAdd({client:this.apiClient,path:await this.path(),body:{ids:a.ids,embeddings:a.embeddings,documents:a.documents,metadatas:ea(a.metadatas),uris:a.uris}})}async get(e={}){let{ids:t,where:n,limit:i,offset:r,whereDocument:a,include:s=["documents","metadatas"]}=e;this.validateGet(s,t,n,a);let{data:o}=await q.collectionGet({client:this.apiClient,path:await this.path(),body:{ids:t,where:n,limit:i,offset:r,where_document:a,include:s}}),l=ec(o.metadatas)??[];return new u({documents:o.documents??[],embeddings:o.embeddings??[],ids:o.ids,include:o.include,metadatas:l,uris:o.uris??[]})}async peek({limit:e=10}){return this.get({limit:e})}async query({queryEmbeddings:e,queryTexts:t,queryURIs:n,ids:i,nResults:r=10,where:a,whereDocument:s,include:o=["metadatas","documents","distances"]}){let l=await this.prepareQuery({embeddings:e,documents:t,uris:n},o,i,a,s,r),{data:c}=await q.collectionQuery({client:this.apiClient,path:await this.path(),body:{ids:l.ids,include:o,n_results:r,query_embeddings:l.embeddings,where:a,where_document:s}}),d=ed(c.metadatas)??[];return new h({distances:c.distances??[],documents:c.documents??[],embeddings:c.embeddings??[],ids:c.ids??[],include:c.include,metadatas:d,uris:c.uris??[]})}async search(e){let t=Array.isArray(e)?e:[e];if(0===t.length)throw new B("At least one search payload must be provided.");let n=await Promise.all(t.map(async e=>{let t=tr(e).toPayload();return this.embedSearchPayload(t)})),{data:i}=await q.collectionSearch({client:this.apiClient,path:await this.path(),body:{searches:n}});return new ts(i)}async modify({name:e,metadata:t,configuration:n}){e&&(this.name=e),t&&(et(t),this.metadata=t);let{updateConfiguration:i,updateEmbeddingFunction:r}=n?await eF({collectionName:this.name,currentConfiguration:this.configuration,newConfiguration:n,currentEmbeddingFunction:this.embeddingFunction,client:this.chromaClient}):{};r&&(this.embeddingFunction=r),i&&(this.configuration={hnsw:{...this.configuration.hnsw,...i.hnsw},spann:{...this.configuration.spann,...i.spann},embeddingFunction:i.embedding_function}),await q.updateCollection({client:this.apiClient,path:await this.path(),body:{new_name:e,new_metadata:er(t),new_configuration:i}})}async fork({name:t}){let{data:n}=await q.forkCollection({client:this.apiClient,path:await this.path(),body:{new_name:t}});return new e({chromaClient:this.chromaClient,apiClient:this.apiClient,name:n.name,tenant:this.tenant,database:this.database,id:n.id,embeddingFunction:this._embeddingFunction,metadata:el(n.metadata??void 0)??void 0,configuration:n.configuration_json})}async update({ids:e,embeddings:t,metadatas:n,documents:i,uris:r}){let a=await this.prepareRecords({recordSet:{ids:e,embeddings:t,documents:i,metadatas:n,uris:r},update:!0});await q.collectionUpdate({client:this.apiClient,path:await this.path(),body:{ids:a.ids,embeddings:a.embeddings,metadatas:ea(a.metadatas),uris:a.uris,documents:a.documents}})}async upsert({ids:e,embeddings:t,metadatas:n,documents:i,uris:r}){let a=await this.prepareRecords({recordSet:{ids:e,embeddings:t,documents:i,metadatas:n,uris:r}});await q.collectionUpsert({client:this.apiClient,path:await this.path(),body:{ids:a.ids,embeddings:a.embeddings,metadatas:ea(a.metadatas),uris:a.uris,documents:a.documents}})}async delete({ids:e,where:t,whereDocument:n}){this.validateDelete(e,t,n),await q.collectionDelete({client:this.apiClient,path:await this.path(),body:{ids:e,where:t,where_document:n}})}},t2=e=>!!((e?.name==="TypeError"||e?.name==="FetchError")&&(e.message?.includes("fetch failed")||e.message?.includes("Failed to fetch")||e.message?.includes("ENOTFOUND"))),t4=async e=>{try{let t=await e.clone().json();return t.message||t.error||`${e.status}: ${e.statusText}`}catch{return`${e.status}: ${e.statusText}`}},t5=async(e,t)=>{let n;try{n=await fetch(e,t)}catch(e){if(t2(e))throw new D("Failed to connect to chromadb. Make sure your server is running and try again. If you are running from a browser, make sure that your chromadb instance is configured to allow requests from the current origin using the CHROMA_SERVER_CORS_ALLOW_ORIGINS environment variable.");throw new D("Failed to connect to Chroma")}if(n.ok)return n;switch(n.status){case 400:let i="Bad Request";try{i=(await n.json()).message||i}catch{}throw new R(`Bad request to ${e.url||"Chroma"} with status: ${i}`);case 401:throw new P("Unauthorized");case 403:throw new K("You do not have permission to access the requested resource.");case 404:throw new U("The requested resource could not be found");case 409:throw new L("The resource already exists");case 422:try{let e=await n.json();if(e&&e.message&&(e.message.startsWith("Quota exceeded")||e.message.startsWith("Billing limit exceeded")))throw new M(e?.message);throw new R(e?.message||"Unprocessable Entity")}catch(e){if(e instanceof M||e instanceof R)throw e;throw new R(`Unprocessable Entity: ${n.statusText}`)}case 429:throw new H("Rate limit exceeded")}throw new J(await t4(n))},t6=e=>{if(e)return(e.keys[tl]?.floatList?.vectorIndex?.config.embeddingFunction??void 0)||(e.defaults.floatList?.vectorIndex?.config.embeddingFunction??void 0)},t9=class{constructor(e={}){let{host:t=G.host,port:n=G.port,ssl:i=G.ssl,tenant:r=G.tenant,database:a=G.database,headers:s=G.headers,fetchOptions:o=G.fetchOptions}=e;if(e.path){console.warn("The 'path' argument is deprecated. Please use 'ssl', 'host', and 'port' instead");let r=ey(e.path);i=r.ssl,t=r.host,n=r.port}e.auth&&(console.warn("The 'auth' argument is deprecated. Please use 'headers' instead"),s||(s={}),!s["x-chroma-token"]&&"X_CHROMA_TOKEN"===e.auth.tokenHeaderType&&e.auth.credentials&&(s["x-chroma-token"]=e.auth.credentials));let c=`${i?"https":"http"}://${t}:${n}`;this._tenant=r||l.env.CHROMA_TENANT,this._database=a||l.env.CHROMA_DATABASE,this._headers=s;let d={...o,method:W(o?.method),baseUrl:c,headers:s};this.apiClient=V(N(d)),this.apiClient.setConfig({fetch:t5})}get tenant(){return this._tenant}set tenant(e){this._tenant=e}get database(){return this._database}set database(e){this._database=e}get preflightChecks(){return this._preflightChecks}set preflightChecks(e){this._preflightChecks=e}get headers(){return this._headers}async _path(){if(!this._tenant||!this._database){let{tenant:e,databases:t}=await this.getUserIdentity(),n=[...new Set(t)];if(this._tenant=e,0===n.length)throw new P(`Your API key does not have access to any DBs for tenant ${this.tenant}`);if(n.length>1||"*"===n[0])throw new B("Your API key is scoped to more than 1 DB. Please provide a DB name to the CloudClient constructor");this._database=n[0]}return{tenant:this._tenant,database:this._database}}async getUserIdentity(){let{data:e}=await q.getUserIdentity({client:this.apiClient});return e}async heartbeat(){let{data:e}=await q.heartbeat({client:this.apiClient});return e["nanosecond heartbeat"]}async listCollections(e){let{limit:t=100,offset:n=0}=e||{},{data:i}=await q.listCollections({client:this.apiClient,path:await this._path(),query:{limit:t,offset:n}});return Promise.all(i.map(async e=>{let t=await t0.deserializeFromJSON(e.schema??null,this),n=t6(t),i=await eI({collectionName:e.name,client:this,efConfig:e.configuration_json.embedding_function??void 0})??n;return new t1({chromaClient:this,apiClient:this.apiClient,tenant:e.tenant,database:e.database,name:e.name,id:e.id,embeddingFunction:i,configuration:e.configuration_json,metadata:el(e.metadata??void 0)??void 0,schema:t})}))}async countCollections(){let{data:e}=await q.countCollections({client:this.apiClient,path:await this._path()});return e}async createCollection({name:e,configuration:t,metadata:n,embeddingFunction:i,schema:r}){let a=await eA({configuration:t,embeddingFunction:i,metadata:n,schema:r}),{data:s}=await q.createCollection({client:this.apiClient,path:await this._path(),body:{name:e,configuration:a,metadata:er(n),get_or_create:!1,schema:r?r.serializeToJSON():void 0}}),o=await t0.deserializeFromJSON(s.schema??null,this),l=t6(o),c=i??await eI({collectionName:s.name,client:this,efConfig:s.configuration_json.embedding_function??void 0})??l;return new t1({chromaClient:this,apiClient:this.apiClient,name:e,tenant:s.tenant,database:s.database,configuration:s.configuration_json,metadata:el(s.metadata??void 0)??void 0,embeddingFunction:c,id:s.id,schema:o})}async getCollection({name:e,embeddingFunction:t}){let{data:n}=await q.getCollection({client:this.apiClient,path:{...await this._path(),collection_id:e}}),i=await t0.deserializeFromJSON(n.schema??null,this),r=t6(i),a=t??await eI({collectionName:n.name,client:this,efConfig:n.configuration_json.embedding_function??void 0})??r;return new t1({chromaClient:this,apiClient:this.apiClient,name:e,tenant:n.tenant,database:n.database,configuration:n.configuration_json,metadata:el(n.metadata??void 0)??void 0,embeddingFunction:a,id:n.id,schema:i})}async getCollectionByCrn(e){let{data:t}=await q.getCollectionByCrn({client:this.apiClient,path:{crn:e}}),n=await t0.deserializeFromJSON(t.schema??null,this),i=t6(n),r=await eI({collectionName:t.name,efConfig:t.configuration_json.embedding_function??void 0,client:this})??i;return new t1({chromaClient:this,apiClient:this.apiClient,name:t.name,tenant:t.tenant,database:t.database,configuration:t.configuration_json,metadata:el(t.metadata??void 0)??void 0,embeddingFunction:r,id:t.id,schema:n})}async getCollections(e){if(0===e.length)return[];let t=e;return"string"==typeof e[0]&&(t=e.map(e=>({name:e,embeddingFunction:void 0}))),Promise.all(t.map(async e=>this.getCollection({...e})))}async getOrCreateCollection({name:e,configuration:t,metadata:n,embeddingFunction:i,schema:r}){let a=await eA({configuration:t,embeddingFunction:i,metadata:n,schema:r}),{data:s}=await q.createCollection({client:this.apiClient,path:await this._path(),body:{name:e,configuration:a,metadata:er(n),get_or_create:!0,schema:r?r.serializeToJSON():void 0}}),o=await t0.deserializeFromJSON(s.schema??null,this),l=t6(o),c=i??await eI({collectionName:e,efConfig:s.configuration_json.embedding_function??void 0,client:this})??l;return new t1({chromaClient:this,apiClient:this.apiClient,name:e,tenant:s.tenant,database:s.database,configuration:s.configuration_json,metadata:el(s.metadata??void 0)??void 0,embeddingFunction:c,id:s.id,schema:o})}async deleteCollection({name:e}){await q.deleteCollection({client:this.apiClient,path:{...await this._path(),collection_id:e}})}async reset(){await q.reset({client:this.apiClient})}async version(){let{data:e}=await q.version({client:this.apiClient});return e}async getPreflightChecks(){if(!this.preflightChecks){let{data:e}=await q.preFlightChecks({client:this.apiClient});this.preflightChecks=e}return this.preflightChecks}async getMaxBatchSize(){return(await this.getPreflightChecks()).max_batch_size??-1}async supportsBase64Encoding(){return(await this.getPreflightChecks()).supports_base64_encoding??!1}},t7=class extends t9{constructor(e={}){let t=e.apiKey||l.env.CHROMA_API_KEY;if(!t)throw new B("Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable");let n=e.tenant||l.env.CHROMA_TENANT,i=e.database||l.env.CHROMA_DATABASE;super({host:e.host||"api.trychroma.com",port:e.port||443,ssl:!0,tenant:n,database:i,headers:{"x-chroma-token":t},fetchOptions:e.fetchOptions}),this.tenant=n,this.database=i}}}};