"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chromadb";
exports.ids = ["vendor-chunks/chromadb"];
exports.modules = {

/***/ "(rsc)/./node_modules/chromadb/dist/chromadb.mjs":
/*!*************************************************!*\
  !*** ./node_modules/chromadb/dist/chromadb.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Abs: () => (/* binding */ Abs),\n/* harmony export */   AdminClient: () => (/* binding */ AdminClient),\n/* harmony export */   AdminCloudClient: () => (/* binding */ AdminCloudClient),\n/* harmony export */   Aggregate: () => (/* binding */ Aggregate),\n/* harmony export */   BoolInvertedIndexConfig: () => (/* binding */ BoolInvertedIndexConfig),\n/* harmony export */   BoolInvertedIndexType: () => (/* binding */ BoolInvertedIndexType),\n/* harmony export */   BoolValueType: () => (/* binding */ BoolValueType),\n/* harmony export */   ChromaClient: () => (/* binding */ ChromaClient),\n/* harmony export */   ChromaClientError: () => (/* binding */ ChromaClientError),\n/* harmony export */   ChromaConnectionError: () => (/* binding */ ChromaConnectionError),\n/* harmony export */   ChromaError: () => (/* binding */ ChromaError),\n/* harmony export */   ChromaForbiddenError: () => (/* binding */ ChromaForbiddenError),\n/* harmony export */   ChromaNotFoundError: () => (/* binding */ ChromaNotFoundError),\n/* harmony export */   ChromaQuotaExceededError: () => (/* binding */ ChromaQuotaExceededError),\n/* harmony export */   ChromaRateLimitError: () => (/* binding */ ChromaRateLimitError),\n/* harmony export */   ChromaServerError: () => (/* binding */ ChromaServerError),\n/* harmony export */   ChromaUnauthorizedError: () => (/* binding */ ChromaUnauthorizedError),\n/* harmony export */   ChromaUniqueError: () => (/* binding */ ChromaUniqueError),\n/* harmony export */   ChromaValueError: () => (/* binding */ ChromaValueError),\n/* harmony export */   CloudClient: () => (/* binding */ CloudClient),\n/* harmony export */   Cmek: () => (/* binding */ Cmek),\n/* harmony export */   CmekProvider: () => (/* binding */ CmekProvider),\n/* harmony export */   DOCUMENT_KEY: () => (/* binding */ DOCUMENT_KEY),\n/* harmony export */   Div: () => (/* binding */ Div),\n/* harmony export */   EMBEDDING_KEY: () => (/* binding */ EMBEDDING_KEY),\n/* harmony export */   Exp: () => (/* binding */ Exp),\n/* harmony export */   FloatInvertedIndexConfig: () => (/* binding */ FloatInvertedIndexConfig),\n/* harmony export */   FloatInvertedIndexType: () => (/* binding */ FloatInvertedIndexType),\n/* harmony export */   FloatListValueType: () => (/* binding */ FloatListValueType),\n/* harmony export */   FloatValueType: () => (/* binding */ FloatValueType),\n/* harmony export */   FtsIndexConfig: () => (/* binding */ FtsIndexConfig),\n/* harmony export */   FtsIndexType: () => (/* binding */ FtsIndexType),\n/* harmony export */   GetResult: () => (/* binding */ GetResult),\n/* harmony export */   GroupBy: () => (/* binding */ GroupBy),\n/* harmony export */   IncludeEnum: () => (/* binding */ IncludeEnum),\n/* harmony export */   IntInvertedIndexConfig: () => (/* binding */ IntInvertedIndexConfig),\n/* harmony export */   IntInvertedIndexType: () => (/* binding */ IntInvertedIndexType),\n/* harmony export */   IntValueType: () => (/* binding */ IntValueType),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidCollectionError: () => (/* binding */ InvalidCollectionError),\n/* harmony export */   K: () => (/* binding */ K),\n/* harmony export */   Key: () => (/* binding */ Key),\n/* harmony export */   Knn: () => (/* binding */ Knn),\n/* harmony export */   Limit: () => (/* binding */ Limit),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   Max: () => (/* binding */ Max),\n/* harmony export */   MaxK: () => (/* binding */ MaxK),\n/* harmony export */   Min: () => (/* binding */ Min),\n/* harmony export */   MinK: () => (/* binding */ MinK),\n/* harmony export */   Mul: () => (/* binding */ Mul),\n/* harmony export */   QueryResult: () => (/* binding */ QueryResult),\n/* harmony export */   RankExpression: () => (/* binding */ RankExpression),\n/* harmony export */   Rrf: () => (/* binding */ Rrf),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Search: () => (/* binding */ Search),\n/* harmony export */   SearchResult: () => (/* binding */ SearchResult),\n/* harmony export */   Select: () => (/* binding */ Select),\n/* harmony export */   SparseVectorIndexConfig: () => (/* binding */ SparseVectorIndexConfig),\n/* harmony export */   SparseVectorIndexType: () => (/* binding */ SparseVectorIndexType),\n/* harmony export */   SparseVectorValueType: () => (/* binding */ SparseVectorValueType),\n/* harmony export */   StringInvertedIndexConfig: () => (/* binding */ StringInvertedIndexConfig),\n/* harmony export */   StringInvertedIndexType: () => (/* binding */ StringInvertedIndexType),\n/* harmony export */   StringValueType: () => (/* binding */ StringValueType),\n/* harmony export */   Sub: () => (/* binding */ Sub),\n/* harmony export */   Sum: () => (/* binding */ Sum),\n/* harmony export */   Val: () => (/* binding */ Val),\n/* harmony export */   ValueTypes: () => (/* binding */ ValueTypes),\n/* harmony export */   VectorIndexConfig: () => (/* binding */ VectorIndexConfig),\n/* harmony export */   VectorIndexType: () => (/* binding */ VectorIndexType),\n/* harmony export */   WhereExpression: () => (/* binding */ WhereExpression),\n/* harmony export */   baseRecordSetFields: () => (/* binding */ baseRecordSetFields),\n/* harmony export */   createErrorByType: () => (/* binding */ createErrorByType),\n/* harmony export */   getDefaultEFConfig: () => (/* binding */ getDefaultEFConfig),\n/* harmony export */   getEmbeddingFunction: () => (/* binding */ getEmbeddingFunction),\n/* harmony export */   getSparseEmbeddingFunction: () => (/* binding */ getSparseEmbeddingFunction),\n/* harmony export */   knownEmbeddingFunctions: () => (/* binding */ knownEmbeddingFunctions),\n/* harmony export */   knownSparseEmbeddingFunctions: () => (/* binding */ knownSparseEmbeddingFunctions),\n/* harmony export */   processCreateCollectionConfig: () => (/* binding */ processCreateCollectionConfig),\n/* harmony export */   processUpdateCollectionConfig: () => (/* binding */ processUpdateCollectionConfig),\n/* harmony export */   recordSetFields: () => (/* binding */ recordSetFields),\n/* harmony export */   registerEmbeddingFunction: () => (/* binding */ registerEmbeddingFunction),\n/* harmony export */   registerSparseEmbeddingFunction: () => (/* binding */ registerSparseEmbeddingFunction),\n/* harmony export */   serializeEmbeddingFunction: () => (/* binding */ serializeEmbeddingFunction),\n/* harmony export */   toSearch: () => (/* binding */ toSearch),\n/* harmony export */   withChroma: () => (/* binding */ withChroma)\n/* harmony export */ });\n/* harmony import */ var _chunk_NSSMTXJJ_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-NSSMTXJJ.mjs */ \"(rsc)/./node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs\");\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:process */ \"node:process\");\n\n\n// src/deno.ts\nif (typeof globalThis.Deno !== \"undefined\") {\n  const OriginalRequest = globalThis.Request;\n  const PatchedRequest = function(input, init) {\n    if (init && typeof init === \"object\") {\n      const cleanInit = { ...init };\n      if (\"client\" in cleanInit) {\n        delete cleanInit.client;\n      }\n      return new OriginalRequest(input, cleanInit);\n    }\n    return new OriginalRequest(input, init);\n  };\n  Object.setPrototypeOf(PatchedRequest, OriginalRequest);\n  Object.defineProperty(PatchedRequest, \"prototype\", {\n    value: OriginalRequest.prototype,\n    writable: false\n  });\n  globalThis.Request = PatchedRequest;\n}\n\n// src/types.ts\nvar baseRecordSetFields = [\n  \"ids\",\n  \"embeddings\",\n  \"metadatas\",\n  \"documents\",\n  \"uris\"\n];\nvar recordSetFields = [...baseRecordSetFields, \"ids\"];\nvar IncludeEnum = /* @__PURE__ */ ((IncludeEnum2) => {\n  IncludeEnum2[\"distances\"] = \"distances\";\n  IncludeEnum2[\"documents\"] = \"documents\";\n  IncludeEnum2[\"embeddings\"] = \"embeddings\";\n  IncludeEnum2[\"metadatas\"] = \"metadatas\";\n  IncludeEnum2[\"uris\"] = \"uris\";\n  return IncludeEnum2;\n})(IncludeEnum || {});\nvar GetResult = class {\n  /**\n   * Creates a new GetResult instance.\n   * @param data - The result data containing all fields\n   */\n  constructor({\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris\n  }) {\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n  /**\n   * Converts the result to a row-based format for easier iteration.\n   * @returns Object containing include fields and array of record objects\n   */\n  rows() {\n    return this.ids.map((id, index) => {\n      return {\n        id,\n        document: this.include.includes(\"documents\") ? this.documents[index] : void 0,\n        embedding: this.include.includes(\"embeddings\") ? this.embeddings[index] : void 0,\n        metadata: this.include.includes(\"metadatas\") ? this.metadatas[index] : void 0,\n        uri: this.include.includes(\"uris\") ? this.uris[index] : void 0\n      };\n    });\n  }\n};\nvar QueryResult = class {\n  /**\n   * Creates a new QueryResult instance.\n   * @param data - The query result data containing all fields\n   */\n  constructor({\n    distances,\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris\n  }) {\n    this.distances = distances;\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n  /**\n   * Converts the query result to a row-based format for easier iteration.\n   * @returns Object containing include fields and structured query results\n   */\n  rows() {\n    const queries = [];\n    for (let q2 = 0; q2 < this.ids.length; q2++) {\n      const records = this.ids[q2].map((id, index) => {\n        return {\n          id,\n          document: this.include.includes(\"documents\") ? this.documents[q2][index] : void 0,\n          embedding: this.include.includes(\"embeddings\") ? this.embeddings[q2][index] : void 0,\n          metadata: this.include.includes(\"metadatas\") ? this.metadatas[q2][index] : void 0,\n          uri: this.include.includes(\"uris\") ? this.uris[q2][index] : void 0,\n          distance: this.include.includes(\"distances\") ? this.distances[q2][index] : void 0\n        };\n      });\n      queries.push(records);\n    }\n    return queries;\n  }\n};\n\n// ../../node_modules/.pnpm/@hey-api+client-fetch@0.10.0_@hey-api+openapi-ts@0.67.3_typescript@5.8.3_/node_modules/@hey-api/client-fetch/dist/index.js\nvar A = async (t, r) => {\n  let e = typeof r == \"function\" ? await r(t) : r;\n  if (e) return t.scheme === \"bearer\" ? `Bearer ${e}` : t.scheme === \"basic\" ? `Basic ${btoa(e)}` : e;\n};\nvar R = { bodySerializer: (t) => JSON.stringify(t, (r, e) => typeof e == \"bigint\" ? e.toString() : e) };\nvar U = (t) => {\n  switch (t) {\n    case \"label\":\n      return \".\";\n    case \"matrix\":\n      return \";\";\n    case \"simple\":\n      return \",\";\n    default:\n      return \"&\";\n  }\n};\nvar _ = (t) => {\n  switch (t) {\n    case \"form\":\n      return \",\";\n    case \"pipeDelimited\":\n      return \"|\";\n    case \"spaceDelimited\":\n      return \"%20\";\n    default:\n      return \",\";\n  }\n};\nvar D = (t) => {\n  switch (t) {\n    case \"label\":\n      return \".\";\n    case \"matrix\":\n      return \";\";\n    case \"simple\":\n      return \",\";\n    default:\n      return \"&\";\n  }\n};\nvar O = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {\n  if (!r) {\n    let s = (t ? i : i.map((l) => encodeURIComponent(l))).join(_(a));\n    switch (a) {\n      case \"label\":\n        return `.${s}`;\n      case \"matrix\":\n        return `;${e}=${s}`;\n      case \"simple\":\n        return s;\n      default:\n        return `${e}=${s}`;\n    }\n  }\n  let o = U(a), n = i.map((s) => a === \"label\" || a === \"simple\" ? t ? s : encodeURIComponent(s) : y({ allowReserved: t, name: e, value: s })).join(o);\n  return a === \"label\" || a === \"matrix\" ? o + n : n;\n};\nvar y = ({ allowReserved: t, name: r, value: e }) => {\n  if (e == null) return \"\";\n  if (typeof e == \"object\") throw new Error(\"Deeply-nested arrays/objects aren\\u2019t supported. Provide your own `querySerializer()` to handle these.\");\n  return `${r}=${t ? e : encodeURIComponent(e)}`;\n};\nvar q = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {\n  if (i instanceof Date) return `${e}=${i.toISOString()}`;\n  if (a !== \"deepObject\" && !r) {\n    let s = [];\n    Object.entries(i).forEach(([f, u]) => {\n      s = [...s, f, t ? u : encodeURIComponent(u)];\n    });\n    let l = s.join(\",\");\n    switch (a) {\n      case \"form\":\n        return `${e}=${l}`;\n      case \"label\":\n        return `.${l}`;\n      case \"matrix\":\n        return `;${e}=${l}`;\n      default:\n        return l;\n    }\n  }\n  let o = D(a), n = Object.entries(i).map(([s, l]) => y({ allowReserved: t, name: a === \"deepObject\" ? `${e}[${s}]` : s, value: l })).join(o);\n  return a === \"label\" || a === \"matrix\" ? o + n : n;\n};\nvar H = /\\{[^{}]+\\}/g;\nvar B = ({ path: t, url: r }) => {\n  let e = r, a = r.match(H);\n  if (a) for (let i of a) {\n    let o = false, n = i.substring(1, i.length - 1), s = \"simple\";\n    n.endsWith(\"*\") && (o = true, n = n.substring(0, n.length - 1)), n.startsWith(\".\") ? (n = n.substring(1), s = \"label\") : n.startsWith(\";\") && (n = n.substring(1), s = \"matrix\");\n    let l = t[n];\n    if (l == null) continue;\n    if (Array.isArray(l)) {\n      e = e.replace(i, O({ explode: o, name: n, style: s, value: l }));\n      continue;\n    }\n    if (typeof l == \"object\") {\n      e = e.replace(i, q({ explode: o, name: n, style: s, value: l }));\n      continue;\n    }\n    if (s === \"matrix\") {\n      e = e.replace(i, `;${y({ name: n, value: l })}`);\n      continue;\n    }\n    let f = encodeURIComponent(s === \"label\" ? `.${l}` : l);\n    e = e.replace(i, f);\n  }\n  return e;\n};\nvar E = ({ allowReserved: t, array: r, object: e } = {}) => (i) => {\n  let o = [];\n  if (i && typeof i == \"object\") for (let n in i) {\n    let s = i[n];\n    if (s != null) {\n      if (Array.isArray(s)) {\n        o = [...o, O({ allowReserved: t, explode: true, name: n, style: \"form\", value: s, ...r })];\n        continue;\n      }\n      if (typeof s == \"object\") {\n        o = [...o, q({ allowReserved: t, explode: true, name: n, style: \"deepObject\", value: s, ...e })];\n        continue;\n      }\n      o = [...o, y({ allowReserved: t, name: n, value: s })];\n    }\n  }\n  return o.join(\"&\");\n};\nvar P = (t) => {\n  if (!t) return \"stream\";\n  let r = t.split(\";\")[0]?.trim();\n  if (r) {\n    if (r.startsWith(\"application/json\") || r.endsWith(\"+json\")) return \"json\";\n    if (r === \"multipart/form-data\") return \"formData\";\n    if ([\"application/\", \"audio/\", \"image/\", \"video/\"].some((e) => r.startsWith(e))) return \"blob\";\n    if (r.startsWith(\"text/\")) return \"text\";\n  }\n};\nvar I = async ({ security: t, ...r }) => {\n  for (let e of t) {\n    let a = await A(e, r.auth);\n    if (!a) continue;\n    let i = e.name ?? \"Authorization\";\n    switch (e.in) {\n      case \"query\":\n        r.query || (r.query = {}), r.query[i] = a;\n        break;\n      case \"cookie\":\n        r.headers.append(\"Cookie\", `${i}=${a}`);\n        break;\n      case \"header\":\n      default:\n        r.headers.set(i, a);\n        break;\n    }\n    return;\n  }\n};\nvar S = (t) => W({ baseUrl: t.baseUrl, path: t.path, query: t.query, querySerializer: typeof t.querySerializer == \"function\" ? t.querySerializer : E(t.querySerializer), url: t.url });\nvar W = ({ baseUrl: t, path: r, query: e, querySerializer: a, url: i }) => {\n  let o = i.startsWith(\"/\") ? i : `/${i}`, n = (t ?? \"\") + o;\n  r && (n = B({ path: r, url: n }));\n  let s = e ? a(e) : \"\";\n  return s.startsWith(\"?\") && (s = s.substring(1)), s && (n += `?${s}`), n;\n};\nvar C = (t, r) => {\n  let e = { ...t, ...r };\n  return e.baseUrl?.endsWith(\"/\") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = x(t.headers, r.headers), e;\n};\nvar x = (...t) => {\n  let r = new Headers();\n  for (let e of t) {\n    if (!e || typeof e != \"object\") continue;\n    let a = e instanceof Headers ? e.entries() : Object.entries(e);\n    for (let [i, o] of a) if (o === null) r.delete(i);\n    else if (Array.isArray(o)) for (let n of o) r.append(i, n);\n    else o !== void 0 && r.set(i, typeof o == \"object\" ? JSON.stringify(o) : o);\n  }\n  return r;\n};\nvar h = class {\n  constructor() {\n    (0,_chunk_NSSMTXJJ_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"_fns\");\n    this._fns = [];\n  }\n  clear() {\n    this._fns = [];\n  }\n  exists(r) {\n    return this._fns.indexOf(r) !== -1;\n  }\n  eject(r) {\n    let e = this._fns.indexOf(r);\n    e !== -1 && (this._fns = [...this._fns.slice(0, e), ...this._fns.slice(e + 1)]);\n  }\n  use(r) {\n    this._fns = [...this._fns, r];\n  }\n};\nvar T = () => ({ error: new h(), request: new h(), response: new h() });\nvar N = E({ allowReserved: false, array: { explode: true, style: \"form\" }, object: { explode: true, style: \"deepObject\" } });\nvar Q = { \"Content-Type\": \"application/json\" };\nvar w = (t = {}) => ({ ...R, headers: Q, parseAs: \"auto\", querySerializer: N, ...t });\nvar J = (t = {}) => {\n  let r = C(w(), t), e = () => ({ ...r }), a = (n) => (r = C(r, n), e()), i = T(), o = async (n) => {\n    let s = { ...r, ...n, fetch: n.fetch ?? r.fetch ?? globalThis.fetch, headers: x(r.headers, n.headers) };\n    s.security && await I({ ...s, security: s.security }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === \"\") && s.headers.delete(\"Content-Type\");\n    let l = S(s), f = { redirect: \"follow\", ...s }, u = new Request(l, f);\n    for (let p of i.request._fns) u = await p(u, s);\n    let k = s.fetch, c = await k(u);\n    for (let p of i.response._fns) c = await p(c, u, s);\n    let m = { request: u, response: c };\n    if (c.ok) {\n      if (c.status === 204 || c.headers.get(\"Content-Length\") === \"0\") return { data: {}, ...m };\n      let p = (s.parseAs === \"auto\" ? P(c.headers.get(\"Content-Type\")) : s.parseAs) ?? \"json\";\n      if (p === \"stream\") return { data: c.body, ...m };\n      let b = await c[p]();\n      return p === \"json\" && (s.responseValidator && await s.responseValidator(b), s.responseTransformer && (b = await s.responseTransformer(b))), { data: b, ...m };\n    }\n    let g = await c.text();\n    try {\n      g = JSON.parse(g);\n    } catch {\n    }\n    let d = g;\n    for (let p of i.error._fns) d = await p(g, c, u, s);\n    if (d = d || {}, s.throwOnError) throw d;\n    return { error: d, ...m };\n  };\n  return { buildUrl: S, connect: (n) => o({ ...n, method: \"CONNECT\" }), delete: (n) => o({ ...n, method: \"DELETE\" }), get: (n) => o({ ...n, method: \"GET\" }), getConfig: e, head: (n) => o({ ...n, method: \"HEAD\" }), interceptors: i, options: (n) => o({ ...n, method: \"OPTIONS\" }), patch: (n) => o({ ...n, method: \"PATCH\" }), post: (n) => o({ ...n, method: \"POST\" }), put: (n) => o({ ...n, method: \"PUT\" }), request: o, setConfig: a, trace: (n) => o({ ...n, method: \"TRACE\" }) };\n};\n\n// src/api/client.gen.ts\nvar client = J(w({\n  baseUrl: \"http://localhost:8000\",\n  throwOnError: true\n}));\n\n// src/api/sdk.gen.ts\nvar DefaultService = class {\n  /**\n   * Retrieves the current user's identity, tenant, and databases.\n   */\n  static getUserIdentity(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/auth/identity\",\n      ...options\n    });\n  }\n  /**\n   * Retrieves a collection by Chroma Resource Name.\n   */\n  static getCollectionByCrn(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/collections/{crn}\",\n      ...options\n    });\n  }\n  /**\n   * Health check endpoint that returns 200 if the server and executor are ready\n   */\n  static healthcheck(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/healthcheck\",\n      ...options\n    });\n  }\n  /**\n   * Heartbeat endpoint that returns a nanosecond timestamp of the current time.\n   */\n  static heartbeat(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/heartbeat\",\n      ...options\n    });\n  }\n  /**\n   * Pre-flight checks endpoint reporting basic readiness info.\n   */\n  static preFlightChecks(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/pre-flight-checks\",\n      ...options\n    });\n  }\n  /**\n   * Reset endpoint allowing authorized users to reset the database.\n   */\n  static reset(options) {\n    return (options?.client ?? client).post({\n      url: \"/api/v2/reset\",\n      ...options\n    });\n  }\n  /**\n   * Creates a new tenant.\n   */\n  static createTenant(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Returns an existing tenant by name.\n   */\n  static getTenant(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant_name}\",\n      ...options\n    });\n  }\n  /**\n   * Updates an existing tenant by name.\n   */\n  static updateTenant(options) {\n    return (options.client ?? client).patch({\n      url: \"/api/v2/tenants/{tenant_name}\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Lists all databases for a given tenant.\n   */\n  static listDatabases(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases\",\n      ...options\n    });\n  }\n  /**\n   * Creates a new database for a given tenant.\n   */\n  static createDatabase(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Deletes a specific database.\n   */\n  static deleteDatabase(options) {\n    return (options.client ?? client).delete({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}\",\n      ...options\n    });\n  }\n  /**\n   * Retrieves a specific database by name.\n   */\n  static getDatabase(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}\",\n      ...options\n    });\n  }\n  /**\n   * Lists all collections in the specified database.\n   */\n  static listCollections(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections\",\n      ...options\n    });\n  }\n  /**\n   * Creates a new collection under the specified database.\n   */\n  static createCollection(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Deletes a collection in a given database.\n   */\n  static deleteCollection(options) {\n    return (options.client ?? client).delete({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}\",\n      ...options\n    });\n  }\n  /**\n   * Retrieves a collection by ID or name.\n   */\n  static getCollection(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}\",\n      ...options\n    });\n  }\n  /**\n   * Updates an existing collection's name or metadata.\n   */\n  static updateCollection(options) {\n    return (options.client ?? client).put({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Adds records to a collection.\n   */\n  static collectionAdd(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/add\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Detach a function\n   */\n  static detachFunction(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/attached_functions/{name}/detach\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Retrieves the number of records in a collection.\n   */\n  static collectionCount(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/count\",\n      ...options\n    });\n  }\n  /**\n   * Deletes records in a collection. Can filter by IDs or metadata.\n   */\n  static collectionDelete(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/delete\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Forks an existing collection.\n   */\n  static forkCollection(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/fork\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Attach a function to a collection\n   */\n  static attachFunction(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/functions/attach\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Get an attached function by name\n   */\n  static getAttachedFunction(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/functions/{function_name}\",\n      ...options\n    });\n  }\n  /**\n   * Retrieves records from a collection by ID or metadata filter.\n   */\n  static collectionGet(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/get\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Query a collection in a variety of ways, including vector search, metadata filtering, and full-text search\n   */\n  static collectionQuery(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/query\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Search records from a collection with hybrid criterias.\n   */\n  static collectionSearch(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/search\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Updates records in a collection by ID.\n   */\n  static collectionUpdate(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/update\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Upserts records in a collection (create if not exists, otherwise update).\n   */\n  static collectionUpsert(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/upsert\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Retrieves the total number of collections in a given database.\n   */\n  static countCollections(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections_count\",\n      ...options\n    });\n  }\n  /**\n   * Returns the version of the server.\n   */\n  static version(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/version\",\n      ...options\n    });\n  }\n};\n\n// src/errors.ts\nvar ChromaError = class extends Error {\n  constructor(name, message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = name;\n  }\n};\nvar ChromaConnectionError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaConnectionError\";\n  }\n};\nvar ChromaServerError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaServerError\";\n  }\n};\nvar ChromaClientError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaClientError\";\n  }\n};\nvar ChromaUnauthorizedError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaAuthError\";\n  }\n};\nvar ChromaForbiddenError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaForbiddenError\";\n  }\n};\nvar ChromaNotFoundError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaNotFoundError\";\n  }\n};\nvar ChromaValueError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaValueError\";\n  }\n};\nvar InvalidCollectionError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"InvalidCollectionError\";\n  }\n};\nvar InvalidArgumentError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"InvalidArgumentError\";\n  }\n};\nvar ChromaUniqueError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaUniqueError\";\n  }\n};\nvar ChromaQuotaExceededError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaQuotaExceededError\";\n  }\n};\nvar ChromaRateLimitError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaRateLimitError\";\n  }\n};\nfunction createErrorByType(type, message) {\n  switch (type) {\n    case \"InvalidCollection\":\n      return new InvalidCollectionError(message);\n    case \"InvalidArgumentError\":\n      return new InvalidArgumentError(message);\n    default:\n      return void 0;\n  }\n}\n\n// src/utils.ts\nvar DEFAULT_TENANT = \"default_tenant\";\nvar DEFAULT_DATABASE = \"default_database\";\nvar defaultAdminClientArgs = {\n  host: \"localhost\",\n  port: 8e3,\n  ssl: false\n};\nvar defaultChromaClientArgs = {\n  ...defaultAdminClientArgs,\n  tenant: DEFAULT_TENANT,\n  database: DEFAULT_DATABASE\n};\nvar normalizeMethod = (method) => {\n  if (method) {\n    switch (method.toUpperCase()) {\n      case \"GET\":\n        return \"GET\";\n      case \"POST\":\n        return \"POST\";\n      case \"PUT\":\n        return \"PUT\";\n      case \"DELETE\":\n        return \"DELETE\";\n      case \"HEAD\":\n        return \"HEAD\";\n      case \"CONNECT\":\n        return \"CONNECT\";\n      case \"OPTIONS\":\n        return \"OPTIONS\";\n      case \"PATCH\":\n        return \"PATCH\";\n      case \"TRACE\":\n        return \"TRACE\";\n      default:\n        return void 0;\n    }\n  }\n  return void 0;\n};\nvar validateRecordSetLengthConsistency = (recordSet) => {\n  const lengths = Object.entries(recordSet).filter(\n    ([field, value]) => recordSetFields.includes(field) && value !== void 0\n  ).map(([field, value]) => [field, value.length]);\n  if (lengths.length === 0) {\n    throw new ChromaValueError(\n      `At least one of ${recordSetFields.join(\", \")} must be provided`\n    );\n  }\n  const zeroLength = lengths.filter(([_2, length]) => length === 0).map(([field, _2]) => field);\n  if (zeroLength.length > 0) {\n    throw new ChromaValueError(\n      `Non-empty lists are required for ${zeroLength.join(\", \")}`\n    );\n  }\n  if (new Set(lengths.map(([_2, length]) => length)).size > 1) {\n    throw new ChromaValueError(\n      `Unequal lengths for fields ${lengths.map(([field, _2]) => field).join(\", \")}`\n    );\n  }\n};\nvar validateEmbeddings = ({\n  embeddings,\n  fieldName = \"embeddings\"\n}) => {\n  if (!Array.isArray(embeddings)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof embeddings}`\n    );\n  }\n  if (embeddings.length === 0) {\n    throw new ChromaValueError(\n      \"Expected embeddings to be an array with at least one item\"\n    );\n  }\n  if (!embeddings.filter((e) => e.every((n) => typeof n === \"number\"))) {\n    throw new ChromaValueError(\n      \"Expected each embedding to be an array of numbers\"\n    );\n  }\n  embeddings.forEach((embedding, i) => {\n    if (embedding.length === 0) {\n      throw new ChromaValueError(\n        `Expected each embedding to be a non-empty array of numbers, but got an empty array at index ${i}`\n      );\n    }\n  });\n};\nvar validateDocuments = ({\n  documents,\n  nullable = false,\n  fieldName = \"documents\"\n}) => {\n  if (!Array.isArray(documents)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof documents}`\n    );\n  }\n  if (documents.length === 0) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be a non-empty list`\n    );\n  }\n  documents.forEach((document) => {\n    if (!nullable && typeof document !== \"string\" && !document) {\n      throw new ChromaValueError(\n        `Expected each document to be a string, but got ${typeof document}`\n      );\n    }\n  });\n};\nvar validateIDs = (ids) => {\n  if (!Array.isArray(ids)) {\n    throw new ChromaValueError(\n      `Expected 'ids' to be an array, but got ${typeof ids}`\n    );\n  }\n  if (ids.length === 0) {\n    throw new ChromaValueError(\"Expected 'ids' to be a non-empty list\");\n  }\n  const nonStrings = ids.map((id, i) => [id, i]).filter(([id, _2]) => typeof id !== \"string\").map(([_2, i]) => i);\n  if (nonStrings.length > 0) {\n    throw new ChromaValueError(\n      `Found non-string IDs at ${nonStrings.join(\", \")}`\n    );\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const duplicates = ids.filter((id) => {\n    if (seen.has(id)) {\n      return id;\n    }\n    seen.add(id);\n  });\n  let message = \"Expected IDs to be unique, but found duplicates of\";\n  if (duplicates.length > 0 && duplicates.length <= 5) {\n    throw new ChromaValueError(`${message} ${duplicates.join(\", \")}`);\n  }\n  if (duplicates.length > 0) {\n    throw new ChromaValueError(\n      `${message} ${duplicates.slice(0, 5).join(\", \")}, ..., ${duplicates.slice(duplicates.length - 5).join(\", \")}`\n    );\n  }\n};\nvar validateSparseVector = (v) => {\n  if (typeof v !== \"object\" || v === null) {\n    return false;\n  }\n  const candidate = v;\n  const indices = candidate.indices;\n  const values = candidate.values;\n  if (!Array.isArray(indices) || !Array.isArray(values)) {\n    return false;\n  }\n  return indices.every((e) => typeof e === \"number\") && values.every((e) => typeof e === \"number\");\n};\nvar validateMetadata = (metadata) => {\n  if (!metadata) {\n    return;\n  }\n  if (Object.keys(metadata).length === 0) {\n    throw new ChromaValueError(\"Expected metadata to be non-empty\");\n  }\n  if (!Object.values(metadata).every(\n    (v) => v === null || v === void 0 || typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\" || validateSparseVector(v)\n  )) {\n    throw new ChromaValueError(\n      \"Expected metadata to be a string, number, boolean, SparseVector, or nullable\"\n    );\n  }\n};\nvar SPARSE_VECTOR_TYPE = \"sparse_vector\";\nvar toSerializedSparseVector = (vector) => ({\n  \"#type\": SPARSE_VECTOR_TYPE,\n  indices: vector.indices,\n  values: vector.values\n});\nvar serializeMetadata = (metadata) => {\n  if (metadata === void 0) {\n    return void 0;\n  }\n  if (metadata === null) {\n    return null;\n  }\n  const result = {};\n  Object.entries(metadata).forEach(([key, value]) => {\n    if (validateSparseVector(value)) {\n      result[key] = toSerializedSparseVector(value);\n    } else {\n      result[key] = value ?? null;\n    }\n  });\n  return result;\n};\nvar serializeMetadatas = (metadatas) => {\n  if (metadatas === void 0) {\n    return void 0;\n  }\n  if (metadatas === null) {\n    return null;\n  }\n  return metadatas.map((metadata) => serializeMetadata(metadata) ?? null);\n};\nvar isSerializedSparseVector = (value) => {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const candidate = value;\n  if (candidate[\"#type\"] !== SPARSE_VECTOR_TYPE) {\n    return false;\n  }\n  return validateSparseVector(candidate);\n};\nvar deserializeMetadataValue = (value) => {\n  if (isSerializedSparseVector(value)) {\n    return {\n      indices: value.indices,\n      values: value.values\n    };\n  }\n  return value;\n};\nvar deserializeMetadata = (metadata) => {\n  if (metadata === void 0) {\n    return void 0;\n  }\n  if (metadata === null) {\n    return null;\n  }\n  const result = {};\n  Object.entries(metadata).forEach(([key, value]) => {\n    result[key] = deserializeMetadataValue(value);\n  });\n  return result;\n};\nvar deserializeMetadatas = (metadatas) => {\n  if (metadatas === void 0) {\n    return void 0;\n  }\n  if (metadatas === null) {\n    return null;\n  }\n  return metadatas.map((metadata) => deserializeMetadata(metadata) ?? null);\n};\nvar deserializeMetadataMatrix = (metadatas) => {\n  if (metadatas === void 0) {\n    return void 0;\n  }\n  if (metadatas === null) {\n    return null;\n  }\n  return metadatas.map((metadataArray) => {\n    if (metadataArray === null) {\n      return null;\n    }\n    const deserialized = deserializeMetadatas(metadataArray);\n    return deserialized ?? [];\n  });\n};\nvar validateMetadatas = (metadatas) => {\n  if (!Array.isArray(metadatas)) {\n    throw new ChromaValueError(\n      `Expected metadatas to be an array, but got ${typeof metadatas}`\n    );\n  }\n  metadatas.forEach((metadata) => validateMetadata(metadata));\n};\nvar validateBaseRecordSet = ({\n  recordSet,\n  update = false,\n  embeddingsField = \"embeddings\",\n  documentsField = \"documents\"\n}) => {\n  if (!recordSet.embeddings && !recordSet.documents && !update) {\n    throw new ChromaValueError(\n      `At least one of '${embeddingsField}' and '${documentsField}' must be provided`\n    );\n  }\n  if (recordSet.embeddings) {\n    validateEmbeddings({\n      embeddings: recordSet.embeddings,\n      fieldName: embeddingsField\n    });\n  }\n  if (recordSet.documents) {\n    validateDocuments({\n      documents: recordSet.documents,\n      fieldName: documentsField\n    });\n  }\n  if (recordSet.metadatas) {\n    validateMetadatas(recordSet.metadatas);\n  }\n};\nvar validateMaxBatchSize = (recordSetLength, maxBatchSize) => {\n  if (recordSetLength > maxBatchSize) {\n    throw new ChromaValueError(\n      `Record set length ${recordSetLength} exceeds max batch size ${maxBatchSize}`\n    );\n  }\n};\nvar validateWhere = (where) => {\n  if (typeof where !== \"object\") {\n    throw new ChromaValueError(\"Expected where to be a non-empty object\");\n  }\n  if (Object.keys(where).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'where' to have exactly one operator, but got ${Object.keys(where).length}`\n    );\n  }\n  Object.entries(where).forEach(([key, value]) => {\n    if (key !== \"$and\" && key !== \"$or\" && key !== \"$in\" && key !== \"$nin\" && ![\"string\", \"number\", \"boolean\", \"object\"].includes(typeof value)) {\n      throw new ChromaValueError(\n        `Expected 'where' value to be a string, number, boolean, or an operator expression, but got ${value}`\n      );\n    }\n    if (key === \"$and\" || key === \"$or\") {\n      if (Object.keys(value).length <= 1) {\n        throw new ChromaValueError(\n          `Expected 'where' value for $and or $or to be a list of 'where' expressions, but got ${value}`\n        );\n      }\n      value.forEach((w2) => validateWhere(w2));\n      return;\n    }\n    if (typeof value === \"object\") {\n      if (Object.keys(value).length != 1) {\n        throw new ChromaValueError(\n          `Expected operator expression to have one operator, but got ${value}`\n        );\n      }\n      const [operator, operand] = Object.entries(value)[0];\n      if ([\"$gt\", \"$gte\", \"$lt\", \"$lte\"].includes(operator) && typeof operand !== \"number\") {\n        throw new ChromaValueError(\n          `Expected operand value to be a number for ${operator}, but got ${typeof operand}`\n        );\n      }\n      if ([\"$in\", \"$nin\"].includes(operator) && !Array.isArray(operand)) {\n        throw new ChromaValueError(\n          `Expected operand value to be an array for ${operator}, but got ${operand}`\n        );\n      }\n      if (![\"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$ne\", \"$eq\", \"$in\", \"$nin\"].includes(\n        operator\n      )) {\n        throw new ChromaValueError(\n          `Expected operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, but got ${operator}`\n        );\n      }\n      if (![\"string\", \"number\", \"boolean\"].includes(typeof operand) && !Array.isArray(operand)) {\n        throw new ChromaValueError(\n          \"Expected operand value to be a string, number, boolean, or a list of those types\"\n        );\n      }\n      if (Array.isArray(operand) && (operand.length === 0 || !operand.every((item) => typeof item === typeof operand[0]))) {\n        throw new ChromaValueError(\n          \"Expected 'where' operand value to be a non-empty list and all values to be of the same type\"\n        );\n      }\n    }\n  });\n};\nvar validateWhereDocument = (whereDocument) => {\n  if (typeof whereDocument !== \"object\") {\n    throw new ChromaValueError(\n      \"Expected 'whereDocument' to be a non-empty object\"\n    );\n  }\n  if (Object.keys(whereDocument).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' to have exactly one operator, but got ${whereDocument}`\n    );\n  }\n  const [operator, operand] = Object.entries(whereDocument)[0];\n  if (![\n    \"$contains\",\n    \"$not_contains\",\n    \"$matches\",\n    \"$not_matches\",\n    \"$regex\",\n    \"$not_regex\",\n    \"$and\",\n    \"$or\"\n  ].includes(operator)) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' operator to be one of $contains, $not_contains, $matches, $not_matches, $regex, $not_regex, $and, or $or, but got ${operator}`\n    );\n  }\n  if (operator === \"$and\" || operator === \"$or\") {\n    if (!Array.isArray(operand)) {\n      throw new ChromaValueError(\n        `Expected operand for ${operator} to be a list of 'whereDocument' expressions, but got ${operand}`\n      );\n    }\n    if (operand.length <= 1) {\n      throw new ChromaValueError(\n        `Expected 'whereDocument' operand for ${operator} to be a list with at least two 'whereDocument' expressions`\n      );\n    }\n    operand.forEach((item) => validateWhereDocument(item));\n  }\n  if ((operand === \"$contains\" || operand === \"$not_contains\" || operand === \"$regex\" || operand === \"$not_regex\") && (typeof operator !== \"string\" || operator.length === 0)) {\n    throw new ChromaValueError(\n      `Expected operand for ${operator} to be a non empty string, but got ${operand}`\n    );\n  }\n};\nvar validateInclude = ({\n  include,\n  exclude\n}) => {\n  if (!Array.isArray(include)) {\n    throw new ChromaValueError(\"Expected 'include' to be a non-empty array\");\n  }\n  const validValues = Object.keys(IncludeEnum);\n  include.forEach((item) => {\n    if (typeof item !== \"string\") {\n      throw new ChromaValueError(\"Expected 'include' items to be strings\");\n    }\n    if (!validValues.includes(item)) {\n      throw new ChromaValueError(\n        `Expected 'include' items to be one of ${validValues.join(\n          \", \"\n        )}, but got ${item}`\n      );\n    }\n    if (exclude?.includes(item)) {\n      throw new ChromaValueError(`${item} is not allowed for this operation`);\n    }\n  });\n};\nvar validateNResults = (nResults) => {\n  if (typeof nResults !== \"number\") {\n    throw new ChromaValueError(\n      `Expected 'nResults' to be a number, but got ${typeof nResults}`\n    );\n  }\n  if (nResults <= 0) {\n    throw new ChromaValueError(\"Number of requested results has to positive\");\n  }\n};\nvar parseConnectionPath = (path) => {\n  try {\n    const url = new URL(path);\n    const ssl = url.protocol === \"https:\";\n    const host = url.hostname;\n    const port = url.port;\n    return {\n      ssl,\n      host,\n      port: Number(port)\n    };\n  } catch {\n    throw new ChromaValueError(`Invalid URL: ${path}`);\n  }\n};\nvar packEmbedding = (embedding) => {\n  const buffer = new ArrayBuffer(embedding.length * 4);\n  const view = new Float32Array(buffer);\n  for (let i = 0; i < embedding.length; i++) {\n    view[i] = embedding[i];\n  }\n  return buffer;\n};\nvar embeddingsToBase64Bytes = (embeddings) => {\n  return embeddings.map((embedding) => {\n    const buffer = packEmbedding(embedding);\n    const uint8Array = new Uint8Array(buffer);\n    const binaryString = Array.from(\n      uint8Array,\n      (byte) => String.fromCharCode(byte)\n    ).join(\"\");\n    return btoa(binaryString);\n  });\n};\n\n// src/embedding-function.ts\nvar knownEmbeddingFunctions = /* @__PURE__ */ new Map();\nvar pythonEmbeddingFunctions = {\n  onnx_mini_lm_l6_v2: \"default-embed\",\n  default: \"default-embed\",\n  together_ai: \"together-ai\",\n  sentence_transformer: \"sentence-transformer\"\n};\nvar unsupportedEmbeddingFunctions = /* @__PURE__ */ new Set([\n  \"amazon_bedrock\",\n  \"baseten\",\n  \"langchain\",\n  \"google_palm\",\n  \"huggingface\",\n  \"instructor\",\n  \"open_clip\",\n  \"roboflow\",\n  \"text2vec\"\n]);\nvar knownSparseEmbeddingFunctions = /* @__PURE__ */ new Map();\nvar pythonSparseEmbeddingFunctions = {\n  chroma_bm25: \"chroma-bm25\"\n};\nvar unsupportedSparseEmbeddingFunctions = /* @__PURE__ */ new Set([\n  \"bm25\",\n  \"fastembed_sparse\",\n  \"huggingface_sparse\"\n]);\nvar registerEmbeddingFunction = (name, fn) => {\n  if (knownEmbeddingFunctions.has(name)) {\n    throw new ChromaValueError(\n      `Embedding function with name ${name} is already registered.`\n    );\n  }\n  knownEmbeddingFunctions.set(name, fn);\n};\nvar registerSparseEmbeddingFunction = (name, fn) => {\n  if (knownSparseEmbeddingFunctions.has(name)) {\n    throw new ChromaValueError(\n      `Sparse embedding function with name ${name} is already registered.`\n    );\n  }\n  knownSparseEmbeddingFunctions.set(name, fn);\n};\nvar getEmbeddingFunction = async (args) => {\n  const { collectionName, client: client2, efConfig } = args;\n  if (!efConfig) {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  }\n  if (efConfig.type === \"legacy\") {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  }\n  if (efConfig.type === \"unknown\") {\n    console.warn(\n      `Unknown embedding function configuration for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  }\n  if (efConfig.type !== \"known\") {\n    return void 0;\n  }\n  if (unsupportedEmbeddingFunctions.has(efConfig.name)) {\n    console.warn(\n      `Embedding function ${efConfig.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  }\n  const packageName = pythonEmbeddingFunctions[efConfig.name] || efConfig.name;\n  if (packageName === \"default-embed\") {\n    await getDefaultEFConfig();\n  }\n  let embeddingFunction = knownEmbeddingFunctions.get(packageName);\n  if (!embeddingFunction) {\n    try {\n      const fullPackageName = `@chroma-core/${packageName}`;\n      await __webpack_require__(\"(rsc)/./node_modules/chromadb/dist lazy recursive\")(fullPackageName);\n      embeddingFunction = knownEmbeddingFunctions.get(packageName);\n    } catch (error) {\n    }\n    if (!embeddingFunction) {\n      console.warn(\n        `Collection ${collectionName} was created with the ${packageName} embedding function. However, the @chroma-core/${packageName} package is not installed. 'add' and 'query' will fail unless you provide them embeddings directly, or install the @chroma-core/${packageName} package.`\n      );\n      return void 0;\n    }\n  }\n  let constructorConfig = efConfig.type === \"known\" ? efConfig.config : {};\n  try {\n    if (embeddingFunction.buildFromConfig) {\n      return embeddingFunction.buildFromConfig(constructorConfig, client2);\n    }\n    console.warn(\n      `Embedding function ${packageName} does not define a 'buildFromConfig' function. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  } catch (e) {\n    console.warn(\n      `Embedding function ${packageName} failed to build with config: ${constructorConfig}. 'add' and 'query' will fail unless you provide them embeddings directly. Error: ${e}`\n    );\n    return void 0;\n  }\n};\nvar getSparseEmbeddingFunction = async (collectionName, client2, efConfig) => {\n  if (!efConfig) {\n    return void 0;\n  }\n  if (efConfig.type === \"legacy\") {\n    return void 0;\n  }\n  if (efConfig.type !== \"known\") {\n    return void 0;\n  }\n  if (unsupportedSparseEmbeddingFunctions.has(efConfig.name)) {\n    console.warn(\n      \"Embedding function ${efConfig.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.\"\n    );\n    return void 0;\n  }\n  const packageName = pythonSparseEmbeddingFunctions[efConfig.name] || efConfig.name;\n  let sparseEmbeddingFunction = knownSparseEmbeddingFunctions.get(packageName);\n  if (!sparseEmbeddingFunction) {\n    try {\n      const fullPackageName = `@chroma-core/${packageName}`;\n      await __webpack_require__(\"(rsc)/./node_modules/chromadb/dist lazy recursive\")(fullPackageName);\n      sparseEmbeddingFunction = knownSparseEmbeddingFunctions.get(packageName);\n    } catch (error) {\n    }\n    if (!sparseEmbeddingFunction) {\n      console.warn(\n        `Collection ${collectionName} was created with the ${packageName} sparse embedding function. However, the @chroma-core/${packageName} package is not installed.`\n      );\n      return void 0;\n    }\n  }\n  let constructorConfig = efConfig.type === \"known\" ? efConfig.config : {};\n  try {\n    if (sparseEmbeddingFunction.buildFromConfig) {\n      return sparseEmbeddingFunction.buildFromConfig(constructorConfig, client2);\n    }\n    console.warn(\n      `Sparse embedding function ${packageName} does not define a 'buildFromConfig' function.`\n    );\n    return void 0;\n  } catch (e) {\n    console.warn(\n      `Sparse embedding function ${packageName} failed to build with config: ${constructorConfig}. Error: ${e}`\n    );\n    return void 0;\n  }\n};\nvar serializeEmbeddingFunction = ({\n  embeddingFunction,\n  configEmbeddingFunction\n}) => {\n  if (embeddingFunction && configEmbeddingFunction) {\n    throw new ChromaValueError(\n      \"Embedding function provided when already defined in the collection configuration\"\n    );\n  }\n  if (!embeddingFunction && !configEmbeddingFunction) {\n    return void 0;\n  }\n  const ef = embeddingFunction || configEmbeddingFunction;\n  if (!ef.getConfig || !ef.name || !ef.constructor.buildFromConfig) {\n    return { type: \"legacy\" };\n  }\n  if (ef.validateConfig) ef.validateConfig(ef.getConfig());\n  return {\n    name: ef.name,\n    type: \"known\",\n    config: ef.getConfig()\n  };\n};\nvar getDefaultEFConfig = async () => {\n  try {\n    const { DefaultEmbeddingFunction } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@chroma-core\"), __webpack_require__.e(\"vendor-chunks/onnxruntime-common\"), __webpack_require__.e(\"vendor-chunks/onnxruntime-node\"), __webpack_require__.e(\"vendor-chunks/fast-uri\"), __webpack_require__.e(\"vendor-chunks/@huggingface\"), __webpack_require__.e(\"vendor-chunks/fast-deep-equal\"), __webpack_require__.e(\"_rsc_node_modules_onnxruntime-node_bin_napi-v3_sync_recursive_onnxruntime_binding_node_\")]).then(__webpack_require__.bind(__webpack_require__, /*! @chroma-core/default-embed */ \"(rsc)/./node_modules/@chroma-core/default-embed/dist/default-embed.mjs\"));\n    if (!knownEmbeddingFunctions.has(\"default-embed\")) {\n      registerEmbeddingFunction(\"default-embed\", DefaultEmbeddingFunction);\n    }\n  } catch (e) {\n    console.warn(\n      \"Cannot instantiate a collection with the DefaultEmbeddingFunction. Please install @chroma-core/default-embed, or provide a different embedding function\"\n    );\n  }\n  return {\n    name: \"default\",\n    type: \"known\",\n    config: {}\n  };\n};\n\n// src/collection-configuration.ts\nvar processCreateCollectionConfig = async ({\n  configuration,\n  embeddingFunction,\n  metadata,\n  schema\n}) => {\n  let schemaEmbeddingFunction = void 0;\n  if (schema) {\n    schemaEmbeddingFunction = schema.resolveEmbeddingFunction();\n  }\n  if (configuration?.hnsw && configuration?.spann) {\n    throw new ChromaValueError(\n      \"Cannot specify both HNSW and SPANN configurations\"\n    );\n  }\n  let embeddingFunctionConfiguration = serializeEmbeddingFunction({\n    embeddingFunction: embeddingFunction ?? void 0,\n    configEmbeddingFunction: configuration?.embeddingFunction\n  });\n  if (!embeddingFunctionConfiguration && embeddingFunction !== null && schemaEmbeddingFunction === void 0) {\n    embeddingFunctionConfiguration = await getDefaultEFConfig();\n  }\n  const overallEf = embeddingFunction || configuration?.embeddingFunction;\n  if (overallEf && overallEf.defaultSpace && overallEf.supportedSpaces) {\n    if (configuration?.hnsw === void 0 && configuration?.spann === void 0) {\n      if (metadata === void 0 || metadata?.[\"hnsw:space\"] === void 0) {\n        if (!configuration) configuration = {};\n        configuration.hnsw = { space: overallEf.defaultSpace() };\n      }\n    }\n    if (configuration?.hnsw && !configuration.hnsw.space && overallEf.defaultSpace) {\n      configuration.hnsw.space = overallEf.defaultSpace();\n    }\n    if (configuration?.spann && !configuration.spann.space && overallEf.defaultSpace) {\n      configuration.spann.space = overallEf.defaultSpace();\n    }\n    if (overallEf.supportedSpaces) {\n      const supportedSpaces = overallEf.supportedSpaces();\n      if (configuration?.hnsw?.space && !supportedSpaces.includes(configuration.hnsw.space)) {\n        console.warn(\n          `Space '${configuration.hnsw.space}' is not supported by embedding function '${overallEf.name || \"unknown\"}'. Supported spaces: ${supportedSpaces.join(\", \")}`\n        );\n      }\n      if (configuration?.spann?.space && !supportedSpaces.includes(configuration.spann.space)) {\n        console.warn(\n          `Space '${configuration.spann.space}' is not supported by embedding function '${overallEf.name || \"unknown\"}'. Supported spaces: ${supportedSpaces.join(\", \")}`\n        );\n      }\n      if (!configuration?.hnsw && !configuration?.spann && metadata && typeof metadata[\"hnsw:space\"] === \"string\" && !supportedSpaces.includes(\n        metadata[\"hnsw:space\"]\n      )) {\n        console.warn(\n          `Space '${metadata[\"hnsw:space\"]}' from metadata is not supported by embedding function '${overallEf.name || \"unknown\"}'. Supported spaces: ${supportedSpaces.join(\", \")}`\n        );\n      }\n    }\n  }\n  return {\n    ...configuration || {},\n    embedding_function: embeddingFunctionConfiguration\n  };\n};\nvar processUpdateCollectionConfig = async ({\n  collectionName,\n  currentConfiguration,\n  currentEmbeddingFunction,\n  newConfiguration,\n  client: client2\n}) => {\n  if (newConfiguration.hnsw && typeof newConfiguration.hnsw !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid HNSW config provided in UpdateCollectionConfiguration\"\n    );\n  }\n  if (newConfiguration.spann && typeof newConfiguration.spann !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid SPANN config provided in UpdateCollectionConfiguration\"\n    );\n  }\n  const embeddingFunction = currentEmbeddingFunction || await getEmbeddingFunction({\n    collectionName,\n    client: client2,\n    efConfig: currentConfiguration.embeddingFunction ?? void 0\n  });\n  const newEmbeddingFunction = newConfiguration.embeddingFunction;\n  if (embeddingFunction && embeddingFunction.validateConfigUpdate && newEmbeddingFunction && newEmbeddingFunction.getConfig) {\n    embeddingFunction.validateConfigUpdate(newEmbeddingFunction.getConfig());\n  }\n  return {\n    updateConfiguration: {\n      hnsw: newConfiguration.hnsw,\n      spann: newConfiguration.spann,\n      embedding_function: newEmbeddingFunction && serializeEmbeddingFunction({ embeddingFunction: newEmbeddingFunction })\n    },\n    updateEmbeddingFunction: newEmbeddingFunction\n  };\n};\n\n// src/execution/expression/common.ts\nvar isPlainObject = (value) => {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === Object.prototype || prototype === null;\n};\nvar deepClone = (value) => JSON.parse(JSON.stringify(value));\nvar iterableToArray = (values) => {\n  if (Array.isArray(values)) {\n    return values.slice();\n  }\n  return Array.from(values);\n};\nvar assertNonEmptyArray = (values, message) => {\n  if (values.length === 0) {\n    throw new Error(message);\n  }\n};\n\n// src/execution/expression/where.ts\nvar WhereExpressionBase = class {\n  and(other) {\n    const target = WhereExpression.from(other);\n    if (!target) {\n      return this;\n    }\n    return AndWhere.combine(this, target);\n  }\n  or(other) {\n    const target = WhereExpression.from(other);\n    if (!target) {\n      return this;\n    }\n    return OrWhere.combine(this, target);\n  }\n};\nvar WhereExpression = class _WhereExpression extends WhereExpressionBase {\n  static from(input) {\n    if (input instanceof _WhereExpression) {\n      return input;\n    }\n    if (input === null || input === void 0) {\n      return void 0;\n    }\n    if (!isPlainObject(input)) {\n      throw new TypeError(\"Where input must be a WhereExpression or plain object\");\n    }\n    return parseWhereDict(input);\n  }\n};\nvar AndWhere = class _AndWhere extends WhereExpression {\n  constructor(conditions) {\n    super();\n    this.conditions = conditions;\n  }\n  toJSON() {\n    return { $and: this.conditions.map((condition) => condition.toJSON()) };\n  }\n  get operands() {\n    return this.conditions.slice();\n  }\n  static combine(left, right) {\n    const flattened = [];\n    const add = (expr) => {\n      if (expr instanceof _AndWhere) {\n        flattened.push(...expr.operands);\n      } else {\n        flattened.push(expr);\n      }\n    };\n    add(left);\n    add(right);\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new _AndWhere(flattened);\n  }\n};\nvar OrWhere = class _OrWhere extends WhereExpression {\n  constructor(conditions) {\n    super();\n    this.conditions = conditions;\n  }\n  toJSON() {\n    return { $or: this.conditions.map((condition) => condition.toJSON()) };\n  }\n  get operands() {\n    return this.conditions.slice();\n  }\n  static combine(left, right) {\n    const flattened = [];\n    const add = (expr) => {\n      if (expr instanceof _OrWhere) {\n        flattened.push(...expr.operands);\n      } else {\n        flattened.push(expr);\n      }\n    };\n    add(left);\n    add(right);\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new _OrWhere(flattened);\n  }\n};\nvar ComparisonWhere = class extends WhereExpression {\n  constructor(key, operator, value) {\n    super();\n    this.key = key;\n    this.operator = operator;\n    this.value = value;\n  }\n  toJSON() {\n    return {\n      [this.key]: {\n        [this.operator]: this.value\n      }\n    };\n  }\n};\nvar comparisonOperatorMap = /* @__PURE__ */ new Map([\n  [\"$eq\", (key, value) => new ComparisonWhere(key, \"$eq\", value)],\n  [\"$ne\", (key, value) => new ComparisonWhere(key, \"$ne\", value)],\n  [\"$gt\", (key, value) => new ComparisonWhere(key, \"$gt\", value)],\n  [\"$gte\", (key, value) => new ComparisonWhere(key, \"$gte\", value)],\n  [\"$lt\", (key, value) => new ComparisonWhere(key, \"$lt\", value)],\n  [\"$lte\", (key, value) => new ComparisonWhere(key, \"$lte\", value)],\n  [\"$in\", (key, value) => new ComparisonWhere(key, \"$in\", value)],\n  [\"$nin\", (key, value) => new ComparisonWhere(key, \"$nin\", value)],\n  [\"$contains\", (key, value) => new ComparisonWhere(key, \"$contains\", value)],\n  [\"$not_contains\", (key, value) => new ComparisonWhere(key, \"$not_contains\", value)],\n  [\"$regex\", (key, value) => new ComparisonWhere(key, \"$regex\", value)],\n  [\"$not_regex\", (key, value) => new ComparisonWhere(key, \"$not_regex\", value)]\n]);\nvar parseWhereDict = (data) => {\n  if (\"$and\" in data) {\n    if (Object.keys(data).length !== 1) {\n      throw new Error(\"$and cannot be combined with other keys\");\n    }\n    const rawConditions = data[\"$and\"];\n    if (!Array.isArray(rawConditions) || rawConditions.length === 0) {\n      throw new TypeError(\"$and must be a non-empty array\");\n    }\n    const conditions = rawConditions.map((item, index) => {\n      const expr = WhereExpression.from(item);\n      if (!expr) {\n        throw new TypeError(`Invalid where clause at index ${index}`);\n      }\n      return expr;\n    });\n    if (conditions.length === 1) {\n      return conditions[0];\n    }\n    return conditions.slice(1).reduce((acc, condition) => AndWhere.combine(acc, condition), conditions[0]);\n  }\n  if (\"$or\" in data) {\n    if (Object.keys(data).length !== 1) {\n      throw new Error(\"$or cannot be combined with other keys\");\n    }\n    const rawConditions = data[\"$or\"];\n    if (!Array.isArray(rawConditions) || rawConditions.length === 0) {\n      throw new TypeError(\"$or must be a non-empty array\");\n    }\n    const conditions = rawConditions.map((item, index) => {\n      const expr = WhereExpression.from(item);\n      if (!expr) {\n        throw new TypeError(`Invalid where clause at index ${index}`);\n      }\n      return expr;\n    });\n    if (conditions.length === 1) {\n      return conditions[0];\n    }\n    return conditions.slice(1).reduce((acc, condition) => OrWhere.combine(acc, condition), conditions[0]);\n  }\n  const entries = Object.entries(data);\n  if (entries.length !== 1) {\n    throw new Error(\"Where dictionary must contain exactly one field\");\n  }\n  const [field, value] = entries[0];\n  if (!isPlainObject(value)) {\n    return new ComparisonWhere(field, \"$eq\", value);\n  }\n  const operatorEntries = Object.entries(value);\n  if (operatorEntries.length !== 1) {\n    throw new Error(`Operator dictionary for field \"${field}\" must contain exactly one operator`);\n  }\n  const [operator, operand] = operatorEntries[0];\n  const factory = comparisonOperatorMap.get(operator);\n  if (!factory) {\n    throw new Error(`Unsupported where operator: ${operator}`);\n  }\n  return factory(field, operand);\n};\nvar createComparisonWhere = (key, operator, value) => new ComparisonWhere(key, operator, value);\n\n// src/execution/expression/key.ts\nvar _Key = class _Key {\n  constructor(name) {\n    this.name = name;\n  }\n  eq(value) {\n    return createComparisonWhere(this.name, \"$eq\", value);\n  }\n  ne(value) {\n    return createComparisonWhere(this.name, \"$ne\", value);\n  }\n  gt(value) {\n    return createComparisonWhere(this.name, \"$gt\", value);\n  }\n  gte(value) {\n    return createComparisonWhere(this.name, \"$gte\", value);\n  }\n  lt(value) {\n    return createComparisonWhere(this.name, \"$lt\", value);\n  }\n  lte(value) {\n    return createComparisonWhere(this.name, \"$lte\", value);\n  }\n  isIn(values) {\n    const array = iterableToArray(values);\n    assertNonEmptyArray(array, \"$in requires at least one value\");\n    return createComparisonWhere(this.name, \"$in\", array);\n  }\n  notIn(values) {\n    const array = iterableToArray(values);\n    assertNonEmptyArray(array, \"$nin requires at least one value\");\n    return createComparisonWhere(this.name, \"$nin\", array);\n  }\n  contains(value) {\n    if (typeof value !== \"string\") {\n      throw new TypeError(\"$contains requires a string value\");\n    }\n    return createComparisonWhere(this.name, \"$contains\", value);\n  }\n  notContains(value) {\n    if (typeof value !== \"string\") {\n      throw new TypeError(\"$not_contains requires a string value\");\n    }\n    return createComparisonWhere(this.name, \"$not_contains\", value);\n  }\n  regex(pattern) {\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"$regex requires a string pattern\");\n    }\n    return createComparisonWhere(this.name, \"$regex\", pattern);\n  }\n  notRegex(pattern) {\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"$not_regex requires a string pattern\");\n    }\n    return createComparisonWhere(this.name, \"$not_regex\", pattern);\n  }\n};\n_Key.ID = new _Key(\"#id\");\n_Key.DOCUMENT = new _Key(\"#document\");\n_Key.EMBEDDING = new _Key(\"#embedding\");\n_Key.METADATA = new _Key(\"#metadata\");\n_Key.SCORE = new _Key(\"#score\");\nvar Key = _Key;\nvar createKeyFactory = () => {\n  const factory = (name) => new Key(name);\n  factory.ID = Key.ID;\n  factory.DOCUMENT = Key.DOCUMENT;\n  factory.EMBEDDING = Key.EMBEDDING;\n  factory.METADATA = Key.METADATA;\n  factory.SCORE = Key.SCORE;\n  return factory;\n};\nvar K = createKeyFactory();\n\n// src/execution/expression/limit.ts\nvar Limit = class _Limit {\n  constructor(options = {}) {\n    const { offset = 0, limit } = options;\n    if (!Number.isInteger(offset) || offset < 0) {\n      throw new TypeError(\"Limit offset must be a non-negative integer\");\n    }\n    if (limit !== null && limit !== void 0) {\n      if (!Number.isInteger(limit) || limit <= 0) {\n        throw new TypeError(\"Limit must be a positive integer when provided\");\n      }\n      this.limit = limit;\n    }\n    this.offset = offset;\n  }\n  static from(input, offsetOverride) {\n    if (input instanceof _Limit) {\n      return new _Limit({ offset: input.offset, limit: input.limit });\n    }\n    if (typeof input === \"number\") {\n      return new _Limit({ limit: input, offset: offsetOverride ?? 0 });\n    }\n    if (input === null || input === void 0) {\n      return new _Limit();\n    }\n    if (typeof input === \"object\") {\n      return new _Limit(input);\n    }\n    throw new TypeError(\"Invalid limit input\");\n  }\n  toJSON() {\n    const result = { offset: this.offset };\n    if (this.limit !== void 0) {\n      result.limit = this.limit;\n    }\n    return result;\n  }\n};\n\n// src/execution/expression/select.ts\nvar Select = class _Select {\n  constructor(keys = []) {\n    const unique = /* @__PURE__ */ new Set();\n    for (const key of keys) {\n      const normalized = key instanceof Key ? key.name : key;\n      if (typeof normalized !== \"string\") {\n        throw new TypeError(\"Select keys must be strings or Key instances\");\n      }\n      unique.add(normalized);\n    }\n    this.keys = Array.from(unique);\n  }\n  static from(input) {\n    if (input instanceof _Select) {\n      return new _Select(input.keys);\n    }\n    if (input === null || input === void 0) {\n      return new _Select();\n    }\n    if (Symbol.iterator in Object(input)) {\n      return new _Select(input);\n    }\n    if (typeof input === \"object\" && \"keys\" in input) {\n      const { keys } = input;\n      return new _Select(keys ?? []);\n    }\n    throw new TypeError(\"Unsupported select input\");\n  }\n  static all() {\n    return new _Select([Key.DOCUMENT, Key.EMBEDDING, Key.METADATA, Key.SCORE]);\n  }\n  get values() {\n    return this.keys.slice();\n  }\n  toJSON() {\n    return { keys: this.values };\n  }\n};\n\n// src/execution/expression/rank.ts\nvar requireNumber = (value, message) => {\n  if (typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)) {\n    throw new TypeError(message);\n  }\n  return value;\n};\nvar RankExpressionBase = class {\n  add(...others) {\n    if (others.length === 0) {\n      return this;\n    }\n    const expressions = [\n      this,\n      ...others.map((item, index) => requireRank(item, `add operand ${index}`))\n    ];\n    return SumRankExpression.create(expressions);\n  }\n  subtract(other) {\n    return new SubRankExpression(\n      this,\n      requireRank(other, \"subtract operand\")\n    );\n  }\n  multiply(...others) {\n    if (others.length === 0) {\n      return this;\n    }\n    const expressions = [\n      this,\n      ...others.map((item, index) => requireRank(item, `multiply operand ${index}`))\n    ];\n    return MulRankExpression.create(expressions);\n  }\n  divide(other) {\n    return new DivRankExpression(\n      this,\n      requireRank(other, \"divide operand\")\n    );\n  }\n  negate() {\n    return this.multiply(-1);\n  }\n  abs() {\n    return new AbsRankExpression(this);\n  }\n  exp() {\n    return new ExpRankExpression(this);\n  }\n  log() {\n    return new LogRankExpression(this);\n  }\n  max(...others) {\n    if (others.length === 0) {\n      return this;\n    }\n    const expressions = [\n      this,\n      ...others.map((item, index) => requireRank(item, `max operand ${index}`))\n    ];\n    return MaxRankExpression.create(expressions);\n  }\n  min(...others) {\n    if (others.length === 0) {\n      return this;\n    }\n    const expressions = [\n      this,\n      ...others.map((item, index) => requireRank(item, `min operand ${index}`))\n    ];\n    return MinRankExpression.create(expressions);\n  }\n};\nvar RankExpression = class _RankExpression extends RankExpressionBase {\n  static from(input) {\n    if (input instanceof _RankExpression) {\n      return input;\n    }\n    if (input === null || input === void 0) {\n      return void 0;\n    }\n    if (typeof input === \"number\") {\n      return new ValueRankExpression(input);\n    }\n    if (isPlainObject(input)) {\n      return new RawRankExpression(input);\n    }\n    throw new TypeError(\"Rank input must be a RankExpression, number, or plain object\");\n  }\n};\nvar RawRankExpression = class extends RankExpression {\n  constructor(raw) {\n    super();\n    this.raw = raw;\n  }\n  toJSON() {\n    return deepClone(this.raw);\n  }\n};\nvar ValueRankExpression = class extends RankExpression {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toJSON() {\n    return { $val: this.value };\n  }\n};\nvar SumRankExpression = class _SumRankExpression extends RankExpression {\n  constructor(ranks) {\n    super();\n    this.ranks = ranks;\n  }\n  static create(ranks) {\n    const flattened = [];\n    for (const rank of ranks) {\n      if (rank instanceof _SumRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new _SumRankExpression(flattened);\n  }\n  get operands() {\n    return this.ranks.slice();\n  }\n  toJSON() {\n    return { $sum: this.ranks.map((rank) => rank.toJSON()) };\n  }\n};\nvar SubRankExpression = class extends RankExpression {\n  constructor(left, right) {\n    super();\n    this.left = left;\n    this.right = right;\n  }\n  toJSON() {\n    return {\n      $sub: {\n        left: this.left.toJSON(),\n        right: this.right.toJSON()\n      }\n    };\n  }\n};\nvar MulRankExpression = class _MulRankExpression extends RankExpression {\n  constructor(ranks) {\n    super();\n    this.ranks = ranks;\n  }\n  static create(ranks) {\n    const flattened = [];\n    for (const rank of ranks) {\n      if (rank instanceof _MulRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new _MulRankExpression(flattened);\n  }\n  get operands() {\n    return this.ranks.slice();\n  }\n  toJSON() {\n    return { $mul: this.ranks.map((rank) => rank.toJSON()) };\n  }\n};\nvar DivRankExpression = class extends RankExpression {\n  constructor(left, right) {\n    super();\n    this.left = left;\n    this.right = right;\n  }\n  toJSON() {\n    return {\n      $div: {\n        left: this.left.toJSON(),\n        right: this.right.toJSON()\n      }\n    };\n  }\n};\nvar AbsRankExpression = class extends RankExpression {\n  constructor(operand) {\n    super();\n    this.operand = operand;\n  }\n  toJSON() {\n    return { $abs: this.operand.toJSON() };\n  }\n};\nvar ExpRankExpression = class extends RankExpression {\n  constructor(operand) {\n    super();\n    this.operand = operand;\n  }\n  toJSON() {\n    return { $exp: this.operand.toJSON() };\n  }\n};\nvar LogRankExpression = class extends RankExpression {\n  constructor(operand) {\n    super();\n    this.operand = operand;\n  }\n  toJSON() {\n    return { $log: this.operand.toJSON() };\n  }\n};\nvar MaxRankExpression = class _MaxRankExpression extends RankExpression {\n  constructor(ranks) {\n    super();\n    this.ranks = ranks;\n  }\n  static create(ranks) {\n    const flattened = [];\n    for (const rank of ranks) {\n      if (rank instanceof _MaxRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new _MaxRankExpression(flattened);\n  }\n  get operands() {\n    return this.ranks.slice();\n  }\n  toJSON() {\n    return { $max: this.ranks.map((rank) => rank.toJSON()) };\n  }\n};\nvar MinRankExpression = class _MinRankExpression extends RankExpression {\n  constructor(ranks) {\n    super();\n    this.ranks = ranks;\n  }\n  static create(ranks) {\n    const flattened = [];\n    for (const rank of ranks) {\n      if (rank instanceof _MinRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new _MinRankExpression(flattened);\n  }\n  get operands() {\n    return this.ranks.slice();\n  }\n  toJSON() {\n    return { $min: this.ranks.map((rank) => rank.toJSON()) };\n  }\n};\nvar KnnRankExpression = class extends RankExpression {\n  constructor(config) {\n    super();\n    this.config = config;\n  }\n  toJSON() {\n    const base = {\n      query: this.config.query,\n      key: this.config.key,\n      limit: this.config.limit\n    };\n    if (this.config.defaultValue !== void 0) {\n      base.default = this.config.defaultValue;\n    }\n    if (this.config.returnRank) {\n      base.return_rank = true;\n    }\n    return { $knn: base };\n  }\n};\nvar normalizeDenseVector = (vector) => {\n  if (Array.isArray(vector)) {\n    return vector.slice();\n  }\n  return Array.from(vector, (value) => {\n    if (typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)) {\n      throw new TypeError(\"Dense query vector values must be finite numbers\");\n    }\n    return value;\n  });\n};\nvar normalizeKnnOptions = (options) => {\n  const limit = options.limit ?? 128;\n  if (!Number.isInteger(limit) || limit <= 0) {\n    throw new TypeError(\"Knn limit must be a positive integer\");\n  }\n  const queryInput = options.query;\n  let query;\n  if (typeof queryInput === \"string\") {\n    query = queryInput;\n  } else if (isPlainObject(queryInput) && Array.isArray(queryInput.indices) && Array.isArray(queryInput.values)) {\n    const sparse = queryInput;\n    query = {\n      indices: sparse.indices.slice(),\n      values: sparse.values.slice()\n    };\n  } else {\n    query = normalizeDenseVector(queryInput);\n  }\n  const key = options.key instanceof Key ? options.key.name : options.key ?? \"#embedding\";\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"Knn key must be a string or Key instance\");\n  }\n  const defaultValue = options.default === null || options.default === void 0 ? void 0 : requireNumber(options.default, \"Knn default must be a number\");\n  if (defaultValue !== void 0 && !Number.isFinite(defaultValue)) {\n    throw new TypeError(\"Knn default must be a finite number\");\n  }\n  return {\n    query: Array.isArray(query) || typeof query === \"string\" ? query : deepClone(query),\n    key,\n    limit,\n    defaultValue,\n    returnRank: options.returnRank ?? false\n  };\n};\nvar requireRank = (input, context) => {\n  const result = RankExpression.from(input);\n  if (!result) {\n    throw new TypeError(`${context} must be a rank expression`);\n  }\n  return result;\n};\nvar Val = (value) => new ValueRankExpression(requireNumber(value, \"Val requires a numeric value\"));\nvar Knn = (options) => new KnnRankExpression(normalizeKnnOptions(options));\nvar Rrf = ({ ranks, k = 60, weights, normalize = false }) => {\n  if (!Number.isInteger(k) || k <= 0) {\n    throw new TypeError(\"Rrf k must be a positive integer\");\n  }\n  if (!Array.isArray(ranks) || ranks.length === 0) {\n    throw new TypeError(\"Rrf requires at least one rank expression\");\n  }\n  const expressions = ranks.map((rank, index) => requireRank(rank, `ranks[${index}]`));\n  let weightValues = weights ? weights.slice() : new Array(expressions.length).fill(1);\n  if (weightValues.length !== expressions.length) {\n    throw new Error(\"Number of weights must match number of ranks\");\n  }\n  if (weightValues.some((value) => typeof value !== \"number\" || value < 0)) {\n    throw new TypeError(\"Weights must be non-negative numbers\");\n  }\n  if (normalize) {\n    const total = weightValues.reduce((sum, value) => sum + value, 0);\n    if (total <= 0) {\n      throw new Error(\"Weights must sum to a positive value when normalize=true\");\n    }\n    weightValues = weightValues.map((value) => value / total);\n  }\n  const terms = expressions.map((rank, index) => {\n    const weight = weightValues[index];\n    const numerator = Val(weight);\n    const denominator = rank.add(k);\n    return numerator.divide(denominator);\n  });\n  const fused = terms.reduce((acc, term) => acc.add(term));\n  return fused.negate();\n};\nvar Sum = (...inputs) => {\n  if (inputs.length === 0) {\n    throw new Error(\"Sum requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) => requireRank(rank, `Sum operand ${index}`));\n  return SumRankExpression.create(expressions);\n};\nvar Sub = (left, right) => new SubRankExpression(requireRank(left, \"Sub left\"), requireRank(right, \"Sub right\"));\nvar Mul = (...inputs) => {\n  if (inputs.length === 0) {\n    throw new Error(\"Mul requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) => requireRank(rank, `Mul operand ${index}`));\n  return MulRankExpression.create(expressions);\n};\nvar Div = (left, right) => new DivRankExpression(requireRank(left, \"Div left\"), requireRank(right, \"Div right\"));\nvar Abs = (input) => requireRank(input, \"Abs\").abs();\nvar Exp = (input) => requireRank(input, \"Exp\").exp();\nvar Log = (input) => requireRank(input, \"Log\").log();\nvar Max = (...inputs) => {\n  if (inputs.length === 0) {\n    throw new Error(\"Max requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) => requireRank(rank, `Max operand ${index}`));\n  return MaxRankExpression.create(expressions);\n};\nvar Min = (...inputs) => {\n  if (inputs.length === 0) {\n    throw new Error(\"Min requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) => requireRank(rank, `Min operand ${index}`));\n  return MinRankExpression.create(expressions);\n};\n\n// src/execution/expression/groupBy.ts\nvar Aggregate = class _Aggregate {\n  static from(input) {\n    if (input instanceof _Aggregate) {\n      return input;\n    }\n    if (isPlainObject(input)) {\n      if (\"$min_k\" in input) {\n        const data = input.$min_k;\n        return new MinK(\n          data.keys.map((k) => new Key(k)),\n          data.k\n        );\n      }\n      if (\"$max_k\" in input) {\n        const data = input.$max_k;\n        return new MaxK(\n          data.keys.map((k) => new Key(k)),\n          data.k\n        );\n      }\n    }\n    throw new TypeError(\n      \"Aggregate input must be an Aggregate instance or object with $min_k or $max_k\"\n    );\n  }\n  static minK(keys, k) {\n    return new MinK(\n      keys.map((key) => key instanceof Key ? key : new Key(key)),\n      k\n    );\n  }\n  static maxK(keys, k) {\n    return new MaxK(\n      keys.map((key) => key instanceof Key ? key : new Key(key)),\n      k\n    );\n  }\n};\nvar MinK = class extends Aggregate {\n  constructor(keys, k) {\n    super();\n    this.keys = keys;\n    this.k = k;\n    if (keys.length === 0) {\n      throw new Error(\"MinK keys cannot be empty\");\n    }\n    if (k <= 0) {\n      throw new Error(\"MinK k must be positive\");\n    }\n  }\n  toJSON() {\n    return {\n      $min_k: {\n        keys: this.keys.map((key) => key.name),\n        k: this.k\n      }\n    };\n  }\n};\nvar MaxK = class extends Aggregate {\n  constructor(keys, k) {\n    super();\n    this.keys = keys;\n    this.k = k;\n    if (keys.length === 0) {\n      throw new Error(\"MaxK keys cannot be empty\");\n    }\n    if (k <= 0) {\n      throw new Error(\"MaxK k must be positive\");\n    }\n  }\n  toJSON() {\n    return {\n      $max_k: {\n        keys: this.keys.map((key) => key.name),\n        k: this.k\n      }\n    };\n  }\n};\nvar GroupBy = class _GroupBy {\n  constructor(keys, aggregate) {\n    this.keys = keys;\n    this.aggregate = aggregate;\n    if (keys.length === 0) {\n      throw new Error(\"GroupBy keys cannot be empty\");\n    }\n  }\n  static from(input) {\n    if (input === void 0 || input === null) {\n      return void 0;\n    }\n    if (input instanceof _GroupBy) {\n      return input;\n    }\n    if (isPlainObject(input)) {\n      const data = input;\n      if (!data.keys || !Array.isArray(data.keys)) {\n        throw new TypeError(\"GroupBy requires 'keys' array\");\n      }\n      if (!data.aggregate) {\n        throw new TypeError(\"GroupBy requires 'aggregate'\");\n      }\n      return new _GroupBy(\n        data.keys.map((k) => new Key(k)),\n        Aggregate.from(data.aggregate)\n      );\n    }\n    throw new TypeError(\"GroupBy input must be a GroupBy instance or plain object\");\n  }\n  toJSON() {\n    return {\n      keys: this.keys.map((key) => key.name),\n      aggregate: this.aggregate.toJSON()\n    };\n  }\n};\n\n// src/execution/expression/search.ts\nvar Search = class _Search {\n  constructor(init = {}) {\n    this._where = init.where ? WhereExpression.from(init.where) : void 0;\n    this._rank = init.rank ? RankExpression.from(init.rank) : void 0;\n    this._groupBy = init.groupBy ? GroupBy.from(init.groupBy) : void 0;\n    this._limit = Limit.from(init.limit ?? void 0);\n    this._select = Select.from(init.select ?? void 0);\n  }\n  clone(overrides) {\n    const next = Object.create(_Search.prototype);\n    next._where = overrides.where ?? this._where;\n    next._rank = overrides.rank ?? this._rank;\n    next._groupBy = overrides.groupBy ?? this._groupBy;\n    next._limit = overrides.limit ?? this._limit;\n    next._select = overrides.select ?? this._select;\n    return next;\n  }\n  where(where) {\n    return this.clone({ where: WhereExpression.from(where) });\n  }\n  rank(rank) {\n    return this.clone({ rank: RankExpression.from(rank ?? void 0) });\n  }\n  groupBy(groupBy) {\n    return this.clone({ groupBy: GroupBy.from(groupBy) });\n  }\n  limit(limit, offset) {\n    if (typeof limit === \"number\") {\n      return this.clone({ limit: Limit.from(limit, offset) });\n    }\n    return this.clone({ limit: Limit.from(limit ?? void 0) });\n  }\n  select(first, ...rest) {\n    if (Array.isArray(first) || first instanceof Set) {\n      return this.clone({\n        select: Select.from(first)\n      });\n    }\n    if (first instanceof Select) {\n      return this.clone({ select: Select.from(first) });\n    }\n    if (typeof first === \"object\" && first !== null && \"keys\" in first) {\n      return this.clone({ select: Select.from(first) });\n    }\n    const allKeys = [];\n    if (first !== void 0) {\n      allKeys.push(first);\n    }\n    if (rest.length) {\n      allKeys.push(...rest);\n    }\n    return this.clone({ select: Select.from(allKeys) });\n  }\n  selectAll() {\n    return this.clone({ select: Select.all() });\n  }\n  get whereClause() {\n    return this._where;\n  }\n  get rankExpression() {\n    return this._rank;\n  }\n  get groupByConfig() {\n    return this._groupBy;\n  }\n  get limitConfig() {\n    return this._limit;\n  }\n  get selectConfig() {\n    return this._select;\n  }\n  toPayload() {\n    const payload = {\n      limit: this._limit.toJSON(),\n      select: this._select.toJSON()\n    };\n    if (this._where) {\n      payload.filter = this._where.toJSON();\n    }\n    if (this._rank) {\n      payload.rank = this._rank.toJSON();\n    }\n    if (this._groupBy) {\n      payload.group_by = this._groupBy.toJSON();\n    }\n    return payload;\n  }\n};\nvar toSearch = (input) => input instanceof Search ? input : new Search(input);\n\n// src/execution/expression/searchResult.ts\nvar normalizePayloadArray = (payload, count) => {\n  if (!payload) {\n    return Array(count).fill(null);\n  }\n  if (payload.length === count) {\n    return payload.map((item) => item ? item.slice() : null);\n  }\n  const result = payload.map((item) => item ? item.slice() : null);\n  while (result.length < count) {\n    result.push(null);\n  }\n  return result;\n};\nvar SearchResult = class {\n  constructor(response) {\n    this.ids = response.ids;\n    const payloadCount = this.ids.length;\n    this.documents = normalizePayloadArray(response.documents, payloadCount);\n    this.embeddings = normalizePayloadArray(response.embeddings, payloadCount);\n    const rawMetadatas = normalizePayloadArray(response.metadatas, payloadCount);\n    this.metadatas = rawMetadatas.map((payload) => {\n      if (!payload) {\n        return null;\n      }\n      return deserializeMetadatas(payload) ?? [];\n    });\n    this.scores = normalizePayloadArray(response.scores, payloadCount);\n    this.select = response.select ?? [];\n  }\n  rows() {\n    const results = [];\n    for (let payloadIndex = 0; payloadIndex < this.ids.length; payloadIndex += 1) {\n      const ids = this.ids[payloadIndex];\n      const docPayload = this.documents[payloadIndex] ?? [];\n      const embedPayload = this.embeddings[payloadIndex] ?? [];\n      const metaPayload = this.metadatas[payloadIndex] ?? [];\n      const scorePayload = this.scores[payloadIndex] ?? [];\n      const rows = ids.map((id, rowIndex) => {\n        const row = { id };\n        const document = docPayload[rowIndex];\n        if (document !== void 0 && document !== null) {\n          row.document = document;\n        }\n        const embedding = embedPayload[rowIndex];\n        if (embedding !== void 0 && embedding !== null) {\n          row.embedding = embedding;\n        }\n        const metadata = metaPayload[rowIndex];\n        if (metadata !== void 0 && metadata !== null) {\n          row.metadata = metadata;\n        }\n        const score = scorePayload[rowIndex];\n        if (score !== void 0 && score !== null) {\n          row.score = score;\n        }\n        return row;\n      });\n      results.push(rows);\n    }\n    return results;\n  }\n};\n\n// src/schema.ts\nvar DOCUMENT_KEY = \"#document\";\nvar EMBEDDING_KEY = \"#embedding\";\nvar CmekProvider = /* @__PURE__ */ ((CmekProvider2) => {\n  CmekProvider2[\"GCP\"] = \"gcp\";\n  return CmekProvider2;\n})(CmekProvider || {});\nvar _Cmek = class _Cmek {\n  constructor(provider, resource) {\n    this.provider = provider;\n    this.resource = resource;\n  }\n  /**\n   * Create a CMEK instance for Google Cloud Platform.\n   *\n   * @param resource - GCP Cloud KMS resource name in the format:\n   *   projects/{project-id}/locations/{location}/keyRings/{key-ring}/cryptoKeys/{key-name}\n   *\n   * @returns A new CMEK instance configured for GCP\n   *\n   * @example\n   * ```typescript\n   * const cmek = Cmek.gcp(\n   *   \"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key\"\n   * );\n   * ```\n   */\n  static gcp(resource) {\n    return new _Cmek(\"gcp\" /* GCP */, resource);\n  }\n  /**\n   * Validate the CMEK resource name format.\n   *\n   * Validates that the resource name matches the expected pattern for the\n   * provider. This is a format check only and does not verify that the key\n   * exists or that you have access to it.\n   *\n   * For GCP, the expected format is:\n   *   projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}\n   *\n   * @returns true if the resource name format is valid, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const cmek = Cmek.gcp(\"projects/p/locations/l/keyRings/r/cryptoKeys/k\");\n   * cmek.validatePattern(); // Returns true\n   *\n   * const badCmek = Cmek.gcp(\"invalid-format\");\n   * badCmek.validatePattern(); // Returns false\n   * ```\n   */\n  validatePattern() {\n    if (this.provider === \"gcp\" /* GCP */) {\n      return _Cmek.GCP_PATTERN.test(this.resource);\n    }\n    return false;\n  }\n  /**\n   * Serialize CMEK to object format for API transport.\n   *\n   * Returns an object with the provider variant as the key and resource as the value.\n   *\n   * @returns Object containing the provider variant and resource identifier\n   *\n   * @example\n   * ```typescript\n   * const cmek = Cmek.gcp(\"projects/p/locations/l/keyRings/r/cryptoKeys/k\");\n   * cmek.toJSON();\n   * // Returns: { gcp: 'projects/p/locations/l/keyRings/r/cryptoKeys/k' }\n   * ```\n   */\n  toJSON() {\n    if (this.provider === \"gcp\" /* GCP */) {\n      return { gcp: this.resource };\n    }\n    throw new Error(`Unknown CMEK provider: ${this.provider}`);\n  }\n  /**\n   * Deserialize CMEK from object format.\n   *\n   * Expects the provider variant as the key and resource as the value.\n   *\n   * @param data - Object containing provider variant and resource\n   * @returns Deserialized CMEK instance\n   * @throws Error if the provider is unsupported or data is malformed\n   *\n   * @example\n   * ```typescript\n   * const data = { gcp: 'projects/p/locations/l/keyRings/r/cryptoKeys/k' };\n   * const cmek = Cmek.fromJSON(data);\n   * ```\n   */\n  static fromJSON(data) {\n    if (\"gcp\" in data && typeof data.gcp === \"string\") {\n      return _Cmek.gcp(data.gcp);\n    }\n    throw new Error(\n      `Unsupported or missing CMEK provider in data: ${JSON.stringify(data)}`\n    );\n  }\n};\n_Cmek.GCP_PATTERN = /^projects\\/.+\\/locations\\/.+\\/keyRings\\/.+\\/cryptoKeys\\/.+$/;\nvar Cmek = _Cmek;\nvar STRING_VALUE_NAME = \"string\";\nvar FLOAT_LIST_VALUE_NAME = \"float_list\";\nvar SPARSE_VECTOR_VALUE_NAME = \"sparse_vector\";\nvar INT_VALUE_NAME = \"int\";\nvar FLOAT_VALUE_NAME = \"float\";\nvar BOOL_VALUE_NAME = \"bool\";\nvar FTS_INDEX_NAME = \"fts_index\";\nvar STRING_INVERTED_INDEX_NAME = \"string_inverted_index\";\nvar VECTOR_INDEX_NAME = \"vector_index\";\nvar SPARSE_VECTOR_INDEX_NAME = \"sparse_vector_index\";\nvar INT_INVERTED_INDEX_NAME = \"int_inverted_index\";\nvar FLOAT_INVERTED_INDEX_NAME = \"float_inverted_index\";\nvar BOOL_INVERTED_INDEX_NAME = \"bool_inverted_index\";\nvar FtsIndexConfig = class {\n  constructor() {\n    this.type = \"FtsIndexConfig\";\n  }\n};\nvar StringInvertedIndexConfig = class {\n  constructor() {\n    this.type = \"StringInvertedIndexConfig\";\n  }\n};\nvar IntInvertedIndexConfig = class {\n  constructor() {\n    this.type = \"IntInvertedIndexConfig\";\n  }\n};\nvar FloatInvertedIndexConfig = class {\n  constructor() {\n    this.type = \"FloatInvertedIndexConfig\";\n  }\n};\nvar BoolInvertedIndexConfig = class {\n  constructor() {\n    this.type = \"BoolInvertedIndexConfig\";\n  }\n};\nvar VectorIndexConfig = class {\n  constructor(options = {}) {\n    this.type = \"VectorIndexConfig\";\n    this.space = options.space ?? null;\n    this.embeddingFunction = options.embeddingFunction;\n    this.sourceKey = options.sourceKey instanceof Key ? options.sourceKey.name : options.sourceKey ?? null;\n    this.hnsw = options.hnsw ?? null;\n    this.spann = options.spann ?? null;\n  }\n};\nvar SparseVectorIndexConfig = class {\n  constructor(options = {}) {\n    this.type = \"SparseVectorIndexConfig\";\n    this.embeddingFunction = options.embeddingFunction;\n    this.sourceKey = options.sourceKey instanceof Key ? options.sourceKey.name : options.sourceKey ?? null;\n    this.bm25 = options.bm25 ?? null;\n  }\n};\nvar FtsIndexType = class {\n  constructor(enabled, config) {\n    this.enabled = enabled;\n    this.config = config;\n  }\n};\nvar StringInvertedIndexType = class {\n  constructor(enabled, config) {\n    this.enabled = enabled;\n    this.config = config;\n  }\n};\nvar VectorIndexType = class {\n  constructor(enabled, config) {\n    this.enabled = enabled;\n    this.config = config;\n  }\n};\nvar SparseVectorIndexType = class {\n  constructor(enabled, config) {\n    this.enabled = enabled;\n    this.config = config;\n  }\n};\nvar IntInvertedIndexType = class {\n  constructor(enabled, config) {\n    this.enabled = enabled;\n    this.config = config;\n  }\n};\nvar FloatInvertedIndexType = class {\n  constructor(enabled, config) {\n    this.enabled = enabled;\n    this.config = config;\n  }\n};\nvar BoolInvertedIndexType = class {\n  constructor(enabled, config) {\n    this.enabled = enabled;\n    this.config = config;\n  }\n};\nvar StringValueType = class {\n  constructor(ftsIndex = null, stringInvertedIndex = null) {\n    this.ftsIndex = ftsIndex;\n    this.stringInvertedIndex = stringInvertedIndex;\n  }\n};\nvar FloatListValueType = class {\n  constructor(vectorIndex = null) {\n    this.vectorIndex = vectorIndex;\n  }\n};\nvar SparseVectorValueType = class {\n  constructor(sparseVectorIndex = null) {\n    this.sparseVectorIndex = sparseVectorIndex;\n  }\n};\nvar IntValueType = class {\n  constructor(intInvertedIndex = null) {\n    this.intInvertedIndex = intInvertedIndex;\n  }\n};\nvar FloatValueType = class {\n  constructor(floatInvertedIndex = null) {\n    this.floatInvertedIndex = floatInvertedIndex;\n  }\n};\nvar BoolValueType = class {\n  constructor(boolInvertedIndex = null) {\n    this.boolInvertedIndex = boolInvertedIndex;\n  }\n};\nvar ValueTypes = class {\n  constructor() {\n    this.string = null;\n    this.floatList = null;\n    this.sparseVector = null;\n    this.intValue = null;\n    this.floatValue = null;\n    this.boolean = null;\n  }\n};\nvar cloneObject = (value) => {\n  if (value === null || value === void 0) {\n    return value;\n  }\n  if (typeof value !== \"object\") {\n    return value;\n  }\n  return Array.isArray(value) ? value.map((item) => cloneObject(item)) : Object.fromEntries(\n    Object.entries(value).map(([k, v]) => [\n      k,\n      cloneObject(v)\n    ])\n  );\n};\nvar resolveEmbeddingFunctionName = (fn) => {\n  if (!fn) return void 0;\n  if (typeof fn.name === \"function\") {\n    try {\n      const value = fn.name();\n      return typeof value === \"string\" ? value : void 0;\n    } catch (_err) {\n      return void 0;\n    }\n  }\n  if (typeof fn.name === \"string\") {\n    return fn.name;\n  }\n  return void 0;\n};\nvar prepareEmbeddingFunctionConfig = (fn) => {\n  if (!fn) {\n    return { type: \"legacy\" };\n  }\n  const name = resolveEmbeddingFunctionName(fn);\n  const getConfig = typeof fn.getConfig === \"function\" ? fn.getConfig.bind(fn) : void 0;\n  const buildFromConfig = fn.constructor?.buildFromConfig;\n  if (!name || !getConfig || typeof buildFromConfig !== \"function\") {\n    return { type: \"legacy\" };\n  }\n  const config = getConfig();\n  if (typeof fn.validateConfig === \"function\") {\n    fn.validateConfig(config);\n  }\n  return {\n    type: \"known\",\n    name,\n    config\n  };\n};\nvar ensureValueTypes = (valueTypes) => valueTypes ?? new ValueTypes();\nvar ensureStringValueType = (valueTypes) => {\n  if (!valueTypes.string) {\n    valueTypes.string = new StringValueType();\n  }\n  return valueTypes.string;\n};\nvar ensureFloatListValueType = (valueTypes) => {\n  if (!valueTypes.floatList) {\n    valueTypes.floatList = new FloatListValueType();\n  }\n  return valueTypes.floatList;\n};\nvar ensureSparseVectorValueType = (valueTypes) => {\n  if (!valueTypes.sparseVector) {\n    valueTypes.sparseVector = new SparseVectorValueType();\n  }\n  return valueTypes.sparseVector;\n};\nvar ensureIntValueType = (valueTypes) => {\n  if (!valueTypes.intValue) {\n    valueTypes.intValue = new IntValueType();\n  }\n  return valueTypes.intValue;\n};\nvar ensureFloatValueType = (valueTypes) => {\n  if (!valueTypes.floatValue) {\n    valueTypes.floatValue = new FloatValueType();\n  }\n  return valueTypes.floatValue;\n};\nvar ensureBoolValueType = (valueTypes) => {\n  if (!valueTypes.boolean) {\n    valueTypes.boolean = new BoolValueType();\n  }\n  return valueTypes.boolean;\n};\nvar Schema = class _Schema {\n  constructor() {\n    this.defaults = new ValueTypes();\n    this.keys = {};\n    this.cmek = null;\n    this.initializeDefaults();\n    this.initializeKeys();\n  }\n  /**\n   * Set the customer-managed encryption key for this collection.\n   *\n   * CMEK allows you to use your own encryption keys managed by cloud providers'\n   * key management services instead of default provider-managed keys.\n   *\n   * @param cmek - CMEK instance or null to remove encryption\n   * @returns this for method chaining\n   *\n   * @example\n   * ```typescript\n   * const schema = new Schema();\n   * schema.setCmek(Cmek.gcp(\n   *   \"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key\"\n   * ));\n   * ```\n   */\n  setCmek(cmek) {\n    this.cmek = cmek;\n    return this;\n  }\n  createIndex(config, key) {\n    const configProvided = config !== void 0 && config !== null;\n    const keyProvided = key !== void 0 && key !== null;\n    if (!configProvided && !keyProvided) {\n      throw new Error(\n        \"Cannot enable all index types globally. Must specify either config or key.\"\n      );\n    }\n    if (keyProvided && key && (key === EMBEDDING_KEY || key === DOCUMENT_KEY)) {\n      throw new Error(\n        `Cannot create index on special key '${key}'. These keys are managed automatically by the system.`\n      );\n    }\n    if (config instanceof VectorIndexConfig) {\n      if (!keyProvided) {\n        this.setVectorIndexConfig(config);\n        return this;\n      }\n      throw new Error(\n        \"Vector index cannot be enabled on specific keys. Use createIndex(config=VectorIndexConfig(...)) without specifying a key to configure the vector index globally.\"\n      );\n    }\n    if (config instanceof FtsIndexConfig) {\n      if (!keyProvided) {\n        this.setFtsIndexConfig(config);\n        return this;\n      }\n      throw new Error(\n        \"FTS index cannot be enabled on specific keys. Use createIndex(config=FtsIndexConfig(...)) without specifying a key to configure the FTS index globally.\"\n      );\n    }\n    if (config instanceof SparseVectorIndexConfig && !keyProvided) {\n      throw new Error(\n        \"Sparse vector index must be created on a specific key. Please specify a key using: createIndex(config=SparseVectorIndexConfig(...), key='your_key')\"\n      );\n    }\n    if (!configProvided && keyProvided && key) {\n      throw new Error(\n        `Cannot enable all index types for key '${key}'. Please specify a specific index configuration.`\n      );\n    }\n    if (configProvided && !keyProvided) {\n      this.setIndexInDefaults(config, true);\n    } else if (configProvided && keyProvided && key) {\n      this.setIndexForKey(key, config, true);\n    }\n    return this;\n  }\n  deleteIndex(config, key) {\n    const configProvided = config !== void 0 && config !== null;\n    const keyProvided = key !== void 0 && key !== null;\n    if (!configProvided && !keyProvided) {\n      throw new Error(\n        \"Cannot disable all indexes. Must specify either config or key.\"\n      );\n    }\n    if (keyProvided && key && (key === EMBEDDING_KEY || key === DOCUMENT_KEY)) {\n      throw new Error(\n        `Cannot delete index on special key '${key}'. These keys are managed automatically by the system.`\n      );\n    }\n    if (config instanceof VectorIndexConfig) {\n      throw new Error(\"Deleting vector index is not currently supported.\");\n    }\n    if (config instanceof FtsIndexConfig) {\n      throw new Error(\"Deleting FTS index is not currently supported.\");\n    }\n    if (config instanceof SparseVectorIndexConfig) {\n      throw new Error(\n        \"Deleting sparse vector index is not currently supported.\"\n      );\n    }\n    if (keyProvided && !configProvided && key) {\n      throw new Error(\n        `Cannot disable all index types for key '${key}'. Please specify a specific index configuration.`\n      );\n    }\n    if (keyProvided && configProvided && key) {\n      this.setIndexForKey(key, config, false);\n    } else if (!keyProvided && configProvided) {\n      this.setIndexInDefaults(config, false);\n    }\n    return this;\n  }\n  serializeToJSON() {\n    const defaults = this.serializeValueTypes(this.defaults);\n    const keys = {};\n    for (const [keyName, valueTypes] of Object.entries(this.keys)) {\n      keys[keyName] = this.serializeValueTypes(valueTypes);\n    }\n    const result = {\n      defaults,\n      keys\n    };\n    if (this.cmek !== null) {\n      result.cmek = this.cmek.toJSON();\n    }\n    return result;\n  }\n  static async deserializeFromJSON(json, client2) {\n    if (json == null) {\n      return void 0;\n    }\n    const data = json;\n    const instance = Object.create(_Schema.prototype);\n    instance.defaults = await _Schema.deserializeValueTypes(\n      data.defaults ?? {},\n      client2\n    );\n    instance.keys = {};\n    const keys = data.keys ?? {};\n    for (const [keyName, value] of Object.entries(keys)) {\n      instance.keys[keyName] = await _Schema.deserializeValueTypes(\n        value,\n        client2\n      );\n    }\n    instance.cmek = null;\n    if (data.cmek && typeof data.cmek === \"object\") {\n      instance.cmek = Cmek.fromJSON(data.cmek);\n    }\n    return instance;\n  }\n  setVectorIndexConfig(config) {\n    const defaultsFloatList = ensureFloatListValueType(this.defaults);\n    const currentDefaultsVector = defaultsFloatList.vectorIndex ?? new VectorIndexType(false, new VectorIndexConfig());\n    defaultsFloatList.vectorIndex = new VectorIndexType(\n      currentDefaultsVector.enabled,\n      new VectorIndexConfig({\n        space: config.space ?? null,\n        embeddingFunction: config.embeddingFunction,\n        sourceKey: config.sourceKey ?? null,\n        hnsw: config.hnsw ? cloneObject(config.hnsw) : null,\n        spann: config.spann ? cloneObject(config.spann) : null\n      })\n    );\n    const embeddingValueTypes = ensureValueTypes(this.keys[EMBEDDING_KEY]);\n    this.keys[EMBEDDING_KEY] = embeddingValueTypes;\n    const overrideFloatList = ensureFloatListValueType(embeddingValueTypes);\n    const currentOverrideVector = overrideFloatList.vectorIndex ?? new VectorIndexType(\n      true,\n      new VectorIndexConfig({ sourceKey: DOCUMENT_KEY })\n    );\n    const preservedSourceKey = currentOverrideVector.config.sourceKey ?? DOCUMENT_KEY;\n    overrideFloatList.vectorIndex = new VectorIndexType(\n      currentOverrideVector.enabled,\n      new VectorIndexConfig({\n        space: config.space ?? null,\n        embeddingFunction: config.embeddingFunction,\n        sourceKey: preservedSourceKey,\n        hnsw: config.hnsw ? cloneObject(config.hnsw) : null,\n        spann: config.spann ? cloneObject(config.spann) : null\n      })\n    );\n  }\n  setFtsIndexConfig(config) {\n    const defaultsString = ensureStringValueType(this.defaults);\n    const currentDefaultsFts = defaultsString.ftsIndex ?? new FtsIndexType(false, new FtsIndexConfig());\n    defaultsString.ftsIndex = new FtsIndexType(\n      currentDefaultsFts.enabled,\n      config\n    );\n    const documentValueTypes = ensureValueTypes(this.keys[DOCUMENT_KEY]);\n    this.keys[DOCUMENT_KEY] = documentValueTypes;\n    const overrideString = ensureStringValueType(documentValueTypes);\n    const currentOverrideFts = overrideString.ftsIndex ?? new FtsIndexType(true, new FtsIndexConfig());\n    overrideString.ftsIndex = new FtsIndexType(\n      currentOverrideFts.enabled,\n      config\n    );\n  }\n  setIndexInDefaults(config, enabled) {\n    if (config instanceof FtsIndexConfig) {\n      const valueType = ensureStringValueType(this.defaults);\n      valueType.ftsIndex = new FtsIndexType(enabled, config);\n    } else if (config instanceof StringInvertedIndexConfig) {\n      const valueType = ensureStringValueType(this.defaults);\n      valueType.stringInvertedIndex = new StringInvertedIndexType(\n        enabled,\n        config\n      );\n    } else if (config instanceof VectorIndexConfig) {\n      const valueType = ensureFloatListValueType(this.defaults);\n      valueType.vectorIndex = new VectorIndexType(enabled, config);\n    } else if (config instanceof SparseVectorIndexConfig) {\n      const valueType = ensureSparseVectorValueType(this.defaults);\n      valueType.sparseVectorIndex = new SparseVectorIndexType(enabled, config);\n    } else if (config instanceof IntInvertedIndexConfig) {\n      const valueType = ensureIntValueType(this.defaults);\n      valueType.intInvertedIndex = new IntInvertedIndexType(enabled, config);\n    } else if (config instanceof FloatInvertedIndexConfig) {\n      const valueType = ensureFloatValueType(this.defaults);\n      valueType.floatInvertedIndex = new FloatInvertedIndexType(\n        enabled,\n        config\n      );\n    } else if (config instanceof BoolInvertedIndexConfig) {\n      const valueType = ensureBoolValueType(this.defaults);\n      valueType.boolInvertedIndex = new BoolInvertedIndexType(enabled, config);\n    }\n  }\n  setIndexForKey(key, config, enabled) {\n    if (config instanceof SparseVectorIndexConfig && enabled) {\n      this.validateSingleSparseVectorIndex(key);\n      this.validateSparseVectorConfig(config);\n    }\n    const current = this.keys[key] = ensureValueTypes(this.keys[key]);\n    if (config instanceof StringInvertedIndexConfig) {\n      const valueType = ensureStringValueType(current);\n      valueType.stringInvertedIndex = new StringInvertedIndexType(\n        enabled,\n        config\n      );\n    } else if (config instanceof FtsIndexConfig) {\n      const valueType = ensureStringValueType(current);\n      valueType.ftsIndex = new FtsIndexType(enabled, config);\n    } else if (config instanceof SparseVectorIndexConfig) {\n      const valueType = ensureSparseVectorValueType(current);\n      valueType.sparseVectorIndex = new SparseVectorIndexType(enabled, config);\n    } else if (config instanceof VectorIndexConfig) {\n      const valueType = ensureFloatListValueType(current);\n      valueType.vectorIndex = new VectorIndexType(enabled, config);\n    } else if (config instanceof IntInvertedIndexConfig) {\n      const valueType = ensureIntValueType(current);\n      valueType.intInvertedIndex = new IntInvertedIndexType(enabled, config);\n    } else if (config instanceof FloatInvertedIndexConfig) {\n      const valueType = ensureFloatValueType(current);\n      valueType.floatInvertedIndex = new FloatInvertedIndexType(\n        enabled,\n        config\n      );\n    } else if (config instanceof BoolInvertedIndexConfig) {\n      const valueType = ensureBoolValueType(current);\n      valueType.boolInvertedIndex = new BoolInvertedIndexType(enabled, config);\n    }\n  }\n  enableAllIndexesForKey(key) {\n    if (key === EMBEDDING_KEY || key === DOCUMENT_KEY) {\n      throw new Error(\n        `Cannot enable all indexes for special key '${key}'. These keys are managed automatically by the system.`\n      );\n    }\n    const current = this.keys[key] = ensureValueTypes(this.keys[key]);\n    current.string = new StringValueType(\n      new FtsIndexType(true, new FtsIndexConfig()),\n      new StringInvertedIndexType(true, new StringInvertedIndexConfig())\n    );\n    current.floatList = new FloatListValueType(\n      new VectorIndexType(true, new VectorIndexConfig())\n    );\n    current.sparseVector = new SparseVectorValueType(\n      new SparseVectorIndexType(false, new SparseVectorIndexConfig())\n    );\n    current.intValue = new IntValueType(\n      new IntInvertedIndexType(true, new IntInvertedIndexConfig())\n    );\n    current.floatValue = new FloatValueType(\n      new FloatInvertedIndexType(true, new FloatInvertedIndexConfig())\n    );\n    current.boolean = new BoolValueType(\n      new BoolInvertedIndexType(true, new BoolInvertedIndexConfig())\n    );\n  }\n  disableAllIndexesForKey(key) {\n    if (key === EMBEDDING_KEY || key === DOCUMENT_KEY) {\n      throw new Error(\n        `Cannot disable all indexes for special key '${key}'. These keys are managed automatically by the system.`\n      );\n    }\n    const current = this.keys[key] = ensureValueTypes(this.keys[key]);\n    current.string = new StringValueType(\n      new FtsIndexType(false, new FtsIndexConfig()),\n      new StringInvertedIndexType(false, new StringInvertedIndexConfig())\n    );\n    current.floatList = new FloatListValueType(\n      new VectorIndexType(false, new VectorIndexConfig())\n    );\n    current.sparseVector = new SparseVectorValueType(\n      new SparseVectorIndexType(false, new SparseVectorIndexConfig())\n    );\n    current.intValue = new IntValueType(\n      new IntInvertedIndexType(false, new IntInvertedIndexConfig())\n    );\n    current.floatValue = new FloatValueType(\n      new FloatInvertedIndexType(false, new FloatInvertedIndexConfig())\n    );\n    current.boolean = new BoolValueType(\n      new BoolInvertedIndexType(false, new BoolInvertedIndexConfig())\n    );\n  }\n  validateSingleSparseVectorIndex(targetKey) {\n    for (const [existingKey, valueTypes] of Object.entries(this.keys)) {\n      if (existingKey === targetKey) continue;\n      const sparseIndex = valueTypes.sparseVector?.sparseVectorIndex;\n      if (sparseIndex?.enabled) {\n        throw new Error(\n          `Cannot enable sparse vector index on key '${targetKey}'. A sparse vector index is already enabled on key '${existingKey}'. Only one sparse vector index is allowed per collection.`\n        );\n      }\n    }\n  }\n  validateSparseVectorConfig(config) {\n    if (config.sourceKey !== null && config.sourceKey !== void 0 && !config.embeddingFunction) {\n      throw new Error(\n        `If sourceKey is provided then embeddingFunction must also be provided since there is no default embedding function. Config: ${JSON.stringify(config)}`\n      );\n    }\n  }\n  initializeDefaults() {\n    this.defaults.string = new StringValueType(\n      new FtsIndexType(false, new FtsIndexConfig()),\n      new StringInvertedIndexType(true, new StringInvertedIndexConfig())\n    );\n    this.defaults.floatList = new FloatListValueType(\n      new VectorIndexType(false, new VectorIndexConfig())\n    );\n    this.defaults.sparseVector = new SparseVectorValueType(\n      new SparseVectorIndexType(false, new SparseVectorIndexConfig())\n    );\n    this.defaults.intValue = new IntValueType(\n      new IntInvertedIndexType(true, new IntInvertedIndexConfig())\n    );\n    this.defaults.floatValue = new FloatValueType(\n      new FloatInvertedIndexType(true, new FloatInvertedIndexConfig())\n    );\n    this.defaults.boolean = new BoolValueType(\n      new BoolInvertedIndexType(true, new BoolInvertedIndexConfig())\n    );\n  }\n  initializeKeys() {\n    this.keys[DOCUMENT_KEY] = new ValueTypes();\n    this.keys[DOCUMENT_KEY].string = new StringValueType(\n      new FtsIndexType(true, new FtsIndexConfig()),\n      new StringInvertedIndexType(false, new StringInvertedIndexConfig())\n    );\n    this.keys[EMBEDDING_KEY] = new ValueTypes();\n    this.keys[EMBEDDING_KEY].floatList = new FloatListValueType(\n      new VectorIndexType(\n        true,\n        new VectorIndexConfig({ sourceKey: DOCUMENT_KEY })\n      )\n    );\n  }\n  serializeValueTypes(valueTypes) {\n    const result = {};\n    if (valueTypes.string) {\n      const serialized = this.serializeStringValueType(valueTypes.string);\n      if (Object.keys(serialized).length > 0) {\n        result[STRING_VALUE_NAME] = serialized;\n      }\n    }\n    if (valueTypes.floatList) {\n      const serialized = this.serializeFloatListValueType(valueTypes.floatList);\n      if (Object.keys(serialized).length > 0) {\n        result[FLOAT_LIST_VALUE_NAME] = serialized;\n      }\n    }\n    if (valueTypes.sparseVector) {\n      const serialized = this.serializeSparseVectorValueType(\n        valueTypes.sparseVector\n      );\n      if (Object.keys(serialized).length > 0) {\n        result[SPARSE_VECTOR_VALUE_NAME] = serialized;\n      }\n    }\n    if (valueTypes.intValue) {\n      const serialized = this.serializeIntValueType(valueTypes.intValue);\n      if (Object.keys(serialized).length > 0) {\n        result[INT_VALUE_NAME] = serialized;\n      }\n    }\n    if (valueTypes.floatValue) {\n      const serialized = this.serializeFloatValueType(valueTypes.floatValue);\n      if (Object.keys(serialized).length > 0) {\n        result[FLOAT_VALUE_NAME] = serialized;\n      }\n    }\n    if (valueTypes.boolean) {\n      const serialized = this.serializeBoolValueType(valueTypes.boolean);\n      if (Object.keys(serialized).length > 0) {\n        result[BOOL_VALUE_NAME] = serialized;\n      }\n    }\n    return result;\n  }\n  serializeStringValueType(valueType) {\n    const result = {};\n    if (valueType.ftsIndex) {\n      result[FTS_INDEX_NAME] = {\n        enabled: valueType.ftsIndex.enabled,\n        config: this.serializeConfig(valueType.ftsIndex.config)\n      };\n    }\n    if (valueType.stringInvertedIndex) {\n      result[STRING_INVERTED_INDEX_NAME] = {\n        enabled: valueType.stringInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.stringInvertedIndex.config)\n      };\n    }\n    return result;\n  }\n  serializeFloatListValueType(valueType) {\n    const result = {};\n    if (valueType.vectorIndex) {\n      result[VECTOR_INDEX_NAME] = {\n        enabled: valueType.vectorIndex.enabled,\n        config: this.serializeConfig(valueType.vectorIndex.config)\n      };\n    }\n    return result;\n  }\n  serializeSparseVectorValueType(valueType) {\n    const result = {};\n    if (valueType.sparseVectorIndex) {\n      result[SPARSE_VECTOR_INDEX_NAME] = {\n        enabled: valueType.sparseVectorIndex.enabled,\n        config: this.serializeConfig(valueType.sparseVectorIndex.config)\n      };\n    }\n    return result;\n  }\n  serializeIntValueType(valueType) {\n    const result = {};\n    if (valueType.intInvertedIndex) {\n      result[INT_INVERTED_INDEX_NAME] = {\n        enabled: valueType.intInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.intInvertedIndex.config)\n      };\n    }\n    return result;\n  }\n  serializeFloatValueType(valueType) {\n    const result = {};\n    if (valueType.floatInvertedIndex) {\n      result[FLOAT_INVERTED_INDEX_NAME] = {\n        enabled: valueType.floatInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.floatInvertedIndex.config)\n      };\n    }\n    return result;\n  }\n  serializeBoolValueType(valueType) {\n    const result = {};\n    if (valueType.boolInvertedIndex) {\n      result[BOOL_INVERTED_INDEX_NAME] = {\n        enabled: valueType.boolInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.boolInvertedIndex.config)\n      };\n    }\n    return result;\n  }\n  serializeConfig(config) {\n    if (config instanceof VectorIndexConfig) {\n      return this.serializeVectorConfig(config);\n    }\n    if (config instanceof SparseVectorIndexConfig) {\n      return this.serializeSparseVectorConfig(config);\n    }\n    return {};\n  }\n  serializeVectorConfig(config) {\n    const serialized = {};\n    const embeddingFunction = config.embeddingFunction;\n    const efConfig = prepareEmbeddingFunctionConfig(embeddingFunction);\n    serialized[\"embedding_function\"] = efConfig;\n    let resolvedSpace = config.space ?? null;\n    if (!resolvedSpace && embeddingFunction?.defaultSpace) {\n      resolvedSpace = embeddingFunction.defaultSpace();\n    }\n    if (resolvedSpace && embeddingFunction?.supportedSpaces && !embeddingFunction.supportedSpaces().includes(resolvedSpace)) {\n      console.warn(\n        `Space '${resolvedSpace}' is not supported by embedding function '${resolveEmbeddingFunctionName(embeddingFunction) ?? \"unknown\"}'. Supported spaces: ${embeddingFunction.supportedSpaces().join(\", \")}`\n      );\n    }\n    if (resolvedSpace) {\n      serialized.space = resolvedSpace;\n    }\n    if (config.sourceKey) {\n      serialized.source_key = config.sourceKey;\n    }\n    if (config.hnsw) {\n      serialized.hnsw = cloneObject(config.hnsw);\n    }\n    if (config.spann) {\n      serialized.spann = cloneObject(config.spann);\n    }\n    return serialized;\n  }\n  serializeSparseVectorConfig(config) {\n    const serialized = {};\n    const embeddingFunction = config.embeddingFunction;\n    serialized[\"embedding_function\"] = prepareEmbeddingFunctionConfig(embeddingFunction);\n    if (config.sourceKey) {\n      serialized.source_key = config.sourceKey;\n    }\n    if (typeof config.bm25 === \"boolean\") {\n      serialized.bm25 = config.bm25;\n    }\n    return serialized;\n  }\n  static async deserializeValueTypes(json, client2) {\n    const result = new ValueTypes();\n    if (json[STRING_VALUE_NAME]) {\n      result.string = _Schema.deserializeStringValueType(\n        json[STRING_VALUE_NAME]\n      );\n    }\n    if (json[FLOAT_LIST_VALUE_NAME]) {\n      result.floatList = await _Schema.deserializeFloatListValueType(\n        json[FLOAT_LIST_VALUE_NAME],\n        client2\n      );\n    }\n    if (json[SPARSE_VECTOR_VALUE_NAME]) {\n      result.sparseVector = await _Schema.deserializeSparseVectorValueType(\n        json[SPARSE_VECTOR_VALUE_NAME],\n        client2\n      );\n    }\n    if (json[INT_VALUE_NAME]) {\n      result.intValue = _Schema.deserializeIntValueType(json[INT_VALUE_NAME]);\n    }\n    if (json[FLOAT_VALUE_NAME]) {\n      result.floatValue = _Schema.deserializeFloatValueType(\n        json[FLOAT_VALUE_NAME]\n      );\n    }\n    if (json[BOOL_VALUE_NAME]) {\n      result.boolean = _Schema.deserializeBoolValueType(json[BOOL_VALUE_NAME]);\n    }\n    return result;\n  }\n  static deserializeStringValueType(json) {\n    let ftsIndex = null;\n    let stringIndex = null;\n    if (json[FTS_INDEX_NAME]) {\n      const data = json[FTS_INDEX_NAME];\n      ftsIndex = new FtsIndexType(Boolean(data.enabled), new FtsIndexConfig());\n    }\n    if (json[STRING_INVERTED_INDEX_NAME]) {\n      const data = json[STRING_INVERTED_INDEX_NAME];\n      stringIndex = new StringInvertedIndexType(\n        Boolean(data.enabled),\n        new StringInvertedIndexConfig()\n      );\n    }\n    return new StringValueType(ftsIndex, stringIndex);\n  }\n  static async deserializeFloatListValueType(json, client2) {\n    let vectorIndex = null;\n    if (json[VECTOR_INDEX_NAME]) {\n      const data = json[VECTOR_INDEX_NAME];\n      const enabled = Boolean(data.enabled);\n      const config = await _Schema.deserializeVectorConfig(\n        data.config ?? {},\n        client2\n      );\n      vectorIndex = new VectorIndexType(enabled, config);\n    }\n    return new FloatListValueType(vectorIndex);\n  }\n  static async deserializeSparseVectorValueType(json, client2) {\n    let sparseIndex = null;\n    if (json[SPARSE_VECTOR_INDEX_NAME]) {\n      const data = json[SPARSE_VECTOR_INDEX_NAME];\n      const enabled = Boolean(data.enabled);\n      const config = await _Schema.deserializeSparseVectorConfig(\n        data.config ?? {},\n        client2\n      );\n      sparseIndex = new SparseVectorIndexType(enabled, config);\n    }\n    return new SparseVectorValueType(sparseIndex);\n  }\n  static deserializeIntValueType(json) {\n    let index = null;\n    if (json[INT_INVERTED_INDEX_NAME]) {\n      const data = json[INT_INVERTED_INDEX_NAME];\n      index = new IntInvertedIndexType(\n        Boolean(data.enabled),\n        new IntInvertedIndexConfig()\n      );\n    }\n    return new IntValueType(index);\n  }\n  static deserializeFloatValueType(json) {\n    let index = null;\n    if (json[FLOAT_INVERTED_INDEX_NAME]) {\n      const data = json[FLOAT_INVERTED_INDEX_NAME];\n      index = new FloatInvertedIndexType(\n        Boolean(data.enabled),\n        new FloatInvertedIndexConfig()\n      );\n    }\n    return new FloatValueType(index);\n  }\n  static deserializeBoolValueType(json) {\n    let index = null;\n    if (json[BOOL_INVERTED_INDEX_NAME]) {\n      const data = json[BOOL_INVERTED_INDEX_NAME];\n      index = new BoolInvertedIndexType(\n        Boolean(data.enabled),\n        new BoolInvertedIndexConfig()\n      );\n    }\n    return new BoolValueType(index);\n  }\n  static async deserializeVectorConfig(json, client2) {\n    const config = new VectorIndexConfig({\n      space: json.space ?? null,\n      sourceKey: json.source_key ?? null,\n      hnsw: json.hnsw ? cloneObject(json.hnsw) : null,\n      spann: json.spann ? cloneObject(json.spann) : null\n    });\n    config.embeddingFunction = await getEmbeddingFunction({\n      collectionName: \"schema deserialization\",\n      client: client2,\n      efConfig: json.embedding_function\n    });\n    if (!config.space && config.embeddingFunction?.defaultSpace) {\n      config.space = config.embeddingFunction.defaultSpace();\n    }\n    return config;\n  }\n  static async deserializeSparseVectorConfig(json, client2) {\n    const config = new SparseVectorIndexConfig({\n      sourceKey: json.source_key ?? null,\n      bm25: typeof json.bm25 === \"boolean\" ? json.bm25 : null\n    });\n    const embeddingFunction = await getSparseEmbeddingFunction(\n      \"schema deserialization\",\n      client2,\n      json.embedding_function\n    ) ?? config.embeddingFunction ?? void 0;\n    config.embeddingFunction = embeddingFunction ?? null;\n    return config;\n  }\n  resolveEmbeddingFunction() {\n    const embeddingOverride = this.keys[EMBEDDING_KEY]?.floatList?.vectorIndex?.config.embeddingFunction;\n    if (embeddingOverride !== void 0) {\n      return embeddingOverride;\n    }\n    return this.defaults.floatList?.vectorIndex?.config.embeddingFunction;\n  }\n};\n\n// src/collection.ts\nvar CollectionImpl = class _CollectionImpl {\n  /**\n   * Creates a new CollectionAPIImpl instance.\n   * @param options - Configuration for the collection API\n   */\n  constructor({\n    chromaClient,\n    apiClient,\n    id,\n    tenant,\n    database,\n    name,\n    metadata,\n    configuration,\n    embeddingFunction,\n    schema\n  }) {\n    this.chromaClient = chromaClient;\n    this.apiClient = apiClient;\n    this.id = id;\n    this.tenant = tenant;\n    this.database = database;\n    this._name = name;\n    this._metadata = metadata;\n    this._configuration = configuration;\n    this._embeddingFunction = embeddingFunction;\n    this._schema = schema;\n  }\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n  }\n  get configuration() {\n    return this._configuration;\n  }\n  set configuration(configuration) {\n    this._configuration = configuration;\n  }\n  get metadata() {\n    return this._metadata;\n  }\n  set metadata(metadata) {\n    this._metadata = metadata;\n  }\n  get embeddingFunction() {\n    return this._embeddingFunction;\n  }\n  set embeddingFunction(embeddingFunction) {\n    this._embeddingFunction = embeddingFunction;\n  }\n  get schema() {\n    return this._schema;\n  }\n  set schema(schema) {\n    this._schema = schema;\n  }\n  async path() {\n    return {\n      tenant: this.tenant,\n      database: this.database,\n      collection_id: this.id\n    };\n  }\n  async embed(inputs, isQuery) {\n    const embeddingFunction = this._embeddingFunction ?? this.getSchemaEmbeddingFunction();\n    if (!embeddingFunction) {\n      throw new ChromaValueError(\n        \"Embedding function must be defined for operations requiring embeddings.\"\n      );\n    }\n    if (isQuery && embeddingFunction.generateForQueries) {\n      return await embeddingFunction.generateForQueries(inputs);\n    }\n    return await embeddingFunction.generate(inputs);\n  }\n  async sparseEmbed(sparseEmbeddingFunction, inputs, isQuery) {\n    if (isQuery && sparseEmbeddingFunction.generateForQueries) {\n      return await sparseEmbeddingFunction.generateForQueries(inputs);\n    }\n    return await sparseEmbeddingFunction.generate(inputs);\n  }\n  getSparseEmbeddingTargets() {\n    const schema = this._schema;\n    if (!schema) return {};\n    const targets = {};\n    for (const [key, valueTypes] of Object.entries(schema.keys)) {\n      const sparseVector = valueTypes.sparseVector;\n      const sparseIndex = sparseVector?.sparseVectorIndex;\n      if (!sparseIndex?.enabled) continue;\n      const config = sparseIndex.config;\n      if (!config.embeddingFunction || !config.sourceKey) continue;\n      targets[key] = config;\n    }\n    return targets;\n  }\n  async applySparseEmbeddingsToMetadatas(metadatas, documents) {\n    const sparseTargets = this.getSparseEmbeddingTargets();\n    if (Object.keys(sparseTargets).length === 0) {\n      return metadatas;\n    }\n    if (!metadatas) {\n      if (!documents) {\n        return void 0;\n      }\n      metadatas = Array(documents.length).fill(null).map(() => ({}));\n    }\n    const updatedMetadatas = metadatas.map(\n      (metadata) => metadata !== null && metadata !== void 0 ? { ...metadata } : {}\n    );\n    const documentsList = documents ? [...documents] : void 0;\n    for (const [targetKey, config] of Object.entries(sparseTargets)) {\n      const sourceKey = config.sourceKey;\n      const embeddingFunction = config.embeddingFunction;\n      if (!sourceKey || !embeddingFunction) {\n        continue;\n      }\n      const inputs = [];\n      const positions = [];\n      if (sourceKey === DOCUMENT_KEY) {\n        if (!documentsList) {\n          continue;\n        }\n        updatedMetadatas.forEach((metadata, index) => {\n          if (targetKey in metadata) {\n            return;\n          }\n          if (index < documentsList.length) {\n            const doc = documentsList[index];\n            if (typeof doc === \"string\") {\n              inputs.push(doc);\n              positions.push(index);\n            }\n          }\n        });\n        if (inputs.length === 0) {\n          continue;\n        }\n        const sparseEmbeddings2 = await this.sparseEmbed(\n          embeddingFunction,\n          inputs,\n          false\n        );\n        if (sparseEmbeddings2.length !== positions.length) {\n          throw new ChromaValueError(\n            \"Sparse embedding function returned unexpected number of embeddings.\"\n          );\n        }\n        positions.forEach((position, idx) => {\n          updatedMetadatas[position][targetKey] = sparseEmbeddings2[idx];\n        });\n        continue;\n      }\n      updatedMetadatas.forEach((metadata, index) => {\n        if (targetKey in metadata) {\n          return;\n        }\n        const sourceValue = metadata[sourceKey];\n        if (typeof sourceValue !== \"string\") {\n          return;\n        }\n        inputs.push(sourceValue);\n        positions.push(index);\n      });\n      if (inputs.length === 0) {\n        continue;\n      }\n      const sparseEmbeddings = await this.sparseEmbed(\n        embeddingFunction,\n        inputs,\n        false\n      );\n      if (sparseEmbeddings.length !== positions.length) {\n        throw new ChromaValueError(\n          \"Sparse embedding function returned unexpected number of embeddings.\"\n        );\n      }\n      positions.forEach((position, idx) => {\n        updatedMetadatas[position][targetKey] = sparseEmbeddings[idx];\n      });\n    }\n    const resultMetadatas = updatedMetadatas.map(\n      (metadata) => Object.keys(metadata).length === 0 ? null : metadata\n    );\n    return resultMetadatas;\n  }\n  async embedKnnLiteral(knn) {\n    const queryValue = knn.query;\n    if (typeof queryValue !== \"string\") {\n      return { ...knn };\n    }\n    const keyValue = knn.key;\n    const key = typeof keyValue === \"string\" ? keyValue : EMBEDDING_KEY;\n    if (key === EMBEDDING_KEY) {\n      const embeddings = await this.embed([queryValue], true);\n      if (!embeddings || embeddings.length !== 1) {\n        throw new ChromaValueError(\n          \"Embedding function returned unexpected number of embeddings.\"\n        );\n      }\n      return { ...knn, query: embeddings[0] };\n    }\n    const schema = this._schema;\n    if (!schema) {\n      throw new ChromaValueError(\n        `Cannot embed string query for key '${key}': schema is not available. Provide an embedded vector or configure an embedding function.`\n      );\n    }\n    const valueTypes = schema.keys[key];\n    if (!valueTypes) {\n      throw new ChromaValueError(\n        `Cannot embed string query for key '${key}': key not found in schema. Provide an embedded vector or configure an embedding function.`\n      );\n    }\n    const sparseIndex = valueTypes.sparseVector?.sparseVectorIndex;\n    if (sparseIndex?.enabled && sparseIndex.config.embeddingFunction) {\n      const sparseEmbeddingFunction = sparseIndex.config.embeddingFunction;\n      const sparseEmbeddings = await this.sparseEmbed(\n        sparseEmbeddingFunction,\n        [queryValue],\n        true\n      );\n      if (!sparseEmbeddings || sparseEmbeddings.length !== 1) {\n        throw new ChromaValueError(\n          \"Sparse embedding function returned unexpected number of embeddings.\"\n        );\n      }\n      return { ...knn, query: sparseEmbeddings[0] };\n    }\n    const vectorIndex = valueTypes.floatList?.vectorIndex;\n    if (vectorIndex?.enabled && vectorIndex.config.embeddingFunction) {\n      const embeddingFunction = vectorIndex.config.embeddingFunction;\n      const embeddings = embeddingFunction.generateForQueries ? await embeddingFunction.generateForQueries([queryValue]) : await embeddingFunction.generate([queryValue]);\n      if (!embeddings || embeddings.length !== 1) {\n        throw new ChromaValueError(\n          \"Embedding function returned unexpected number of embeddings.\"\n        );\n      }\n      return { ...knn, query: embeddings[0] };\n    }\n    throw new ChromaValueError(\n      `Cannot embed string query for key '${key}': no embedding function configured. Provide an embedded vector or configure an embedding function.`\n    );\n  }\n  async embedRankLiteral(rank) {\n    if (rank === null || rank === void 0) {\n      return rank;\n    }\n    if (Array.isArray(rank)) {\n      return Promise.all(rank.map((item) => this.embedRankLiteral(item)));\n    }\n    if (!isPlainObject(rank)) {\n      return rank;\n    }\n    const entries = await Promise.all(\n      Object.entries(rank).map(async ([key, value]) => {\n        if (key === \"$knn\" && isPlainObject(value)) {\n          return [key, await this.embedKnnLiteral(value)];\n        }\n        return [key, await this.embedRankLiteral(value)];\n      })\n    );\n    return Object.fromEntries(entries);\n  }\n  async embedSearchPayload(payload) {\n    if (!payload.rank) {\n      return payload;\n    }\n    const embeddedRank = await this.embedRankLiteral(payload.rank);\n    if (!isPlainObject(embeddedRank)) {\n      return payload;\n    }\n    return {\n      ...payload,\n      rank: embeddedRank\n    };\n  }\n  getSchemaEmbeddingFunction() {\n    const schema = this._schema;\n    if (!schema) return void 0;\n    const schemaOverride = schema.keys[EMBEDDING_KEY];\n    const overrideFunction = schemaOverride?.floatList?.vectorIndex?.config.embeddingFunction;\n    if (overrideFunction) {\n      return overrideFunction;\n    }\n    const defaultFunction = schema.defaults.floatList?.vectorIndex?.config.embeddingFunction;\n    return defaultFunction ?? void 0;\n  }\n  async prepareRecords({\n    recordSet,\n    update = false\n  }) {\n    const maxBatchSize = await this.chromaClient.getMaxBatchSize();\n    validateRecordSetLengthConsistency(recordSet);\n    validateIDs(recordSet.ids);\n    validateBaseRecordSet({ recordSet, update });\n    validateMaxBatchSize(recordSet.ids.length, maxBatchSize);\n    if (!recordSet.embeddings && recordSet.documents) {\n      recordSet.embeddings = await this.embed(recordSet.documents, false);\n    }\n    const metadatasWithSparse = await this.applySparseEmbeddingsToMetadatas(\n      recordSet.metadatas,\n      recordSet.documents\n    );\n    const preparedRecordSet = {\n      ...recordSet,\n      metadatas: metadatasWithSparse\n    };\n    const base64Supported = await this.chromaClient.supportsBase64Encoding();\n    if (base64Supported && recordSet.embeddings) {\n      preparedRecordSet.embeddings = embeddingsToBase64Bytes(\n        recordSet.embeddings\n      );\n    }\n    return preparedRecordSet;\n  }\n  validateGet(include, ids, where, whereDocument) {\n    validateInclude({ include, exclude: [\"distances\"] });\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n  async prepareQuery(recordSet, include, ids, where, whereDocument, nResults) {\n    validateBaseRecordSet({\n      recordSet,\n      embeddingsField: \"queryEmbeddings\",\n      documentsField: \"queryTexts\"\n    });\n    validateInclude({ include });\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n    if (nResults) validateNResults(nResults);\n    let embeddings;\n    if (!recordSet.embeddings) {\n      embeddings = await this.embed(recordSet.documents, true);\n    } else {\n      embeddings = recordSet.embeddings;\n    }\n    return {\n      ...recordSet,\n      ids,\n      embeddings\n    };\n  }\n  validateDelete(ids, where, whereDocument) {\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n  async count() {\n    const { data } = await DefaultService.collectionCount({\n      client: this.apiClient,\n      path: await this.path()\n    });\n    return data;\n  }\n  async add({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris\n  }) {\n    const recordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris\n    };\n    const preparedRecordSet = await this.prepareRecords({ recordSet });\n    await DefaultService.collectionAdd({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        documents: preparedRecordSet.documents,\n        metadatas: serializeMetadatas(preparedRecordSet.metadatas),\n        uris: preparedRecordSet.uris\n      }\n    });\n  }\n  async get(args = {}) {\n    const {\n      ids,\n      where,\n      limit,\n      offset,\n      whereDocument,\n      include = [\"documents\", \"metadatas\"]\n    } = args;\n    this.validateGet(include, ids, where, whereDocument);\n    const { data } = await DefaultService.collectionGet({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        limit,\n        offset,\n        where_document: whereDocument,\n        include\n      }\n    });\n    const deserializedMetadatas = deserializeMetadatas(data.metadatas) ?? [];\n    return new GetResult({\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids,\n      include: data.include,\n      metadatas: deserializedMetadatas,\n      uris: data.uris ?? []\n    });\n  }\n  async peek({ limit = 10 }) {\n    return this.get({ limit });\n  }\n  async query({\n    queryEmbeddings,\n    queryTexts,\n    queryURIs,\n    ids,\n    nResults = 10,\n    where,\n    whereDocument,\n    include = [\"metadatas\", \"documents\", \"distances\"]\n  }) {\n    const recordSet = {\n      embeddings: queryEmbeddings,\n      documents: queryTexts,\n      uris: queryURIs\n    };\n    const queryRecordSet = await this.prepareQuery(\n      recordSet,\n      include,\n      ids,\n      where,\n      whereDocument,\n      nResults\n    );\n    const { data } = await DefaultService.collectionQuery({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: queryRecordSet.ids,\n        include,\n        n_results: nResults,\n        query_embeddings: queryRecordSet.embeddings,\n        where,\n        where_document: whereDocument\n      }\n    });\n    const deserializedMetadatas = deserializeMetadataMatrix(data.metadatas) ?? [];\n    return new QueryResult({\n      distances: data.distances ?? [],\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids ?? [],\n      include: data.include,\n      metadatas: deserializedMetadatas,\n      uris: data.uris ?? []\n    });\n  }\n  async search(searches) {\n    const items = Array.isArray(searches) ? searches : [searches];\n    if (items.length === 0) {\n      throw new ChromaValueError(\n        \"At least one search payload must be provided.\"\n      );\n    }\n    const payloads = await Promise.all(\n      items.map(async (search) => {\n        const payload = toSearch(search).toPayload();\n        return this.embedSearchPayload(payload);\n      })\n    );\n    const { data } = await DefaultService.collectionSearch({\n      client: this.apiClient,\n      path: await this.path(),\n      body: { searches: payloads }\n    });\n    return new SearchResult(data);\n  }\n  async modify({\n    name,\n    metadata,\n    configuration\n  }) {\n    if (name) this.name = name;\n    if (metadata) {\n      validateMetadata(metadata);\n      this.metadata = metadata;\n    }\n    const { updateConfiguration, updateEmbeddingFunction } = configuration ? await processUpdateCollectionConfig({\n      collectionName: this.name,\n      currentConfiguration: this.configuration,\n      newConfiguration: configuration,\n      currentEmbeddingFunction: this.embeddingFunction,\n      client: this.chromaClient\n    }) : {};\n    if (updateEmbeddingFunction) {\n      this.embeddingFunction = updateEmbeddingFunction;\n    }\n    if (updateConfiguration) {\n      this.configuration = {\n        hnsw: { ...this.configuration.hnsw, ...updateConfiguration.hnsw },\n        spann: { ...this.configuration.spann, ...updateConfiguration.spann },\n        embeddingFunction: updateConfiguration.embedding_function\n      };\n    }\n    await DefaultService.updateCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        new_name: name,\n        new_metadata: serializeMetadata(metadata),\n        new_configuration: updateConfiguration\n      }\n    });\n  }\n  async fork({ name }) {\n    const { data } = await DefaultService.forkCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: { new_name: name }\n    });\n    return new _CollectionImpl({\n      chromaClient: this.chromaClient,\n      apiClient: this.apiClient,\n      name: data.name,\n      tenant: this.tenant,\n      database: this.database,\n      id: data.id,\n      embeddingFunction: this._embeddingFunction,\n      metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,\n      configuration: data.configuration_json\n    });\n  }\n  async update({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris\n  }) {\n    const recordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris\n    };\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet,\n      update: true\n    });\n    await DefaultService.collectionUpdate({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: serializeMetadatas(preparedRecordSet.metadatas),\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents\n      }\n    });\n  }\n  async upsert({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris\n  }) {\n    const recordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris\n    };\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet\n    });\n    await DefaultService.collectionUpsert({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: serializeMetadatas(preparedRecordSet.metadatas),\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents\n      }\n    });\n  }\n  async delete({\n    ids,\n    where,\n    whereDocument\n  }) {\n    this.validateDelete(ids, where, whereDocument);\n    await DefaultService.collectionDelete({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        where_document: whereDocument\n      }\n    });\n  }\n};\n\n// src/next.ts\nfunction withChroma(userNextConfig = {}) {\n  const originalWebpackFunction = userNextConfig.webpack;\n  const newWebpackFunction = (config, options) => {\n    if (!Array.isArray(config.externals)) {\n      config.externals = [];\n    }\n    const externalsToAdd = [\"@huggingface/transformers\", \"chromadb\"];\n    for (const ext of externalsToAdd) {\n      if (!config.externals.includes(ext)) {\n        config.externals.push(ext);\n      }\n    }\n    if (typeof originalWebpackFunction === \"function\") {\n      return originalWebpackFunction(config, options);\n    }\n    return config;\n  };\n  return {\n    ...userNextConfig,\n    webpack: newWebpackFunction\n  };\n}\n\n// src/chroma-fetch.ts\nvar offlineError = (error) => {\n  return Boolean(\n    (error?.name === \"TypeError\" || error?.name === \"FetchError\") && (error.message?.includes(\"fetch failed\") || error.message?.includes(\"Failed to fetch\") || error.message?.includes(\"ENOTFOUND\"))\n  );\n};\nvar getErrorMessage = async (response) => {\n  try {\n    const body = await response.clone().json();\n    return body.message || body.error || `${response.status}: ${response.statusText}`;\n  } catch {\n    return `${response.status}: ${response.statusText}`;\n  }\n};\nvar chromaFetch = async (input, init) => {\n  let response;\n  try {\n    response = await fetch(input, init);\n  } catch (err) {\n    if (offlineError(err)) {\n      throw new ChromaConnectionError(\n        \"Failed to connect to chromadb. Make sure your server is running and try again. If you are running from a browser, make sure that your chromadb instance is configured to allow requests from the current origin using the CHROMA_SERVER_CORS_ALLOW_ORIGINS environment variable.\"\n      );\n    }\n    throw new ChromaConnectionError(\"Failed to connect to Chroma\");\n  }\n  if (response.ok) {\n    return response;\n  }\n  switch (response.status) {\n    case 400:\n      let status = \"Bad Request\";\n      try {\n        const responseBody = await response.json();\n        status = responseBody.message || status;\n      } catch {\n      }\n      throw new ChromaClientError(\n        `Bad request to ${input.url || \"Chroma\"} with status: ${status}`\n      );\n    case 401:\n      throw new ChromaUnauthorizedError(`Unauthorized`);\n    case 403:\n      throw new ChromaForbiddenError(\n        `You do not have permission to access the requested resource.`\n      );\n    case 404:\n      throw new ChromaNotFoundError(\n        `The requested resource could not be found`\n      );\n    case 409:\n      throw new ChromaUniqueError(\"The resource already exists\");\n    case 422:\n      try {\n        const body = await response.json();\n        if (body && body.message && (body.message.startsWith(\"Quota exceeded\") || body.message.startsWith(\"Billing limit exceeded\"))) {\n          throw new ChromaQuotaExceededError(body?.message);\n        }\n        throw new ChromaClientError(body?.message || \"Unprocessable Entity\");\n      } catch (error) {\n        if (error instanceof ChromaQuotaExceededError || error instanceof ChromaClientError) {\n          throw error;\n        }\n        throw new ChromaClientError(`Unprocessable Entity: ${response.statusText}`);\n      }\n    case 429:\n      throw new ChromaRateLimitError(\"Rate limit exceeded\");\n  }\n  const errorMessage = await getErrorMessage(response);\n  throw new ChromaServerError(errorMessage);\n};\n\n// src/admin-client.ts\nvar AdminClient = class {\n  /**\n   * Creates a new AdminClient instance.\n   * @param args - Optional configuration for the admin client\n   */\n  constructor(args) {\n    const { host, port, ssl, headers, fetchOptions } = args || defaultAdminClientArgs;\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method),\n      baseUrl,\n      headers\n    };\n    this.apiClient = J(w(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n  /**\n   * Creates a new database within a tenant.\n   * @param options - Database creation options\n   * @param options.name - Name of the database to create\n   * @param options.tenant - Tenant that will own the database\n   */\n  async createDatabase({\n    name,\n    tenant\n  }) {\n    await DefaultService.createDatabase({\n      client: this.apiClient,\n      path: { tenant },\n      body: { name }\n    });\n  }\n  /**\n   * Retrieves information about a specific database.\n   * @param options - Database retrieval options\n   * @param options.name - Name of the database to retrieve\n   * @param options.tenant - Tenant that owns the database\n   * @returns Promise resolving to database information\n   */\n  async getDatabase({\n    name,\n    tenant\n  }) {\n    const { data } = await DefaultService.getDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name }\n    });\n    return data;\n  }\n  /**\n   * Deletes a database and all its data.\n   * @param options - Database deletion options\n   * @param options.name - Name of the database to delete\n   * @param options.tenant - Tenant that owns the database\n   * @warning This operation is irreversible and will delete all data\n   */\n  async deleteDatabase({\n    name,\n    tenant\n  }) {\n    await DefaultService.deleteDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name }\n    });\n  }\n  /**\n   * Lists all databases within a tenant.\n   * @param args - Listing parameters including tenant and pagination\n   * @returns Promise resolving to an array of database information\n   */\n  async listDatabases(args) {\n    const { limit = 100, offset = 0, tenant } = args;\n    const { data } = await DefaultService.listDatabases({\n      client: this.apiClient,\n      path: { tenant },\n      query: { limit, offset }\n    });\n    return data;\n  }\n  /**\n   * Creates a new tenant.\n   * @param options - Tenant creation options\n   * @param options.name - Name of the tenant to create\n   */\n  async createTenant({ name }) {\n    await DefaultService.createTenant({\n      client: this.apiClient,\n      body: { name }\n    });\n  }\n  /**\n   * Retrieves information about a specific tenant.\n   * @param options - Tenant retrieval options\n   * @param options.name - Name of the tenant to retrieve\n   * @returns Promise resolving to the tenant name\n   */\n  async getTenant({ name }) {\n    const { data } = await DefaultService.getTenant({\n      client: this.apiClient,\n      path: { tenant_name: name }\n    });\n    return data.name;\n  }\n};\n\n// src/chroma-client.ts\n\nvar resolveSchemaEmbeddingFunction = (schema) => {\n  if (!schema) {\n    return void 0;\n  }\n  const embeddingOverride = schema.keys[EMBEDDING_KEY]?.floatList?.vectorIndex?.config.embeddingFunction ?? void 0;\n  if (embeddingOverride) {\n    return embeddingOverride;\n  }\n  return schema.defaults.floatList?.vectorIndex?.config.embeddingFunction ?? void 0;\n};\nvar ChromaClient = class {\n  /**\n   * Creates a new ChromaClient instance.\n   * @param args - Configuration options for the client\n   */\n  constructor(args = {}) {\n    let {\n      host = defaultChromaClientArgs.host,\n      port = defaultChromaClientArgs.port,\n      ssl = defaultChromaClientArgs.ssl,\n      tenant = defaultChromaClientArgs.tenant,\n      database = defaultChromaClientArgs.database,\n      headers = defaultChromaClientArgs.headers,\n      fetchOptions = defaultChromaClientArgs.fetchOptions\n    } = args;\n    if (args.path) {\n      console.warn(\n        \"The 'path' argument is deprecated. Please use 'ssl', 'host', and 'port' instead\"\n      );\n      const parsedPath = parseConnectionPath(args.path);\n      ssl = parsedPath.ssl;\n      host = parsedPath.host;\n      port = parsedPath.port;\n    }\n    if (args.auth) {\n      console.warn(\n        \"The 'auth' argument is deprecated. Please use 'headers' instead\"\n      );\n      if (!headers) {\n        headers = {};\n      }\n      if (!headers[\"x-chroma-token\"] && args.auth.tokenHeaderType === \"X_CHROMA_TOKEN\" && args.auth.credentials) {\n        headers[\"x-chroma-token\"] = args.auth.credentials;\n      }\n    }\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n    this._tenant = tenant || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_TENANT;\n    this._database = database || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_DATABASE;\n    this._headers = headers;\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method),\n      baseUrl,\n      headers\n    };\n    this.apiClient = J(w(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n  /**\n   * Gets the current tenant name.\n   * @returns The tenant name or undefined if not set\n   */\n  get tenant() {\n    return this._tenant;\n  }\n  set tenant(tenant) {\n    this._tenant = tenant;\n  }\n  /**\n   * Gets the current database name.\n   * @returns The database name or undefined if not set\n   */\n  get database() {\n    return this._database;\n  }\n  set database(database) {\n    this._database = database;\n  }\n  /**\n   * Gets the preflight checks\n   * @returns The preflight checks or undefined if not set\n   */\n  get preflightChecks() {\n    return this._preflightChecks;\n  }\n  set preflightChecks(preflightChecks) {\n    this._preflightChecks = preflightChecks;\n  }\n  get headers() {\n    return this._headers;\n  }\n  /** @ignore */\n  async _path() {\n    if (!this._tenant || !this._database) {\n      const { tenant, databases } = await this.getUserIdentity();\n      const uniqueDBs = [...new Set(databases)];\n      this._tenant = tenant;\n      if (uniqueDBs.length === 0) {\n        throw new ChromaUnauthorizedError(\n          `Your API key does not have access to any DBs for tenant ${this.tenant}`\n        );\n      }\n      if (uniqueDBs.length > 1 || uniqueDBs[0] === \"*\") {\n        throw new ChromaValueError(\n          \"Your API key is scoped to more than 1 DB. Please provide a DB name to the CloudClient constructor\"\n        );\n      }\n      this._database = uniqueDBs[0];\n    }\n    return { tenant: this._tenant, database: this._database };\n  }\n  /**\n   * Gets the user identity information including tenant and accessible databases.\n   * @returns Promise resolving to user identity data\n   */\n  async getUserIdentity() {\n    const { data } = await DefaultService.getUserIdentity({\n      client: this.apiClient\n    });\n    return data;\n  }\n  /**\n   * Sends a heartbeat request to check server connectivity.\n   * @returns Promise resolving to the server's nanosecond heartbeat timestamp\n   */\n  async heartbeat() {\n    const { data } = await DefaultService.heartbeat({\n      client: this.apiClient\n    });\n    return data[\"nanosecond heartbeat\"];\n  }\n  /**\n   * Lists all collections in the current database.\n   * @param args - Optional pagination parameters\n   * @param args.limit - Maximum number of collections to return (default: 100)\n   * @param args.offset - Number of collections to skip (default: 0)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  async listCollections(args) {\n    const { limit = 100, offset = 0 } = args || {};\n    const { data } = await DefaultService.listCollections({\n      client: this.apiClient,\n      path: await this._path(),\n      query: { limit, offset }\n    });\n    return Promise.all(\n      data.map(async (collection) => {\n        const schema = await Schema.deserializeFromJSON(\n          collection.schema ?? null,\n          this\n        );\n        const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);\n        const resolvedEmbeddingFunction = await getEmbeddingFunction({\n          collectionName: collection.name,\n          client: this,\n          efConfig: collection.configuration_json.embedding_function ?? void 0\n        }) ?? schemaEmbeddingFunction;\n        return new CollectionImpl({\n          chromaClient: this,\n          apiClient: this.apiClient,\n          tenant: collection.tenant,\n          database: collection.database,\n          name: collection.name,\n          id: collection.id,\n          embeddingFunction: resolvedEmbeddingFunction,\n          configuration: collection.configuration_json,\n          metadata: deserializeMetadata(collection.metadata ?? void 0) ?? void 0,\n          schema\n        });\n      })\n    );\n  }\n  /**\n   * Gets the total number of collections in the current database.\n   * @returns Promise resolving to the collection count\n   */\n  async countCollections() {\n    const { data } = await DefaultService.countCollections({\n      client: this.apiClient,\n      path: await this._path()\n    });\n    return data;\n  }\n  /**\n   * Creates a new collection with the specified configuration.\n   * @param options - Collection creation options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration\n   * @param options.metadata - Optional metadata for the collection\n   * @param options.embeddingFunction - Optional embedding function to use. Defaults to `DefaultEmbeddingFunction` from @chroma-core/default-embed\n   * @returns Promise resolving to the created Collection instance\n   * @throws Error if a collection with the same name already exists\n   */\n  async createCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction,\n    schema\n  }) {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction,\n      metadata,\n      schema\n    });\n    const { data } = await DefaultService.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata: serializeMetadata(metadata),\n        get_or_create: false,\n        schema: schema ? schema.serializeToJSON() : void 0\n      }\n    });\n    const serverSchema = await Schema.deserializeFromJSON(\n      data.schema ?? null,\n      this\n    );\n    const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(serverSchema);\n    const resolvedEmbeddingFunction = embeddingFunction ?? await getEmbeddingFunction({\n      collectionName: data.name,\n      client: this,\n      efConfig: data.configuration_json.embedding_function ?? void 0\n    }) ?? schemaEmbeddingFunction;\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema: serverSchema\n    });\n  }\n  /**\n   * Retrieves an existing collection by name.\n   * @param options - Collection retrieval options\n   * @param options.name - The name of the collection to retrieve\n   * @param options.embeddingFunction - Optional embedding function. Should match the one used to create the collection.\n   * @returns Promise resolving to the Collection instance\n   * @throws Error if the collection does not exist\n   */\n  async getCollection({\n    name,\n    embeddingFunction\n  }) {\n    const { data } = await DefaultService.getCollection({\n      client: this.apiClient,\n      path: { ...await this._path(), collection_id: name }\n    });\n    const schema = await Schema.deserializeFromJSON(data.schema ?? null, this);\n    const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);\n    const resolvedEmbeddingFunction = embeddingFunction ?? await getEmbeddingFunction({\n      collectionName: data.name,\n      client: this,\n      efConfig: data.configuration_json.embedding_function ?? void 0\n    }) ?? schemaEmbeddingFunction;\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema\n    });\n  }\n  /**\n   * Retrieves an existing collection by its Chroma Resource Name (CRN).\n   * @param crn - The Chroma Resource Name of the collection to retrieve\n   * @returns Promise resolving to the Collection instance\n   * @throws Error if the collection does not exist\n   */\n  async getCollectionByCrn(crn) {\n    const { data } = await DefaultService.getCollectionByCrn({\n      client: this.apiClient,\n      path: { crn }\n    });\n    const schema = await Schema.deserializeFromJSON(data.schema ?? null, this);\n    const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);\n    const resolvedEmbeddingFunction = await getEmbeddingFunction({\n      collectionName: data.name,\n      efConfig: data.configuration_json.embedding_function ?? void 0,\n      client: this\n    }) ?? schemaEmbeddingFunction;\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name: data.name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema\n    });\n  }\n  /**\n   * Retrieves multiple collections by name.\n   * @param items - Array of collection names or objects with name and optional embedding function (should match the ones used to create the collections)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  async getCollections(items) {\n    if (items.length === 0) return [];\n    let requestedCollections = items;\n    if (typeof items[0] === \"string\") {\n      requestedCollections = items.map((item) => {\n        return { name: item, embeddingFunction: void 0 };\n      });\n    }\n    let collections = requestedCollections;\n    return Promise.all(\n      collections.map(async (collection) => {\n        return this.getCollection({ ...collection });\n      })\n    );\n  }\n  /**\n   * Gets an existing collection or creates it if it doesn't exist.\n   * @param options - Collection options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration (used only if creating)\n   * @param options.metadata - Optional metadata for the collection (used only if creating)\n   * @param options.embeddingFunction - Optional embedding function to use\n   * @returns Promise resolving to the Collection instance\n   */\n  async getOrCreateCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction,\n    schema\n  }) {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction,\n      metadata,\n      schema\n    });\n    const { data } = await DefaultService.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata: serializeMetadata(metadata),\n        get_or_create: true,\n        schema: schema ? schema.serializeToJSON() : void 0\n      }\n    });\n    const serverSchema = await Schema.deserializeFromJSON(\n      data.schema ?? null,\n      this\n    );\n    const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(serverSchema);\n    const resolvedEmbeddingFunction = embeddingFunction ?? await getEmbeddingFunction({\n      collectionName: name,\n      efConfig: data.configuration_json.embedding_function ?? void 0,\n      client: this\n    }) ?? schemaEmbeddingFunction;\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema: serverSchema\n    });\n  }\n  /**\n   * Deletes a collection and all its data.\n   * @param options - Deletion options\n   * @param options.name - The name of the collection to delete\n   */\n  async deleteCollection({ name }) {\n    await DefaultService.deleteCollection({\n      client: this.apiClient,\n      path: { ...await this._path(), collection_id: name }\n    });\n  }\n  /**\n   * Resets the entire database, deleting all collections and data.\n   * @returns Promise that resolves when the reset is complete\n   * @warning This operation is irreversible and will delete all data\n   */\n  async reset() {\n    await DefaultService.reset({\n      client: this.apiClient\n    });\n  }\n  /**\n   * Gets the version of the Chroma server.\n   * @returns Promise resolving to the server version string\n   */\n  async version() {\n    const { data } = await DefaultService.version({\n      client: this.apiClient\n    });\n    return data;\n  }\n  /**\n   * Gets the preflight checks\n   * @returns Promise resolving to the preflight checks\n   */\n  async getPreflightChecks() {\n    if (!this.preflightChecks) {\n      const { data } = await DefaultService.preFlightChecks({\n        client: this.apiClient\n      });\n      this.preflightChecks = data;\n      return this.preflightChecks;\n    }\n    return this.preflightChecks;\n  }\n  /**\n   * Gets the max batch size\n   * @returns Promise resolving to the max batch size\n   */\n  async getMaxBatchSize() {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.max_batch_size ?? -1;\n  }\n  /**\n   * Gets whether base64_encoding is supported by the connected server\n   * @returns Promise resolving to whether base64_encoding is supported\n   */\n  async supportsBase64Encoding() {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.supports_base64_encoding ?? false;\n  }\n};\n\n// src/cloud-client.ts\n\nvar CloudClient = class extends ChromaClient {\n  /**\n   * Creates a new CloudClient instance for Chroma Cloud.\n   * @param args - Cloud client configuration options\n   */\n  constructor(args = {}) {\n    const apiKey = args.apiKey || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\"\n      );\n    }\n    const tenant = args.tenant || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_TENANT;\n    const database = args.database || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_DATABASE;\n    super({\n      host: args.host || \"api.trychroma.com\",\n      port: args.port || 443,\n      ssl: true,\n      tenant,\n      database,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions\n    });\n    this.tenant = tenant;\n    this.database = database;\n  }\n};\nvar AdminCloudClient = class extends AdminClient {\n  /**\n   * Creates a new AdminCloudClient instance for cloud admin operations.\n   * @param args - Admin cloud client configuration options\n   */\n  constructor(args = {}) {\n    const apiKey = args.apiKey || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\"\n      );\n    }\n    super({\n      host: args.host || \"api.trychroma.com\",\n      port: args.port || 443,\n      ssl: true,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions\n    });\n  }\n};\n\n//# sourceMappingURL=chromadb.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hyb21hZGIvZGlzdC9jaHJvbWFkYi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRSxvQ0FBb0MsUUFBUTtBQUNoRztBQUNBLFVBQVU7QUFDVjtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sWUFBWSxTQUFTO0FBQ3pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELE1BQU07QUFDbkU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxNQUFNO0FBQ25FO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQTBDO0FBQ3BFO0FBQ0E7QUFDQSwwQkFBMEIsMkNBQTJDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsTUFBTTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsTUFBTTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsTUFBTTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsTUFBTTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkNBQTJDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxNQUFNO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLE1BQU07QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsTUFBTTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixNQUFNO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixNQUFNO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTtBQUNBLHdCQUF3QiwyQ0FBMkM7QUFDbkU7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBLHdC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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxJQUFJO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxVQUFVLHNEQUFzRCxZQUFZO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJLHVCQUF1QjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLDRDQUE0Qyw2REFBNkQsdUJBQXVCLCtDQUErQztBQUMvTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGlFQUFpRSxjQUFjO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FB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QUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixrQ0FBa0MsNkNBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2Q0FBWTtBQUM5QyxzQ0FBc0MsNkNBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsa0NBQWtDLDZDQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQXVGRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnVnc2NvdXQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvY2hyb21hZGIvZGlzdC9jaHJvbWFkYi5tanM/YjU5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBfX3B1YmxpY0ZpZWxkXG59IGZyb20gXCIuL2NodW5rLU5TU01UWEpKLm1qc1wiO1xuXG4vLyBzcmMvZGVuby50c1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzLkRlbm8gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgY29uc3QgT3JpZ2luYWxSZXF1ZXN0ID0gZ2xvYmFsVGhpcy5SZXF1ZXN0O1xuICBjb25zdCBQYXRjaGVkUmVxdWVzdCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGNsZWFuSW5pdCA9IHsgLi4uaW5pdCB9O1xuICAgICAgaWYgKFwiY2xpZW50XCIgaW4gY2xlYW5Jbml0KSB7XG4gICAgICAgIGRlbGV0ZSBjbGVhbkluaXQuY2xpZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBPcmlnaW5hbFJlcXVlc3QoaW5wdXQsIGNsZWFuSW5pdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JpZ2luYWxSZXF1ZXN0KGlucHV0LCBpbml0KTtcbiAgfTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFBhdGNoZWRSZXF1ZXN0LCBPcmlnaW5hbFJlcXVlc3QpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGF0Y2hlZFJlcXVlc3QsIFwicHJvdG90eXBlXCIsIHtcbiAgICB2YWx1ZTogT3JpZ2luYWxSZXF1ZXN0LnByb3RvdHlwZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGdsb2JhbFRoaXMuUmVxdWVzdCA9IFBhdGNoZWRSZXF1ZXN0O1xufVxuXG4vLyBzcmMvdHlwZXMudHNcbnZhciBiYXNlUmVjb3JkU2V0RmllbGRzID0gW1xuICBcImlkc1wiLFxuICBcImVtYmVkZGluZ3NcIixcbiAgXCJtZXRhZGF0YXNcIixcbiAgXCJkb2N1bWVudHNcIixcbiAgXCJ1cmlzXCJcbl07XG52YXIgcmVjb3JkU2V0RmllbGRzID0gWy4uLmJhc2VSZWNvcmRTZXRGaWVsZHMsIFwiaWRzXCJdO1xudmFyIEluY2x1ZGVFbnVtID0gLyogQF9fUFVSRV9fICovICgoSW5jbHVkZUVudW0yKSA9PiB7XG4gIEluY2x1ZGVFbnVtMltcImRpc3RhbmNlc1wiXSA9IFwiZGlzdGFuY2VzXCI7XG4gIEluY2x1ZGVFbnVtMltcImRvY3VtZW50c1wiXSA9IFwiZG9jdW1lbnRzXCI7XG4gIEluY2x1ZGVFbnVtMltcImVtYmVkZGluZ3NcIl0gPSBcImVtYmVkZGluZ3NcIjtcbiAgSW5jbHVkZUVudW0yW1wibWV0YWRhdGFzXCJdID0gXCJtZXRhZGF0YXNcIjtcbiAgSW5jbHVkZUVudW0yW1widXJpc1wiXSA9IFwidXJpc1wiO1xuICByZXR1cm4gSW5jbHVkZUVudW0yO1xufSkoSW5jbHVkZUVudW0gfHwge30pO1xudmFyIEdldFJlc3VsdCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgR2V0UmVzdWx0IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSByZXN1bHQgZGF0YSBjb250YWluaW5nIGFsbCBmaWVsZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkb2N1bWVudHMsXG4gICAgZW1iZWRkaW5ncyxcbiAgICBpZHMsXG4gICAgaW5jbHVkZSxcbiAgICBtZXRhZGF0YXMsXG4gICAgdXJpc1xuICB9KSB7XG4gICAgdGhpcy5kb2N1bWVudHMgPSBkb2N1bWVudHM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gZW1iZWRkaW5ncztcbiAgICB0aGlzLmlkcyA9IGlkcztcbiAgICB0aGlzLmluY2x1ZGUgPSBpbmNsdWRlO1xuICAgIHRoaXMubWV0YWRhdGFzID0gbWV0YWRhdGFzO1xuICAgIHRoaXMudXJpcyA9IHVyaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSByZXN1bHQgdG8gYSByb3ctYmFzZWQgZm9ybWF0IGZvciBlYXNpZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBpbmNsdWRlIGZpZWxkcyBhbmQgYXJyYXkgb2YgcmVjb3JkIG9iamVjdHNcbiAgICovXG4gIHJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRzLm1hcCgoaWQsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgZG9jdW1lbnQ6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcImRvY3VtZW50c1wiKSA/IHRoaXMuZG9jdW1lbnRzW2luZGV4XSA6IHZvaWQgMCxcbiAgICAgICAgZW1iZWRkaW5nOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJlbWJlZGRpbmdzXCIpID8gdGhpcy5lbWJlZGRpbmdzW2luZGV4XSA6IHZvaWQgMCxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcIm1ldGFkYXRhc1wiKSA/IHRoaXMubWV0YWRhdGFzW2luZGV4XSA6IHZvaWQgMCxcbiAgICAgICAgdXJpOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJ1cmlzXCIpID8gdGhpcy51cmlzW2luZGV4XSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBRdWVyeVJlc3VsdCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUXVlcnlSZXN1bHQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIHF1ZXJ5IHJlc3VsdCBkYXRhIGNvbnRhaW5pbmcgYWxsIGZpZWxkc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGRpc3RhbmNlcyxcbiAgICBkb2N1bWVudHMsXG4gICAgZW1iZWRkaW5ncyxcbiAgICBpZHMsXG4gICAgaW5jbHVkZSxcbiAgICBtZXRhZGF0YXMsXG4gICAgdXJpc1xuICB9KSB7XG4gICAgdGhpcy5kaXN0YW5jZXMgPSBkaXN0YW5jZXM7XG4gICAgdGhpcy5kb2N1bWVudHMgPSBkb2N1bWVudHM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gZW1iZWRkaW5ncztcbiAgICB0aGlzLmlkcyA9IGlkcztcbiAgICB0aGlzLmluY2x1ZGUgPSBpbmNsdWRlO1xuICAgIHRoaXMubWV0YWRhdGFzID0gbWV0YWRhdGFzO1xuICAgIHRoaXMudXJpcyA9IHVyaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBxdWVyeSByZXN1bHQgdG8gYSByb3ctYmFzZWQgZm9ybWF0IGZvciBlYXNpZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBpbmNsdWRlIGZpZWxkcyBhbmQgc3RydWN0dXJlZCBxdWVyeSByZXN1bHRzXG4gICAqL1xuICByb3dzKCkge1xuICAgIGNvbnN0IHF1ZXJpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBxMiA9IDA7IHEyIDwgdGhpcy5pZHMubGVuZ3RoOyBxMisrKSB7XG4gICAgICBjb25zdCByZWNvcmRzID0gdGhpcy5pZHNbcTJdLm1hcCgoaWQsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZG9jdW1lbnQ6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcImRvY3VtZW50c1wiKSA/IHRoaXMuZG9jdW1lbnRzW3EyXVtpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgICAgZW1iZWRkaW5nOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJlbWJlZGRpbmdzXCIpID8gdGhpcy5lbWJlZGRpbmdzW3EyXVtpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgICAgbWV0YWRhdGE6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcIm1ldGFkYXRhc1wiKSA/IHRoaXMubWV0YWRhdGFzW3EyXVtpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgICAgdXJpOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJ1cmlzXCIpID8gdGhpcy51cmlzW3EyXVtpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgICAgZGlzdGFuY2U6IHRoaXMuaW5jbHVkZS5pbmNsdWRlcyhcImRpc3RhbmNlc1wiKSA/IHRoaXMuZGlzdGFuY2VzW3EyXVtpbmRleF0gOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcXVlcmllcy5wdXNoKHJlY29yZHMpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcmllcztcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BoZXktYXBpK2NsaWVudC1mZXRjaEAwLjEwLjBfQGhleS1hcGkrb3BlbmFwaS10c0AwLjY3LjNfdHlwZXNjcmlwdEA1LjguM18vbm9kZV9tb2R1bGVzL0BoZXktYXBpL2NsaWVudC1mZXRjaC9kaXN0L2luZGV4LmpzXG52YXIgQSA9IGFzeW5jICh0LCByKSA9PiB7XG4gIGxldCBlID0gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gYXdhaXQgcih0KSA6IHI7XG4gIGlmIChlKSByZXR1cm4gdC5zY2hlbWUgPT09IFwiYmVhcmVyXCIgPyBgQmVhcmVyICR7ZX1gIDogdC5zY2hlbWUgPT09IFwiYmFzaWNcIiA/IGBCYXNpYyAke2J0b2EoZSl9YCA6IGU7XG59O1xudmFyIFIgPSB7IGJvZHlTZXJpYWxpemVyOiAodCkgPT4gSlNPTi5zdHJpbmdpZnkodCwgKHIsIGUpID0+IHR5cGVvZiBlID09IFwiYmlnaW50XCIgPyBlLnRvU3RyaW5nKCkgOiBlKSB9O1xudmFyIFUgPSAodCkgPT4ge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFwibGFiZWxcIjpcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICByZXR1cm4gXCI7XCI7XG4gICAgY2FzZSBcInNpbXBsZVwiOlxuICAgICAgcmV0dXJuIFwiLFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCImXCI7XG4gIH1cbn07XG52YXIgXyA9ICh0KSA9PiB7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJmb3JtXCI6XG4gICAgICByZXR1cm4gXCIsXCI7XG4gICAgY2FzZSBcInBpcGVEZWxpbWl0ZWRcIjpcbiAgICAgIHJldHVybiBcInxcIjtcbiAgICBjYXNlIFwic3BhY2VEZWxpbWl0ZWRcIjpcbiAgICAgIHJldHVybiBcIiUyMFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCIsXCI7XG4gIH1cbn07XG52YXIgRCA9ICh0KSA9PiB7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJsYWJlbFwiOlxuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIGNhc2UgXCJtYXRyaXhcIjpcbiAgICAgIHJldHVybiBcIjtcIjtcbiAgICBjYXNlIFwic2ltcGxlXCI6XG4gICAgICByZXR1cm4gXCIsXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIiZcIjtcbiAgfVxufTtcbnZhciBPID0gKHsgYWxsb3dSZXNlcnZlZDogdCwgZXhwbG9kZTogciwgbmFtZTogZSwgc3R5bGU6IGEsIHZhbHVlOiBpIH0pID0+IHtcbiAgaWYgKCFyKSB7XG4gICAgbGV0IHMgPSAodCA/IGkgOiBpLm1hcCgobCkgPT4gZW5jb2RlVVJJQ29tcG9uZW50KGwpKSkuam9pbihfKGEpKTtcbiAgICBzd2l0Y2ggKGEpIHtcbiAgICAgIGNhc2UgXCJsYWJlbFwiOlxuICAgICAgICByZXR1cm4gYC4ke3N9YDtcbiAgICAgIGNhc2UgXCJtYXRyaXhcIjpcbiAgICAgICAgcmV0dXJuIGA7JHtlfT0ke3N9YDtcbiAgICAgIGNhc2UgXCJzaW1wbGVcIjpcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYCR7ZX09JHtzfWA7XG4gICAgfVxuICB9XG4gIGxldCBvID0gVShhKSwgbiA9IGkubWFwKChzKSA9PiBhID09PSBcImxhYmVsXCIgfHwgYSA9PT0gXCJzaW1wbGVcIiA/IHQgPyBzIDogZW5jb2RlVVJJQ29tcG9uZW50KHMpIDogeSh7IGFsbG93UmVzZXJ2ZWQ6IHQsIG5hbWU6IGUsIHZhbHVlOiBzIH0pKS5qb2luKG8pO1xuICByZXR1cm4gYSA9PT0gXCJsYWJlbFwiIHx8IGEgPT09IFwibWF0cml4XCIgPyBvICsgbiA6IG47XG59O1xudmFyIHkgPSAoeyBhbGxvd1Jlc2VydmVkOiB0LCBuYW1lOiByLCB2YWx1ZTogZSB9KSA9PiB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiBcIlwiO1xuICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiRGVlcGx5LW5lc3RlZCBhcnJheXMvb2JqZWN0cyBhcmVuXFx1MjAxOXQgc3VwcG9ydGVkLiBQcm92aWRlIHlvdXIgb3duIGBxdWVyeVNlcmlhbGl6ZXIoKWAgdG8gaGFuZGxlIHRoZXNlLlwiKTtcbiAgcmV0dXJuIGAke3J9PSR7dCA/IGUgOiBlbmNvZGVVUklDb21wb25lbnQoZSl9YDtcbn07XG52YXIgcSA9ICh7IGFsbG93UmVzZXJ2ZWQ6IHQsIGV4cGxvZGU6IHIsIG5hbWU6IGUsIHN0eWxlOiBhLCB2YWx1ZTogaSB9KSA9PiB7XG4gIGlmIChpIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIGAke2V9PSR7aS50b0lTT1N0cmluZygpfWA7XG4gIGlmIChhICE9PSBcImRlZXBPYmplY3RcIiAmJiAhcikge1xuICAgIGxldCBzID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMoaSkuZm9yRWFjaCgoW2YsIHVdKSA9PiB7XG4gICAgICBzID0gWy4uLnMsIGYsIHQgPyB1IDogZW5jb2RlVVJJQ29tcG9uZW50KHUpXTtcbiAgICB9KTtcbiAgICBsZXQgbCA9IHMuam9pbihcIixcIik7XG4gICAgc3dpdGNoIChhKSB7XG4gICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICByZXR1cm4gYCR7ZX09JHtsfWA7XG4gICAgICBjYXNlIFwibGFiZWxcIjpcbiAgICAgICAgcmV0dXJuIGAuJHtsfWA7XG4gICAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICAgIHJldHVybiBgOyR7ZX09JHtsfWA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG4gIH1cbiAgbGV0IG8gPSBEKGEpLCBuID0gT2JqZWN0LmVudHJpZXMoaSkubWFwKChbcywgbF0pID0+IHkoeyBhbGxvd1Jlc2VydmVkOiB0LCBuYW1lOiBhID09PSBcImRlZXBPYmplY3RcIiA/IGAke2V9WyR7c31dYCA6IHMsIHZhbHVlOiBsIH0pKS5qb2luKG8pO1xuICByZXR1cm4gYSA9PT0gXCJsYWJlbFwiIHx8IGEgPT09IFwibWF0cml4XCIgPyBvICsgbiA6IG47XG59O1xudmFyIEggPSAvXFx7W157fV0rXFx9L2c7XG52YXIgQiA9ICh7IHBhdGg6IHQsIHVybDogciB9KSA9PiB7XG4gIGxldCBlID0gciwgYSA9IHIubWF0Y2goSCk7XG4gIGlmIChhKSBmb3IgKGxldCBpIG9mIGEpIHtcbiAgICBsZXQgbyA9IGZhbHNlLCBuID0gaS5zdWJzdHJpbmcoMSwgaS5sZW5ndGggLSAxKSwgcyA9IFwic2ltcGxlXCI7XG4gICAgbi5lbmRzV2l0aChcIipcIikgJiYgKG8gPSB0cnVlLCBuID0gbi5zdWJzdHJpbmcoMCwgbi5sZW5ndGggLSAxKSksIG4uc3RhcnRzV2l0aChcIi5cIikgPyAobiA9IG4uc3Vic3RyaW5nKDEpLCBzID0gXCJsYWJlbFwiKSA6IG4uc3RhcnRzV2l0aChcIjtcIikgJiYgKG4gPSBuLnN1YnN0cmluZygxKSwgcyA9IFwibWF0cml4XCIpO1xuICAgIGxldCBsID0gdFtuXTtcbiAgICBpZiAobCA9PSBudWxsKSBjb250aW51ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsKSkge1xuICAgICAgZSA9IGUucmVwbGFjZShpLCBPKHsgZXhwbG9kZTogbywgbmFtZTogbiwgc3R5bGU6IHMsIHZhbHVlOiBsIH0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGwgPT0gXCJvYmplY3RcIikge1xuICAgICAgZSA9IGUucmVwbGFjZShpLCBxKHsgZXhwbG9kZTogbywgbmFtZTogbiwgc3R5bGU6IHMsIHZhbHVlOiBsIH0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocyA9PT0gXCJtYXRyaXhcIikge1xuICAgICAgZSA9IGUucmVwbGFjZShpLCBgOyR7eSh7IG5hbWU6IG4sIHZhbHVlOiBsIH0pfWApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBmID0gZW5jb2RlVVJJQ29tcG9uZW50KHMgPT09IFwibGFiZWxcIiA/IGAuJHtsfWAgOiBsKTtcbiAgICBlID0gZS5yZXBsYWNlKGksIGYpO1xuICB9XG4gIHJldHVybiBlO1xufTtcbnZhciBFID0gKHsgYWxsb3dSZXNlcnZlZDogdCwgYXJyYXk6IHIsIG9iamVjdDogZSB9ID0ge30pID0+IChpKSA9PiB7XG4gIGxldCBvID0gW107XG4gIGlmIChpICYmIHR5cGVvZiBpID09IFwib2JqZWN0XCIpIGZvciAobGV0IG4gaW4gaSkge1xuICAgIGxldCBzID0gaVtuXTtcbiAgICBpZiAocyAhPSBudWxsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzKSkge1xuICAgICAgICBvID0gWy4uLm8sIE8oeyBhbGxvd1Jlc2VydmVkOiB0LCBleHBsb2RlOiB0cnVlLCBuYW1lOiBuLCBzdHlsZTogXCJmb3JtXCIsIHZhbHVlOiBzLCAuLi5yIH0pXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHMgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBvID0gWy4uLm8sIHEoeyBhbGxvd1Jlc2VydmVkOiB0LCBleHBsb2RlOiB0cnVlLCBuYW1lOiBuLCBzdHlsZTogXCJkZWVwT2JqZWN0XCIsIHZhbHVlOiBzLCAuLi5lIH0pXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvID0gWy4uLm8sIHkoeyBhbGxvd1Jlc2VydmVkOiB0LCBuYW1lOiBuLCB2YWx1ZTogcyB9KV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvLmpvaW4oXCImXCIpO1xufTtcbnZhciBQID0gKHQpID0+IHtcbiAgaWYgKCF0KSByZXR1cm4gXCJzdHJlYW1cIjtcbiAgbGV0IHIgPSB0LnNwbGl0KFwiO1wiKVswXT8udHJpbSgpO1xuICBpZiAocikge1xuICAgIGlmIChyLnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9qc29uXCIpIHx8IHIuZW5kc1dpdGgoXCIranNvblwiKSkgcmV0dXJuIFwianNvblwiO1xuICAgIGlmIChyID09PSBcIm11bHRpcGFydC9mb3JtLWRhdGFcIikgcmV0dXJuIFwiZm9ybURhdGFcIjtcbiAgICBpZiAoW1wiYXBwbGljYXRpb24vXCIsIFwiYXVkaW8vXCIsIFwiaW1hZ2UvXCIsIFwidmlkZW8vXCJdLnNvbWUoKGUpID0+IHIuc3RhcnRzV2l0aChlKSkpIHJldHVybiBcImJsb2JcIjtcbiAgICBpZiAoci5zdGFydHNXaXRoKFwidGV4dC9cIikpIHJldHVybiBcInRleHRcIjtcbiAgfVxufTtcbnZhciBJID0gYXN5bmMgKHsgc2VjdXJpdHk6IHQsIC4uLnIgfSkgPT4ge1xuICBmb3IgKGxldCBlIG9mIHQpIHtcbiAgICBsZXQgYSA9IGF3YWl0IEEoZSwgci5hdXRoKTtcbiAgICBpZiAoIWEpIGNvbnRpbnVlO1xuICAgIGxldCBpID0gZS5uYW1lID8/IFwiQXV0aG9yaXphdGlvblwiO1xuICAgIHN3aXRjaCAoZS5pbikge1xuICAgICAgY2FzZSBcInF1ZXJ5XCI6XG4gICAgICAgIHIucXVlcnkgfHwgKHIucXVlcnkgPSB7fSksIHIucXVlcnlbaV0gPSBhO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb29raWVcIjpcbiAgICAgICAgci5oZWFkZXJzLmFwcGVuZChcIkNvb2tpZVwiLCBgJHtpfT0ke2F9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhlYWRlclwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgci5oZWFkZXJzLnNldChpLCBhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcbnZhciBTID0gKHQpID0+IFcoeyBiYXNlVXJsOiB0LmJhc2VVcmwsIHBhdGg6IHQucGF0aCwgcXVlcnk6IHQucXVlcnksIHF1ZXJ5U2VyaWFsaXplcjogdHlwZW9mIHQucXVlcnlTZXJpYWxpemVyID09IFwiZnVuY3Rpb25cIiA/IHQucXVlcnlTZXJpYWxpemVyIDogRSh0LnF1ZXJ5U2VyaWFsaXplciksIHVybDogdC51cmwgfSk7XG52YXIgVyA9ICh7IGJhc2VVcmw6IHQsIHBhdGg6IHIsIHF1ZXJ5OiBlLCBxdWVyeVNlcmlhbGl6ZXI6IGEsIHVybDogaSB9KSA9PiB7XG4gIGxldCBvID0gaS5zdGFydHNXaXRoKFwiL1wiKSA/IGkgOiBgLyR7aX1gLCBuID0gKHQgPz8gXCJcIikgKyBvO1xuICByICYmIChuID0gQih7IHBhdGg6IHIsIHVybDogbiB9KSk7XG4gIGxldCBzID0gZSA/IGEoZSkgOiBcIlwiO1xuICByZXR1cm4gcy5zdGFydHNXaXRoKFwiP1wiKSAmJiAocyA9IHMuc3Vic3RyaW5nKDEpKSwgcyAmJiAobiArPSBgPyR7c31gKSwgbjtcbn07XG52YXIgQyA9ICh0LCByKSA9PiB7XG4gIGxldCBlID0geyAuLi50LCAuLi5yIH07XG4gIHJldHVybiBlLmJhc2VVcmw/LmVuZHNXaXRoKFwiL1wiKSAmJiAoZS5iYXNlVXJsID0gZS5iYXNlVXJsLnN1YnN0cmluZygwLCBlLmJhc2VVcmwubGVuZ3RoIC0gMSkpLCBlLmhlYWRlcnMgPSB4KHQuaGVhZGVycywgci5oZWFkZXJzKSwgZTtcbn07XG52YXIgeCA9ICguLi50KSA9PiB7XG4gIGxldCByID0gbmV3IEhlYWRlcnMoKTtcbiAgZm9yIChsZXQgZSBvZiB0KSB7XG4gICAgaWYgKCFlIHx8IHR5cGVvZiBlICE9IFwib2JqZWN0XCIpIGNvbnRpbnVlO1xuICAgIGxldCBhID0gZSBpbnN0YW5jZW9mIEhlYWRlcnMgPyBlLmVudHJpZXMoKSA6IE9iamVjdC5lbnRyaWVzKGUpO1xuICAgIGZvciAobGV0IFtpLCBvXSBvZiBhKSBpZiAobyA9PT0gbnVsbCkgci5kZWxldGUoaSk7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSkgZm9yIChsZXQgbiBvZiBvKSByLmFwcGVuZChpLCBuKTtcbiAgICBlbHNlIG8gIT09IHZvaWQgMCAmJiByLnNldChpLCB0eXBlb2YgbyA9PSBcIm9iamVjdFwiID8gSlNPTi5zdHJpbmdpZnkobykgOiBvKTtcbiAgfVxuICByZXR1cm4gcjtcbn07XG52YXIgaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9mbnNcIik7XG4gICAgdGhpcy5fZm5zID0gW107XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fZm5zID0gW107XG4gIH1cbiAgZXhpc3RzKHIpIHtcbiAgICByZXR1cm4gdGhpcy5fZm5zLmluZGV4T2YocikgIT09IC0xO1xuICB9XG4gIGVqZWN0KHIpIHtcbiAgICBsZXQgZSA9IHRoaXMuX2Zucy5pbmRleE9mKHIpO1xuICAgIGUgIT09IC0xICYmICh0aGlzLl9mbnMgPSBbLi4udGhpcy5fZm5zLnNsaWNlKDAsIGUpLCAuLi50aGlzLl9mbnMuc2xpY2UoZSArIDEpXSk7XG4gIH1cbiAgdXNlKHIpIHtcbiAgICB0aGlzLl9mbnMgPSBbLi4udGhpcy5fZm5zLCByXTtcbiAgfVxufTtcbnZhciBUID0gKCkgPT4gKHsgZXJyb3I6IG5ldyBoKCksIHJlcXVlc3Q6IG5ldyBoKCksIHJlc3BvbnNlOiBuZXcgaCgpIH0pO1xudmFyIE4gPSBFKHsgYWxsb3dSZXNlcnZlZDogZmFsc2UsIGFycmF5OiB7IGV4cGxvZGU6IHRydWUsIHN0eWxlOiBcImZvcm1cIiB9LCBvYmplY3Q6IHsgZXhwbG9kZTogdHJ1ZSwgc3R5bGU6IFwiZGVlcE9iamVjdFwiIH0gfSk7XG52YXIgUSA9IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbnZhciB3ID0gKHQgPSB7fSkgPT4gKHsgLi4uUiwgaGVhZGVyczogUSwgcGFyc2VBczogXCJhdXRvXCIsIHF1ZXJ5U2VyaWFsaXplcjogTiwgLi4udCB9KTtcbnZhciBKID0gKHQgPSB7fSkgPT4ge1xuICBsZXQgciA9IEModygpLCB0KSwgZSA9ICgpID0+ICh7IC4uLnIgfSksIGEgPSAobikgPT4gKHIgPSBDKHIsIG4pLCBlKCkpLCBpID0gVCgpLCBvID0gYXN5bmMgKG4pID0+IHtcbiAgICBsZXQgcyA9IHsgLi4uciwgLi4ubiwgZmV0Y2g6IG4uZmV0Y2ggPz8gci5mZXRjaCA/PyBnbG9iYWxUaGlzLmZldGNoLCBoZWFkZXJzOiB4KHIuaGVhZGVycywgbi5oZWFkZXJzKSB9O1xuICAgIHMuc2VjdXJpdHkgJiYgYXdhaXQgSSh7IC4uLnMsIHNlY3VyaXR5OiBzLnNlY3VyaXR5IH0pLCBzLmJvZHkgJiYgcy5ib2R5U2VyaWFsaXplciAmJiAocy5ib2R5ID0gcy5ib2R5U2VyaWFsaXplcihzLmJvZHkpKSwgKHMuYm9keSA9PT0gdm9pZCAwIHx8IHMuYm9keSA9PT0gXCJcIikgJiYgcy5oZWFkZXJzLmRlbGV0ZShcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBsZXQgbCA9IFMocyksIGYgPSB7IHJlZGlyZWN0OiBcImZvbGxvd1wiLCAuLi5zIH0sIHUgPSBuZXcgUmVxdWVzdChsLCBmKTtcbiAgICBmb3IgKGxldCBwIG9mIGkucmVxdWVzdC5fZm5zKSB1ID0gYXdhaXQgcCh1LCBzKTtcbiAgICBsZXQgayA9IHMuZmV0Y2gsIGMgPSBhd2FpdCBrKHUpO1xuICAgIGZvciAobGV0IHAgb2YgaS5yZXNwb25zZS5fZm5zKSBjID0gYXdhaXQgcChjLCB1LCBzKTtcbiAgICBsZXQgbSA9IHsgcmVxdWVzdDogdSwgcmVzcG9uc2U6IGMgfTtcbiAgICBpZiAoYy5vaykge1xuICAgICAgaWYgKGMuc3RhdHVzID09PSAyMDQgfHwgYy5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpID09PSBcIjBcIikgcmV0dXJuIHsgZGF0YToge30sIC4uLm0gfTtcbiAgICAgIGxldCBwID0gKHMucGFyc2VBcyA9PT0gXCJhdXRvXCIgPyBQKGMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikpIDogcy5wYXJzZUFzKSA/PyBcImpzb25cIjtcbiAgICAgIGlmIChwID09PSBcInN0cmVhbVwiKSByZXR1cm4geyBkYXRhOiBjLmJvZHksIC4uLm0gfTtcbiAgICAgIGxldCBiID0gYXdhaXQgY1twXSgpO1xuICAgICAgcmV0dXJuIHAgPT09IFwianNvblwiICYmIChzLnJlc3BvbnNlVmFsaWRhdG9yICYmIGF3YWl0IHMucmVzcG9uc2VWYWxpZGF0b3IoYiksIHMucmVzcG9uc2VUcmFuc2Zvcm1lciAmJiAoYiA9IGF3YWl0IHMucmVzcG9uc2VUcmFuc2Zvcm1lcihiKSkpLCB7IGRhdGE6IGIsIC4uLm0gfTtcbiAgICB9XG4gICAgbGV0IGcgPSBhd2FpdCBjLnRleHQoKTtcbiAgICB0cnkge1xuICAgICAgZyA9IEpTT04ucGFyc2UoZyk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIGxldCBkID0gZztcbiAgICBmb3IgKGxldCBwIG9mIGkuZXJyb3IuX2ZucykgZCA9IGF3YWl0IHAoZywgYywgdSwgcyk7XG4gICAgaWYgKGQgPSBkIHx8IHt9LCBzLnRocm93T25FcnJvcikgdGhyb3cgZDtcbiAgICByZXR1cm4geyBlcnJvcjogZCwgLi4ubSB9O1xuICB9O1xuICByZXR1cm4geyBidWlsZFVybDogUywgY29ubmVjdDogKG4pID0+IG8oeyAuLi5uLCBtZXRob2Q6IFwiQ09OTkVDVFwiIH0pLCBkZWxldGU6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIkRFTEVURVwiIH0pLCBnZXQ6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIkdFVFwiIH0pLCBnZXRDb25maWc6IGUsIGhlYWQ6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIkhFQURcIiB9KSwgaW50ZXJjZXB0b3JzOiBpLCBvcHRpb25zOiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJPUFRJT05TXCIgfSksIHBhdGNoOiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJQQVRDSFwiIH0pLCBwb3N0OiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJQT1NUXCIgfSksIHB1dDogKG4pID0+IG8oeyAuLi5uLCBtZXRob2Q6IFwiUFVUXCIgfSksIHJlcXVlc3Q6IG8sIHNldENvbmZpZzogYSwgdHJhY2U6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIlRSQUNFXCIgfSkgfTtcbn07XG5cbi8vIHNyYy9hcGkvY2xpZW50Lmdlbi50c1xudmFyIGNsaWVudCA9IEoodyh7XG4gIGJhc2VVcmw6IFwiaHR0cDovL2xvY2FsaG9zdDo4MDAwXCIsXG4gIHRocm93T25FcnJvcjogdHJ1ZVxufSkpO1xuXG4vLyBzcmMvYXBpL3Nkay5nZW4udHNcbnZhciBEZWZhdWx0U2VydmljZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCB1c2VyJ3MgaWRlbnRpdHksIHRlbmFudCwgYW5kIGRhdGFiYXNlcy5cbiAgICovXG4gIHN0YXRpYyBnZXRVc2VySWRlbnRpdHkob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL2F1dGgvaWRlbnRpdHlcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGEgY29sbGVjdGlvbiBieSBDaHJvbWEgUmVzb3VyY2UgTmFtZS5cbiAgICovXG4gIHN0YXRpYyBnZXRDb2xsZWN0aW9uQnlDcm4ob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvY29sbGVjdGlvbnMve2Nybn1cIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGVhbHRoIGNoZWNrIGVuZHBvaW50IHRoYXQgcmV0dXJucyAyMDAgaWYgdGhlIHNlcnZlciBhbmQgZXhlY3V0b3IgYXJlIHJlYWR5XG4gICAqL1xuICBzdGF0aWMgaGVhbHRoY2hlY2sob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL2hlYWx0aGNoZWNrXCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlYXJ0YmVhdCBlbmRwb2ludCB0aGF0IHJldHVybnMgYSBuYW5vc2Vjb25kIHRpbWVzdGFtcCBvZiB0aGUgY3VycmVudCB0aW1lLlxuICAgKi9cbiAgc3RhdGljIGhlYXJ0YmVhdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvaGVhcnRiZWF0XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByZS1mbGlnaHQgY2hlY2tzIGVuZHBvaW50IHJlcG9ydGluZyBiYXNpYyByZWFkaW5lc3MgaW5mby5cbiAgICovXG4gIHN0YXRpYyBwcmVGbGlnaHRDaGVja3Mob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3ByZS1mbGlnaHQtY2hlY2tzXCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IGVuZHBvaW50IGFsbG93aW5nIGF1dGhvcml6ZWQgdXNlcnMgdG8gcmVzZXQgdGhlIGRhdGFiYXNlLlxuICAgKi9cbiAgc3RhdGljIHJlc2V0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvcmVzZXRcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0ZW5hbnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVGVuYW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4aXN0aW5nIHRlbmFudCBieSBuYW1lLlxuICAgKi9cbiAgc3RhdGljIGdldFRlbmFudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnRfbmFtZX1cIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhbiBleGlzdGluZyB0ZW5hbnQgYnkgbmFtZS5cbiAgICovXG4gIHN0YXRpYyB1cGRhdGVUZW5hbnQob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wYXRjaCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnRfbmFtZX1cIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBkYXRhYmFzZXMgZm9yIGEgZ2l2ZW4gdGVuYW50LlxuICAgKi9cbiAgc3RhdGljIGxpc3REYXRhYmFzZXMob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXNcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBkYXRhYmFzZSBmb3IgYSBnaXZlbiB0ZW5hbnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRGF0YWJhc2Uob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgc3BlY2lmaWMgZGF0YWJhc2UuXG4gICAqL1xuICBzdGF0aWMgZGVsZXRlRGF0YWJhc2Uob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5kZWxldGUoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfVwiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBzcGVjaWZpYyBkYXRhYmFzZSBieSBuYW1lLlxuICAgKi9cbiAgc3RhdGljIGdldERhdGFiYXNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX1cIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIGNvbGxlY3Rpb25zIGluIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UuXG4gICAqL1xuICBzdGF0aWMgbGlzdENvbGxlY3Rpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnNcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb2xsZWN0aW9uIHVuZGVyIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQ29sbGVjdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9uc1wiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGNvbGxlY3Rpb24gaW4gYSBnaXZlbiBkYXRhYmFzZS5cbiAgICovXG4gIHN0YXRpYyBkZWxldGVDb2xsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZGVsZXRlKHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGNvbGxlY3Rpb24gYnkgSUQgb3IgbmFtZS5cbiAgICovXG4gIHN0YXRpYyBnZXRDb2xsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgY29sbGVjdGlvbidzIG5hbWUgb3IgbWV0YWRhdGEuXG4gICAqL1xuICBzdGF0aWMgdXBkYXRlQ29sbGVjdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnB1dCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfVwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyByZWNvcmRzIHRvIGEgY29sbGVjdGlvbi5cbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uQWRkKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS9hZGRcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaCBhIGZ1bmN0aW9uXG4gICAqL1xuICBzdGF0aWMgZGV0YWNoRnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9L2F0dGFjaGVkX2Z1bmN0aW9ucy97bmFtZX0vZGV0YWNoXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIGEgY29sbGVjdGlvbi5cbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uQ291bnQob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vY291bnRcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyByZWNvcmRzIGluIGEgY29sbGVjdGlvbi4gQ2FuIGZpbHRlciBieSBJRHMgb3IgbWV0YWRhdGEuXG4gICAqL1xuICBzdGF0aWMgY29sbGVjdGlvbkRlbGV0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vZGVsZXRlXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGb3JrcyBhbiBleGlzdGluZyBjb2xsZWN0aW9uLlxuICAgKi9cbiAgc3RhdGljIGZvcmtDb2xsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS9mb3JrXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2ggYSBmdW5jdGlvbiB0byBhIGNvbGxlY3Rpb25cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hGdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vZnVuY3Rpb25zL2F0dGFjaFwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFuIGF0dGFjaGVkIGZ1bmN0aW9uIGJ5IG5hbWVcbiAgICovXG4gIHN0YXRpYyBnZXRBdHRhY2hlZEZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9L2Z1bmN0aW9ucy97ZnVuY3Rpb25fbmFtZX1cIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHJlY29yZHMgZnJvbSBhIGNvbGxlY3Rpb24gYnkgSUQgb3IgbWV0YWRhdGEgZmlsdGVyLlxuICAgKi9cbiAgc3RhdGljIGNvbGxlY3Rpb25HZXQob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9L2dldFwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUXVlcnkgYSBjb2xsZWN0aW9uIGluIGEgdmFyaWV0eSBvZiB3YXlzLCBpbmNsdWRpbmcgdmVjdG9yIHNlYXJjaCwgbWV0YWRhdGEgZmlsdGVyaW5nLCBhbmQgZnVsbC10ZXh0IHNlYXJjaFxuICAgKi9cbiAgc3RhdGljIGNvbGxlY3Rpb25RdWVyeShvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vcXVlcnlcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaCByZWNvcmRzIGZyb20gYSBjb2xsZWN0aW9uIHdpdGggaHlicmlkIGNyaXRlcmlhcy5cbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uU2VhcmNoKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS9zZWFyY2hcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgcmVjb3JkcyBpbiBhIGNvbGxlY3Rpb24gYnkgSUQuXG4gICAqL1xuICBzdGF0aWMgY29sbGVjdGlvblVwZGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vdXBkYXRlXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcHNlcnRzIHJlY29yZHMgaW4gYSBjb2xsZWN0aW9uIChjcmVhdGUgaWYgbm90IGV4aXN0cywgb3RoZXJ3aXNlIHVwZGF0ZSkuXG4gICAqL1xuICBzdGF0aWMgY29sbGVjdGlvblVwc2VydChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vdXBzZXJ0XCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHRvdGFsIG51bWJlciBvZiBjb2xsZWN0aW9ucyBpbiBhIGdpdmVuIGRhdGFiYXNlLlxuICAgKi9cbiAgc3RhdGljIGNvdW50Q29sbGVjdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9uc19jb3VudFwiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBzdGF0aWMgdmVyc2lvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdmVyc2lvblwiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3JzLnRzXG52YXIgQ2hyb21hRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobmFtZSwgbWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxufTtcbnZhciBDaHJvbWFDb25uZWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFDb25uZWN0aW9uRXJyb3JcIjtcbiAgfVxufTtcbnZhciBDaHJvbWFTZXJ2ZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYVNlcnZlckVycm9yXCI7XG4gIH1cbn07XG52YXIgQ2hyb21hQ2xpZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFDbGllbnRFcnJvclwiO1xuICB9XG59O1xudmFyIENocm9tYVVuYXV0aG9yaXplZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hQXV0aEVycm9yXCI7XG4gIH1cbn07XG52YXIgQ2hyb21hRm9yYmlkZGVuRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFGb3JiaWRkZW5FcnJvclwiO1xuICB9XG59O1xudmFyIENocm9tYU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFOb3RGb3VuZEVycm9yXCI7XG4gIH1cbn07XG52YXIgQ2hyb21hVmFsdWVFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYVZhbHVlRXJyb3JcIjtcbiAgfVxufTtcbnZhciBJbnZhbGlkQ29sbGVjdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZENvbGxlY3Rpb25FcnJvclwiO1xuICB9XG59O1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbiAgfVxufTtcbnZhciBDaHJvbWFVbmlxdWVFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYVVuaXF1ZUVycm9yXCI7XG4gIH1cbn07XG52YXIgQ2hyb21hUXVvdGFFeGNlZWRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hUXVvdGFFeGNlZWRlZEVycm9yXCI7XG4gIH1cbn07XG52YXIgQ2hyb21hUmF0ZUxpbWl0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFSYXRlTGltaXRFcnJvclwiO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JCeVR5cGUodHlwZSwgbWVzc2FnZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiSW52YWxpZENvbGxlY3Rpb25cIjpcbiAgICAgIHJldHVybiBuZXcgSW52YWxpZENvbGxlY3Rpb25FcnJvcihtZXNzYWdlKTtcbiAgICBjYXNlIFwiSW52YWxpZEFyZ3VtZW50RXJyb3JcIjpcbiAgICAgIHJldHVybiBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IobWVzc2FnZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgREVGQVVMVF9URU5BTlQgPSBcImRlZmF1bHRfdGVuYW50XCI7XG52YXIgREVGQVVMVF9EQVRBQkFTRSA9IFwiZGVmYXVsdF9kYXRhYmFzZVwiO1xudmFyIGRlZmF1bHRBZG1pbkNsaWVudEFyZ3MgPSB7XG4gIGhvc3Q6IFwibG9jYWxob3N0XCIsXG4gIHBvcnQ6IDhlMyxcbiAgc3NsOiBmYWxzZVxufTtcbnZhciBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncyA9IHtcbiAgLi4uZGVmYXVsdEFkbWluQ2xpZW50QXJncyxcbiAgdGVuYW50OiBERUZBVUxUX1RFTkFOVCxcbiAgZGF0YWJhc2U6IERFRkFVTFRfREFUQUJBU0Vcbn07XG52YXIgbm9ybWFsaXplTWV0aG9kID0gKG1ldGhvZCkgPT4ge1xuICBpZiAobWV0aG9kKSB7XG4gICAgc3dpdGNoIChtZXRob2QudG9VcHBlckNhc2UoKSkge1xuICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICByZXR1cm4gXCJHRVRcIjtcbiAgICAgIGNhc2UgXCJQT1NUXCI6XG4gICAgICAgIHJldHVybiBcIlBPU1RcIjtcbiAgICAgIGNhc2UgXCJQVVRcIjpcbiAgICAgICAgcmV0dXJuIFwiUFVUXCI7XG4gICAgICBjYXNlIFwiREVMRVRFXCI6XG4gICAgICAgIHJldHVybiBcIkRFTEVURVwiO1xuICAgICAgY2FzZSBcIkhFQURcIjpcbiAgICAgICAgcmV0dXJuIFwiSEVBRFwiO1xuICAgICAgY2FzZSBcIkNPTk5FQ1RcIjpcbiAgICAgICAgcmV0dXJuIFwiQ09OTkVDVFwiO1xuICAgICAgY2FzZSBcIk9QVElPTlNcIjpcbiAgICAgICAgcmV0dXJuIFwiT1BUSU9OU1wiO1xuICAgICAgY2FzZSBcIlBBVENIXCI6XG4gICAgICAgIHJldHVybiBcIlBBVENIXCI7XG4gICAgICBjYXNlIFwiVFJBQ0VcIjpcbiAgICAgICAgcmV0dXJuIFwiVFJBQ0VcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59O1xudmFyIHZhbGlkYXRlUmVjb3JkU2V0TGVuZ3RoQ29uc2lzdGVuY3kgPSAocmVjb3JkU2V0KSA9PiB7XG4gIGNvbnN0IGxlbmd0aHMgPSBPYmplY3QuZW50cmllcyhyZWNvcmRTZXQpLmZpbHRlcihcbiAgICAoW2ZpZWxkLCB2YWx1ZV0pID0+IHJlY29yZFNldEZpZWxkcy5pbmNsdWRlcyhmaWVsZCkgJiYgdmFsdWUgIT09IHZvaWQgMFxuICApLm1hcCgoW2ZpZWxkLCB2YWx1ZV0pID0+IFtmaWVsZCwgdmFsdWUubGVuZ3RoXSk7XG4gIGlmIChsZW5ndGhzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEF0IGxlYXN0IG9uZSBvZiAke3JlY29yZFNldEZpZWxkcy5qb2luKFwiLCBcIil9IG11c3QgYmUgcHJvdmlkZWRgXG4gICAgKTtcbiAgfVxuICBjb25zdCB6ZXJvTGVuZ3RoID0gbGVuZ3Rocy5maWx0ZXIoKFtfMiwgbGVuZ3RoXSkgPT4gbGVuZ3RoID09PSAwKS5tYXAoKFtmaWVsZCwgXzJdKSA9PiBmaWVsZCk7XG4gIGlmICh6ZXJvTGVuZ3RoLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBOb24tZW1wdHkgbGlzdHMgYXJlIHJlcXVpcmVkIGZvciAke3plcm9MZW5ndGguam9pbihcIiwgXCIpfWBcbiAgICApO1xuICB9XG4gIGlmIChuZXcgU2V0KGxlbmd0aHMubWFwKChbXzIsIGxlbmd0aF0pID0+IGxlbmd0aCkpLnNpemUgPiAxKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgVW5lcXVhbCBsZW5ndGhzIGZvciBmaWVsZHMgJHtsZW5ndGhzLm1hcCgoW2ZpZWxkLCBfMl0pID0+IGZpZWxkKS5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVFbWJlZGRpbmdzID0gKHtcbiAgZW1iZWRkaW5ncyxcbiAgZmllbGROYW1lID0gXCJlbWJlZGRpbmdzXCJcbn0pID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVtYmVkZGluZ3MpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgJyR7ZmllbGROYW1lfScgdG8gYmUgYW4gYXJyYXksIGJ1dCBnb3QgJHt0eXBlb2YgZW1iZWRkaW5nc31gXG4gICAgKTtcbiAgfVxuICBpZiAoZW1iZWRkaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgZW1iZWRkaW5ncyB0byBiZSBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBpdGVtXCJcbiAgICApO1xuICB9XG4gIGlmICghZW1iZWRkaW5ncy5maWx0ZXIoKGUpID0+IGUuZXZlcnkoKG4pID0+IHR5cGVvZiBuID09PSBcIm51bWJlclwiKSkpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgZWFjaCBlbWJlZGRpbmcgdG8gYmUgYW4gYXJyYXkgb2YgbnVtYmVyc1wiXG4gICAgKTtcbiAgfVxuICBlbWJlZGRpbmdzLmZvckVhY2goKGVtYmVkZGluZywgaSkgPT4ge1xuICAgIGlmIChlbWJlZGRpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIGVhY2ggZW1iZWRkaW5nIHRvIGJlIGEgbm9uLWVtcHR5IGFycmF5IG9mIG51bWJlcnMsIGJ1dCBnb3QgYW4gZW1wdHkgYXJyYXkgYXQgaW5kZXggJHtpfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgdmFsaWRhdGVEb2N1bWVudHMgPSAoe1xuICBkb2N1bWVudHMsXG4gIG51bGxhYmxlID0gZmFsc2UsXG4gIGZpZWxkTmFtZSA9IFwiZG9jdW1lbnRzXCJcbn0pID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRvY3VtZW50cykpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBFeHBlY3RlZCAnJHtmaWVsZE5hbWV9JyB0byBiZSBhbiBhcnJheSwgYnV0IGdvdCAke3R5cGVvZiBkb2N1bWVudHN9YFxuICAgICk7XG4gIH1cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBFeHBlY3RlZCAnJHtmaWVsZE5hbWV9JyB0byBiZSBhIG5vbi1lbXB0eSBsaXN0YFxuICAgICk7XG4gIH1cbiAgZG9jdW1lbnRzLmZvckVhY2goKGRvY3VtZW50KSA9PiB7XG4gICAgaWYgKCFudWxsYWJsZSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwic3RyaW5nXCIgJiYgIWRvY3VtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIGVhY2ggZG9jdW1lbnQgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHt0eXBlb2YgZG9jdW1lbnR9YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciB2YWxpZGF0ZUlEcyA9IChpZHMpID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkcykpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBFeHBlY3RlZCAnaWRzJyB0byBiZSBhbiBhcnJheSwgYnV0IGdvdCAke3R5cGVvZiBpZHN9YFxuICAgICk7XG4gIH1cbiAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcIkV4cGVjdGVkICdpZHMnIHRvIGJlIGEgbm9uLWVtcHR5IGxpc3RcIik7XG4gIH1cbiAgY29uc3Qgbm9uU3RyaW5ncyA9IGlkcy5tYXAoKGlkLCBpKSA9PiBbaWQsIGldKS5maWx0ZXIoKFtpZCwgXzJdKSA9PiB0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpLm1hcCgoW18yLCBpXSkgPT4gaSk7XG4gIGlmIChub25TdHJpbmdzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBGb3VuZCBub24tc3RyaW5nIElEcyBhdCAke25vblN0cmluZ3Muam9pbihcIiwgXCIpfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBkdXBsaWNhdGVzID0gaWRzLmZpbHRlcigoaWQpID0+IHtcbiAgICBpZiAoc2Vlbi5oYXMoaWQpKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIHNlZW4uYWRkKGlkKTtcbiAgfSk7XG4gIGxldCBtZXNzYWdlID0gXCJFeHBlY3RlZCBJRHMgdG8gYmUgdW5pcXVlLCBidXQgZm91bmQgZHVwbGljYXRlcyBvZlwiO1xuICBpZiAoZHVwbGljYXRlcy5sZW5ndGggPiAwICYmIGR1cGxpY2F0ZXMubGVuZ3RoIDw9IDUpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihgJHttZXNzYWdlfSAke2R1cGxpY2F0ZXMuam9pbihcIiwgXCIpfWApO1xuICB9XG4gIGlmIChkdXBsaWNhdGVzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGAke21lc3NhZ2V9ICR7ZHVwbGljYXRlcy5zbGljZSgwLCA1KS5qb2luKFwiLCBcIil9LCAuLi4sICR7ZHVwbGljYXRlcy5zbGljZShkdXBsaWNhdGVzLmxlbmd0aCAtIDUpLmpvaW4oXCIsIFwiKX1gXG4gICAgKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZVNwYXJzZVZlY3RvciA9ICh2KSA9PiB7XG4gIGlmICh0eXBlb2YgdiAhPT0gXCJvYmplY3RcIiB8fCB2ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhbmRpZGF0ZSA9IHY7XG4gIGNvbnN0IGluZGljZXMgPSBjYW5kaWRhdGUuaW5kaWNlcztcbiAgY29uc3QgdmFsdWVzID0gY2FuZGlkYXRlLnZhbHVlcztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGluZGljZXMpIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGluZGljZXMuZXZlcnkoKGUpID0+IHR5cGVvZiBlID09PSBcIm51bWJlclwiKSAmJiB2YWx1ZXMuZXZlcnkoKGUpID0+IHR5cGVvZiBlID09PSBcIm51bWJlclwiKTtcbn07XG52YXIgdmFsaWRhdGVNZXRhZGF0YSA9IChtZXRhZGF0YSkgPT4ge1xuICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyhtZXRhZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXCJFeHBlY3RlZCBtZXRhZGF0YSB0byBiZSBub24tZW1wdHlcIik7XG4gIH1cbiAgaWYgKCFPYmplY3QudmFsdWVzKG1ldGFkYXRhKS5ldmVyeShcbiAgICAodikgPT4gdiA9PT0gbnVsbCB8fCB2ID09PSB2b2lkIDAgfHwgdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiIHx8IHZhbGlkYXRlU3BhcnNlVmVjdG9yKHYpXG4gICkpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgbWV0YWRhdGEgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgU3BhcnNlVmVjdG9yLCBvciBudWxsYWJsZVwiXG4gICAgKTtcbiAgfVxufTtcbnZhciBTUEFSU0VfVkVDVE9SX1RZUEUgPSBcInNwYXJzZV92ZWN0b3JcIjtcbnZhciB0b1NlcmlhbGl6ZWRTcGFyc2VWZWN0b3IgPSAodmVjdG9yKSA9PiAoe1xuICBcIiN0eXBlXCI6IFNQQVJTRV9WRUNUT1JfVFlQRSxcbiAgaW5kaWNlczogdmVjdG9yLmluZGljZXMsXG4gIHZhbHVlczogdmVjdG9yLnZhbHVlc1xufSk7XG52YXIgc2VyaWFsaXplTWV0YWRhdGEgPSAobWV0YWRhdGEpID0+IHtcbiAgaWYgKG1ldGFkYXRhID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChtZXRhZGF0YSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBPYmplY3QuZW50cmllcyhtZXRhZGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbGlkYXRlU3BhcnNlVmVjdG9yKHZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB0b1NlcmlhbGl6ZWRTcGFyc2VWZWN0b3IodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlID8/IG51bGw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgc2VyaWFsaXplTWV0YWRhdGFzID0gKG1ldGFkYXRhcykgPT4ge1xuICBpZiAobWV0YWRhdGFzID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChtZXRhZGF0YXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbWV0YWRhdGFzLm1hcCgobWV0YWRhdGEpID0+IHNlcmlhbGl6ZU1ldGFkYXRhKG1ldGFkYXRhKSA/PyBudWxsKTtcbn07XG52YXIgaXNTZXJpYWxpemVkU3BhcnNlVmVjdG9yID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gIGlmIChjYW5kaWRhdGVbXCIjdHlwZVwiXSAhPT0gU1BBUlNFX1ZFQ1RPUl9UWVBFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZGF0ZVNwYXJzZVZlY3RvcihjYW5kaWRhdGUpO1xufTtcbnZhciBkZXNlcmlhbGl6ZU1ldGFkYXRhVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgaWYgKGlzU2VyaWFsaXplZFNwYXJzZVZlY3Rvcih2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kaWNlczogdmFsdWUuaW5kaWNlcyxcbiAgICAgIHZhbHVlczogdmFsdWUudmFsdWVzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIGRlc2VyaWFsaXplTWV0YWRhdGEgPSAobWV0YWRhdGEpID0+IHtcbiAgaWYgKG1ldGFkYXRhID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChtZXRhZGF0YSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBPYmplY3QuZW50cmllcyhtZXRhZGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgcmVzdWx0W2tleV0gPSBkZXNlcmlhbGl6ZU1ldGFkYXRhVmFsdWUodmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgZGVzZXJpYWxpemVNZXRhZGF0YXMgPSAobWV0YWRhdGFzKSA9PiB7XG4gIGlmIChtZXRhZGF0YXMgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKG1ldGFkYXRhcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBtZXRhZGF0YXMubWFwKChtZXRhZGF0YSkgPT4gZGVzZXJpYWxpemVNZXRhZGF0YShtZXRhZGF0YSkgPz8gbnVsbCk7XG59O1xudmFyIGRlc2VyaWFsaXplTWV0YWRhdGFNYXRyaXggPSAobWV0YWRhdGFzKSA9PiB7XG4gIGlmIChtZXRhZGF0YXMgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKG1ldGFkYXRhcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBtZXRhZGF0YXMubWFwKChtZXRhZGF0YUFycmF5KSA9PiB7XG4gICAgaWYgKG1ldGFkYXRhQXJyYXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZXNlcmlhbGl6ZWQgPSBkZXNlcmlhbGl6ZU1ldGFkYXRhcyhtZXRhZGF0YUFycmF5KTtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVkID8/IFtdO1xuICB9KTtcbn07XG52YXIgdmFsaWRhdGVNZXRhZGF0YXMgPSAobWV0YWRhdGFzKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtZXRhZGF0YXMpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgbWV0YWRhdGFzIHRvIGJlIGFuIGFycmF5LCBidXQgZ290ICR7dHlwZW9mIG1ldGFkYXRhc31gXG4gICAgKTtcbiAgfVxuICBtZXRhZGF0YXMuZm9yRWFjaCgobWV0YWRhdGEpID0+IHZhbGlkYXRlTWV0YWRhdGEobWV0YWRhdGEpKTtcbn07XG52YXIgdmFsaWRhdGVCYXNlUmVjb3JkU2V0ID0gKHtcbiAgcmVjb3JkU2V0LFxuICB1cGRhdGUgPSBmYWxzZSxcbiAgZW1iZWRkaW5nc0ZpZWxkID0gXCJlbWJlZGRpbmdzXCIsXG4gIGRvY3VtZW50c0ZpZWxkID0gXCJkb2N1bWVudHNcIlxufSkgPT4ge1xuICBpZiAoIXJlY29yZFNldC5lbWJlZGRpbmdzICYmICFyZWNvcmRTZXQuZG9jdW1lbnRzICYmICF1cGRhdGUpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBBdCBsZWFzdCBvbmUgb2YgJyR7ZW1iZWRkaW5nc0ZpZWxkfScgYW5kICcke2RvY3VtZW50c0ZpZWxkfScgbXVzdCBiZSBwcm92aWRlZGBcbiAgICApO1xuICB9XG4gIGlmIChyZWNvcmRTZXQuZW1iZWRkaW5ncykge1xuICAgIHZhbGlkYXRlRW1iZWRkaW5ncyh7XG4gICAgICBlbWJlZGRpbmdzOiByZWNvcmRTZXQuZW1iZWRkaW5ncyxcbiAgICAgIGZpZWxkTmFtZTogZW1iZWRkaW5nc0ZpZWxkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlY29yZFNldC5kb2N1bWVudHMpIHtcbiAgICB2YWxpZGF0ZURvY3VtZW50cyh7XG4gICAgICBkb2N1bWVudHM6IHJlY29yZFNldC5kb2N1bWVudHMsXG4gICAgICBmaWVsZE5hbWU6IGRvY3VtZW50c0ZpZWxkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlY29yZFNldC5tZXRhZGF0YXMpIHtcbiAgICB2YWxpZGF0ZU1ldGFkYXRhcyhyZWNvcmRTZXQubWV0YWRhdGFzKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZU1heEJhdGNoU2l6ZSA9IChyZWNvcmRTZXRMZW5ndGgsIG1heEJhdGNoU2l6ZSkgPT4ge1xuICBpZiAocmVjb3JkU2V0TGVuZ3RoID4gbWF4QmF0Y2hTaXplKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgUmVjb3JkIHNldCBsZW5ndGggJHtyZWNvcmRTZXRMZW5ndGh9IGV4Y2VlZHMgbWF4IGJhdGNoIHNpemUgJHttYXhCYXRjaFNpemV9YFxuICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVXaGVyZSA9ICh3aGVyZSkgPT4ge1xuICBpZiAodHlwZW9mIHdoZXJlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXCJFeHBlY3RlZCB3aGVyZSB0byBiZSBhIG5vbi1lbXB0eSBvYmplY3RcIik7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHdoZXJlKS5sZW5ndGggIT0gMSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICd3aGVyZScgdG8gaGF2ZSBleGFjdGx5IG9uZSBvcGVyYXRvciwgYnV0IGdvdCAke09iamVjdC5rZXlzKHdoZXJlKS5sZW5ndGh9YFxuICAgICk7XG4gIH1cbiAgT2JqZWN0LmVudHJpZXMod2hlcmUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChrZXkgIT09IFwiJGFuZFwiICYmIGtleSAhPT0gXCIkb3JcIiAmJiBrZXkgIT09IFwiJGluXCIgJiYga2V5ICE9PSBcIiRuaW5cIiAmJiAhW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiLCBcIm9iamVjdFwiXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkICd3aGVyZScgdmFsdWUgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgYW4gb3BlcmF0b3IgZXhwcmVzc2lvbiwgYnV0IGdvdCAke3ZhbHVlfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiJGFuZFwiIHx8IGtleSA9PT0gXCIkb3JcIikge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPD0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgJ3doZXJlJyB2YWx1ZSBmb3IgJGFuZCBvciAkb3IgdG8gYmUgYSBsaXN0IG9mICd3aGVyZScgZXhwcmVzc2lvbnMsIGJ1dCBnb3QgJHt2YWx1ZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YWx1ZS5mb3JFYWNoKCh3MikgPT4gdmFsaWRhdGVXaGVyZSh3MikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBvcGVyYXRvciBleHByZXNzaW9uIHRvIGhhdmUgb25lIG9wZXJhdG9yLCBidXQgZ290ICR7dmFsdWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgW29wZXJhdG9yLCBvcGVyYW5kXSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKVswXTtcbiAgICAgIGlmIChbXCIkZ3RcIiwgXCIkZ3RlXCIsIFwiJGx0XCIsIFwiJGx0ZVwiXS5pbmNsdWRlcyhvcGVyYXRvcikgJiYgdHlwZW9mIG9wZXJhbmQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIG9wZXJhbmQgdmFsdWUgdG8gYmUgYSBudW1iZXIgZm9yICR7b3BlcmF0b3J9LCBidXQgZ290ICR7dHlwZW9mIG9wZXJhbmR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFtcIiRpblwiLCBcIiRuaW5cIl0uaW5jbHVkZXMob3BlcmF0b3IpICYmICFBcnJheS5pc0FycmF5KG9wZXJhbmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBvcGVyYW5kIHZhbHVlIHRvIGJlIGFuIGFycmF5IGZvciAke29wZXJhdG9yfSwgYnV0IGdvdCAke29wZXJhbmR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFbXCIkZ3RcIiwgXCIkZ3RlXCIsIFwiJGx0XCIsIFwiJGx0ZVwiLCBcIiRuZVwiLCBcIiRlcVwiLCBcIiRpblwiLCBcIiRuaW5cIl0uaW5jbHVkZXMoXG4gICAgICAgIG9wZXJhdG9yXG4gICAgICApKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBvcGVyYXRvciB0byBiZSBvbmUgb2YgJGd0LCAkZ3RlLCAkbHQsICRsdGUsICRuZSwgJGVxLCAkaW4sICRuaW4sIGJ1dCBnb3QgJHtvcGVyYXRvcn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIVtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIG9wZXJhbmQpICYmICFBcnJheS5pc0FycmF5KG9wZXJhbmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgb3BlcmFuZCB2YWx1ZSB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBhIGxpc3Qgb2YgdGhvc2UgdHlwZXNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3BlcmFuZCkgJiYgKG9wZXJhbmQubGVuZ3RoID09PSAwIHx8ICFvcGVyYW5kLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gdHlwZW9mIG9wZXJhbmRbMF0pKSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkICd3aGVyZScgb3BlcmFuZCB2YWx1ZSB0byBiZSBhIG5vbi1lbXB0eSBsaXN0IGFuZCBhbGwgdmFsdWVzIHRvIGJlIG9mIHRoZSBzYW1lIHR5cGVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlV2hlcmVEb2N1bWVudCA9ICh3aGVyZURvY3VtZW50KSA9PiB7XG4gIGlmICh0eXBlb2Ygd2hlcmVEb2N1bWVudCAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCAnd2hlcmVEb2N1bWVudCcgdG8gYmUgYSBub24tZW1wdHkgb2JqZWN0XCJcbiAgICApO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyh3aGVyZURvY3VtZW50KS5sZW5ndGggIT0gMSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICd3aGVyZURvY3VtZW50JyB0byBoYXZlIGV4YWN0bHkgb25lIG9wZXJhdG9yLCBidXQgZ290ICR7d2hlcmVEb2N1bWVudH1gXG4gICAgKTtcbiAgfVxuICBjb25zdCBbb3BlcmF0b3IsIG9wZXJhbmRdID0gT2JqZWN0LmVudHJpZXMod2hlcmVEb2N1bWVudClbMF07XG4gIGlmICghW1xuICAgIFwiJGNvbnRhaW5zXCIsXG4gICAgXCIkbm90X2NvbnRhaW5zXCIsXG4gICAgXCIkbWF0Y2hlc1wiLFxuICAgIFwiJG5vdF9tYXRjaGVzXCIsXG4gICAgXCIkcmVnZXhcIixcbiAgICBcIiRub3RfcmVnZXhcIixcbiAgICBcIiRhbmRcIixcbiAgICBcIiRvclwiXG4gIF0uaW5jbHVkZXMob3BlcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgJ3doZXJlRG9jdW1lbnQnIG9wZXJhdG9yIHRvIGJlIG9uZSBvZiAkY29udGFpbnMsICRub3RfY29udGFpbnMsICRtYXRjaGVzLCAkbm90X21hdGNoZXMsICRyZWdleCwgJG5vdF9yZWdleCwgJGFuZCwgb3IgJG9yLCBidXQgZ290ICR7b3BlcmF0b3J9YFxuICAgICk7XG4gIH1cbiAgaWYgKG9wZXJhdG9yID09PSBcIiRhbmRcIiB8fCBvcGVyYXRvciA9PT0gXCIkb3JcIikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcGVyYW5kKSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBvcGVyYW5kIGZvciAke29wZXJhdG9yfSB0byBiZSBhIGxpc3Qgb2YgJ3doZXJlRG9jdW1lbnQnIGV4cHJlc3Npb25zLCBidXQgZ290ICR7b3BlcmFuZH1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3BlcmFuZC5sZW5ndGggPD0gMSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCAnd2hlcmVEb2N1bWVudCcgb3BlcmFuZCBmb3IgJHtvcGVyYXRvcn0gdG8gYmUgYSBsaXN0IHdpdGggYXQgbGVhc3QgdHdvICd3aGVyZURvY3VtZW50JyBleHByZXNzaW9uc2BcbiAgICAgICk7XG4gICAgfVxuICAgIG9wZXJhbmQuZm9yRWFjaCgoaXRlbSkgPT4gdmFsaWRhdGVXaGVyZURvY3VtZW50KGl0ZW0pKTtcbiAgfVxuICBpZiAoKG9wZXJhbmQgPT09IFwiJGNvbnRhaW5zXCIgfHwgb3BlcmFuZCA9PT0gXCIkbm90X2NvbnRhaW5zXCIgfHwgb3BlcmFuZCA9PT0gXCIkcmVnZXhcIiB8fCBvcGVyYW5kID09PSBcIiRub3RfcmVnZXhcIikgJiYgKHR5cGVvZiBvcGVyYXRvciAhPT0gXCJzdHJpbmdcIiB8fCBvcGVyYXRvci5sZW5ndGggPT09IDApKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgb3BlcmFuZCBmb3IgJHtvcGVyYXRvcn0gdG8gYmUgYSBub24gZW1wdHkgc3RyaW5nLCBidXQgZ290ICR7b3BlcmFuZH1gXG4gICAgKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUluY2x1ZGUgPSAoe1xuICBpbmNsdWRlLFxuICBleGNsdWRlXG59KSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbmNsdWRlKSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgJ2luY2x1ZGUnIHRvIGJlIGEgbm9uLWVtcHR5IGFycmF5XCIpO1xuICB9XG4gIGNvbnN0IHZhbGlkVmFsdWVzID0gT2JqZWN0LmtleXMoSW5jbHVkZUVudW0pO1xuICBpbmNsdWRlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgJ2luY2x1ZGUnIGl0ZW1zIHRvIGJlIHN0cmluZ3NcIik7XG4gICAgfVxuICAgIGlmICghdmFsaWRWYWx1ZXMuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgJ2luY2x1ZGUnIGl0ZW1zIHRvIGJlIG9uZSBvZiAke3ZhbGlkVmFsdWVzLmpvaW4oXG4gICAgICAgICAgXCIsIFwiXG4gICAgICAgICl9LCBidXQgZ290ICR7aXRlbX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZXhjbHVkZT8uaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKGAke2l0ZW19IGlzIG5vdCBhbGxvd2VkIGZvciB0aGlzIG9wZXJhdGlvbmApO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlTlJlc3VsdHMgPSAoblJlc3VsdHMpID0+IHtcbiAgaWYgKHR5cGVvZiBuUmVzdWx0cyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICduUmVzdWx0cycgdG8gYmUgYSBudW1iZXIsIGJ1dCBnb3QgJHt0eXBlb2YgblJlc3VsdHN9YFxuICAgICk7XG4gIH1cbiAgaWYgKG5SZXN1bHRzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcIk51bWJlciBvZiByZXF1ZXN0ZWQgcmVzdWx0cyBoYXMgdG8gcG9zaXRpdmVcIik7XG4gIH1cbn07XG52YXIgcGFyc2VDb25uZWN0aW9uUGF0aCA9IChwYXRoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoKTtcbiAgICBjb25zdCBzc2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgY29uc3QgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNzbCxcbiAgICAgIGhvc3QsXG4gICAgICBwb3J0OiBOdW1iZXIocG9ydClcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihgSW52YWxpZCBVUkw6ICR7cGF0aH1gKTtcbiAgfVxufTtcbnZhciBwYWNrRW1iZWRkaW5nID0gKGVtYmVkZGluZykgPT4ge1xuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZW1iZWRkaW5nLmxlbmd0aCAqIDQpO1xuICBjb25zdCB2aWV3ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVtYmVkZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZpZXdbaV0gPSBlbWJlZGRpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG52YXIgZW1iZWRkaW5nc1RvQmFzZTY0Qnl0ZXMgPSAoZW1iZWRkaW5ncykgPT4ge1xuICByZXR1cm4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHBhY2tFbWJlZGRpbmcoZW1iZWRkaW5nKTtcbiAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBBcnJheS5mcm9tKFxuICAgICAgdWludDhBcnJheSxcbiAgICAgIChieXRlKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpXG4gICAgKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBidG9hKGJpbmFyeVN0cmluZyk7XG4gIH0pO1xufTtcblxuLy8gc3JjL2VtYmVkZGluZy1mdW5jdGlvbi50c1xudmFyIGtub3duRW1iZWRkaW5nRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBweXRob25FbWJlZGRpbmdGdW5jdGlvbnMgPSB7XG4gIG9ubnhfbWluaV9sbV9sNl92MjogXCJkZWZhdWx0LWVtYmVkXCIsXG4gIGRlZmF1bHQ6IFwiZGVmYXVsdC1lbWJlZFwiLFxuICB0b2dldGhlcl9haTogXCJ0b2dldGhlci1haVwiLFxuICBzZW50ZW5jZV90cmFuc2Zvcm1lcjogXCJzZW50ZW5jZS10cmFuc2Zvcm1lclwiXG59O1xudmFyIHVuc3VwcG9ydGVkRW1iZWRkaW5nRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImFtYXpvbl9iZWRyb2NrXCIsXG4gIFwiYmFzZXRlblwiLFxuICBcImxhbmdjaGFpblwiLFxuICBcImdvb2dsZV9wYWxtXCIsXG4gIFwiaHVnZ2luZ2ZhY2VcIixcbiAgXCJpbnN0cnVjdG9yXCIsXG4gIFwib3Blbl9jbGlwXCIsXG4gIFwicm9ib2Zsb3dcIixcbiAgXCJ0ZXh0MnZlY1wiXG5dKTtcbnZhciBrbm93blNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG52YXIgcHl0aG9uU3BhcnNlRW1iZWRkaW5nRnVuY3Rpb25zID0ge1xuICBjaHJvbWFfYm0yNTogXCJjaHJvbWEtYm0yNVwiXG59O1xudmFyIHVuc3VwcG9ydGVkU3BhcnNlRW1iZWRkaW5nRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImJtMjVcIixcbiAgXCJmYXN0ZW1iZWRfc3BhcnNlXCIsXG4gIFwiaHVnZ2luZ2ZhY2Vfc3BhcnNlXCJcbl0pO1xudmFyIHJlZ2lzdGVyRW1iZWRkaW5nRnVuY3Rpb24gPSAobmFtZSwgZm4pID0+IHtcbiAgaWYgKGtub3duRW1iZWRkaW5nRnVuY3Rpb25zLmhhcyhuYW1lKSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEVtYmVkZGluZyBmdW5jdGlvbiB3aXRoIG5hbWUgJHtuYW1lfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuYFxuICAgICk7XG4gIH1cbiAga25vd25FbWJlZGRpbmdGdW5jdGlvbnMuc2V0KG5hbWUsIGZuKTtcbn07XG52YXIgcmVnaXN0ZXJTcGFyc2VFbWJlZGRpbmdGdW5jdGlvbiA9IChuYW1lLCBmbikgPT4ge1xuICBpZiAoa25vd25TcGFyc2VFbWJlZGRpbmdGdW5jdGlvbnMuaGFzKG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgU3BhcnNlIGVtYmVkZGluZyBmdW5jdGlvbiB3aXRoIG5hbWUgJHtuYW1lfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuYFxuICAgICk7XG4gIH1cbiAga25vd25TcGFyc2VFbWJlZGRpbmdGdW5jdGlvbnMuc2V0KG5hbWUsIGZuKTtcbn07XG52YXIgZ2V0RW1iZWRkaW5nRnVuY3Rpb24gPSBhc3luYyAoYXJncykgPT4ge1xuICBjb25zdCB7IGNvbGxlY3Rpb25OYW1lLCBjbGllbnQ6IGNsaWVudDIsIGVmQ29uZmlnIH0gPSBhcmdzO1xuICBpZiAoIWVmQ29uZmlnKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYE5vIGVtYmVkZGluZyBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGZvdW5kIGZvciBjb2xsZWN0aW9uICR7Y29sbGVjdGlvbk5hbWV9LiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChlZkNvbmZpZy50eXBlID09PSBcImxlZ2FjeVwiKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYE5vIGVtYmVkZGluZyBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGZvdW5kIGZvciBjb2xsZWN0aW9uICR7Y29sbGVjdGlvbk5hbWV9LiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChlZkNvbmZpZy50eXBlID09PSBcInVua25vd25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBVbmtub3duIGVtYmVkZGluZyBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGZvciBjb2xsZWN0aW9uICR7Y29sbGVjdGlvbk5hbWV9LiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChlZkNvbmZpZy50eXBlICE9PSBcImtub3duXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICh1bnN1cHBvcnRlZEVtYmVkZGluZ0Z1bmN0aW9ucy5oYXMoZWZDb25maWcubmFtZSkpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgRW1iZWRkaW5nIGZ1bmN0aW9uICR7ZWZDb25maWcubmFtZX0gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgSlMvVFMgU0RLLiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHBhY2thZ2VOYW1lID0gcHl0aG9uRW1iZWRkaW5nRnVuY3Rpb25zW2VmQ29uZmlnLm5hbWVdIHx8IGVmQ29uZmlnLm5hbWU7XG4gIGlmIChwYWNrYWdlTmFtZSA9PT0gXCJkZWZhdWx0LWVtYmVkXCIpIHtcbiAgICBhd2FpdCBnZXREZWZhdWx0RUZDb25maWcoKTtcbiAgfVxuICBsZXQgZW1iZWRkaW5nRnVuY3Rpb24gPSBrbm93bkVtYmVkZGluZ0Z1bmN0aW9ucy5nZXQocGFja2FnZU5hbWUpO1xuICBpZiAoIWVtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZ1bGxQYWNrYWdlTmFtZSA9IGBAY2hyb21hLWNvcmUvJHtwYWNrYWdlTmFtZX1gO1xuICAgICAgYXdhaXQgaW1wb3J0KGZ1bGxQYWNrYWdlTmFtZSk7XG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbiA9IGtub3duRW1iZWRkaW5nRnVuY3Rpb25zLmdldChwYWNrYWdlTmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gICAgaWYgKCFlbWJlZGRpbmdGdW5jdGlvbikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgQ29sbGVjdGlvbiAke2NvbGxlY3Rpb25OYW1lfSB3YXMgY3JlYXRlZCB3aXRoIHRoZSAke3BhY2thZ2VOYW1lfSBlbWJlZGRpbmcgZnVuY3Rpb24uIEhvd2V2ZXIsIHRoZSBAY2hyb21hLWNvcmUvJHtwYWNrYWdlTmFtZX0gcGFja2FnZSBpcyBub3QgaW5zdGFsbGVkLiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseSwgb3IgaW5zdGFsbCB0aGUgQGNocm9tYS1jb3JlLyR7cGFja2FnZU5hbWV9IHBhY2thZ2UuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGxldCBjb25zdHJ1Y3RvckNvbmZpZyA9IGVmQ29uZmlnLnR5cGUgPT09IFwia25vd25cIiA/IGVmQ29uZmlnLmNvbmZpZyA6IHt9O1xuICB0cnkge1xuICAgIGlmIChlbWJlZGRpbmdGdW5jdGlvbi5idWlsZEZyb21Db25maWcpIHtcbiAgICAgIHJldHVybiBlbWJlZGRpbmdGdW5jdGlvbi5idWlsZEZyb21Db25maWcoY29uc3RydWN0b3JDb25maWcsIGNsaWVudDIpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgRW1iZWRkaW5nIGZ1bmN0aW9uICR7cGFja2FnZU5hbWV9IGRvZXMgbm90IGRlZmluZSBhICdidWlsZEZyb21Db25maWcnIGZ1bmN0aW9uLiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEVtYmVkZGluZyBmdW5jdGlvbiAke3BhY2thZ2VOYW1lfSBmYWlsZWQgdG8gYnVpbGQgd2l0aCBjb25maWc6ICR7Y29uc3RydWN0b3JDb25maWd9LiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS4gRXJyb3I6ICR7ZX1gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xudmFyIGdldFNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9uID0gYXN5bmMgKGNvbGxlY3Rpb25OYW1lLCBjbGllbnQyLCBlZkNvbmZpZykgPT4ge1xuICBpZiAoIWVmQ29uZmlnKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoZWZDb25maWcudHlwZSA9PT0gXCJsZWdhY3lcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKGVmQ29uZmlnLnR5cGUgIT09IFwia25vd25cIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHVuc3VwcG9ydGVkU3BhcnNlRW1iZWRkaW5nRnVuY3Rpb25zLmhhcyhlZkNvbmZpZy5uYW1lKSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiRW1iZWRkaW5nIGZ1bmN0aW9uICR7ZWZDb25maWcubmFtZX0gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgSlMvVFMgU0RLLiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5cIlxuICAgICk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBwYWNrYWdlTmFtZSA9IHB5dGhvblNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9uc1tlZkNvbmZpZy5uYW1lXSB8fCBlZkNvbmZpZy5uYW1lO1xuICBsZXQgc3BhcnNlRW1iZWRkaW5nRnVuY3Rpb24gPSBrbm93blNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9ucy5nZXQocGFja2FnZU5hbWUpO1xuICBpZiAoIXNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZ1bGxQYWNrYWdlTmFtZSA9IGBAY2hyb21hLWNvcmUvJHtwYWNrYWdlTmFtZX1gO1xuICAgICAgYXdhaXQgaW1wb3J0KGZ1bGxQYWNrYWdlTmFtZSk7XG4gICAgICBzcGFyc2VFbWJlZGRpbmdGdW5jdGlvbiA9IGtub3duU3BhcnNlRW1iZWRkaW5nRnVuY3Rpb25zLmdldChwYWNrYWdlTmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gICAgaWYgKCFzcGFyc2VFbWJlZGRpbmdGdW5jdGlvbikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgQ29sbGVjdGlvbiAke2NvbGxlY3Rpb25OYW1lfSB3YXMgY3JlYXRlZCB3aXRoIHRoZSAke3BhY2thZ2VOYW1lfSBzcGFyc2UgZW1iZWRkaW5nIGZ1bmN0aW9uLiBIb3dldmVyLCB0aGUgQGNocm9tYS1jb3JlLyR7cGFja2FnZU5hbWV9IHBhY2thZ2UgaXMgbm90IGluc3RhbGxlZC5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgbGV0IGNvbnN0cnVjdG9yQ29uZmlnID0gZWZDb25maWcudHlwZSA9PT0gXCJrbm93blwiID8gZWZDb25maWcuY29uZmlnIDoge307XG4gIHRyeSB7XG4gICAgaWYgKHNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9uLmJ1aWxkRnJvbUNvbmZpZykge1xuICAgICAgcmV0dXJuIHNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9uLmJ1aWxkRnJvbUNvbmZpZyhjb25zdHJ1Y3RvckNvbmZpZywgY2xpZW50Mik7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBTcGFyc2UgZW1iZWRkaW5nIGZ1bmN0aW9uICR7cGFja2FnZU5hbWV9IGRvZXMgbm90IGRlZmluZSBhICdidWlsZEZyb21Db25maWcnIGZ1bmN0aW9uLmBcbiAgICApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgU3BhcnNlIGVtYmVkZGluZyBmdW5jdGlvbiAke3BhY2thZ2VOYW1lfSBmYWlsZWQgdG8gYnVpbGQgd2l0aCBjb25maWc6ICR7Y29uc3RydWN0b3JDb25maWd9LiBFcnJvcjogJHtlfWBcbiAgICApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG52YXIgc2VyaWFsaXplRW1iZWRkaW5nRnVuY3Rpb24gPSAoe1xuICBlbWJlZGRpbmdGdW5jdGlvbixcbiAgY29uZmlnRW1iZWRkaW5nRnVuY3Rpb25cbn0pID0+IHtcbiAgaWYgKGVtYmVkZGluZ0Z1bmN0aW9uICYmIGNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkVtYmVkZGluZyBmdW5jdGlvbiBwcm92aWRlZCB3aGVuIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgY29sbGVjdGlvbiBjb25maWd1cmF0aW9uXCJcbiAgICApO1xuICB9XG4gIGlmICghZW1iZWRkaW5nRnVuY3Rpb24gJiYgIWNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBlZiA9IGVtYmVkZGluZ0Z1bmN0aW9uIHx8IGNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uO1xuICBpZiAoIWVmLmdldENvbmZpZyB8fCAhZWYubmFtZSB8fCAhZWYuY29uc3RydWN0b3IuYnVpbGRGcm9tQ29uZmlnKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJsZWdhY3lcIiB9O1xuICB9XG4gIGlmIChlZi52YWxpZGF0ZUNvbmZpZykgZWYudmFsaWRhdGVDb25maWcoZWYuZ2V0Q29uZmlnKCkpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IGVmLm5hbWUsXG4gICAgdHlwZTogXCJrbm93blwiLFxuICAgIGNvbmZpZzogZWYuZ2V0Q29uZmlnKClcbiAgfTtcbn07XG52YXIgZ2V0RGVmYXVsdEVGQ29uZmlnID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgRGVmYXVsdEVtYmVkZGluZ0Z1bmN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCJAY2hyb21hLWNvcmUvZGVmYXVsdC1lbWJlZFwiKTtcbiAgICBpZiAoIWtub3duRW1iZWRkaW5nRnVuY3Rpb25zLmhhcyhcImRlZmF1bHQtZW1iZWRcIikpIHtcbiAgICAgIHJlZ2lzdGVyRW1iZWRkaW5nRnVuY3Rpb24oXCJkZWZhdWx0LWVtYmVkXCIsIERlZmF1bHRFbWJlZGRpbmdGdW5jdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJDYW5ub3QgaW5zdGFudGlhdGUgYSBjb2xsZWN0aW9uIHdpdGggdGhlIERlZmF1bHRFbWJlZGRpbmdGdW5jdGlvbi4gUGxlYXNlIGluc3RhbGwgQGNocm9tYS1jb3JlL2RlZmF1bHQtZW1iZWQsIG9yIHByb3ZpZGUgYSBkaWZmZXJlbnQgZW1iZWRkaW5nIGZ1bmN0aW9uXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJkZWZhdWx0XCIsXG4gICAgdHlwZTogXCJrbm93blwiLFxuICAgIGNvbmZpZzoge31cbiAgfTtcbn07XG5cbi8vIHNyYy9jb2xsZWN0aW9uLWNvbmZpZ3VyYXRpb24udHNcbnZhciBwcm9jZXNzQ3JlYXRlQ29sbGVjdGlvbkNvbmZpZyA9IGFzeW5jICh7XG4gIGNvbmZpZ3VyYXRpb24sXG4gIGVtYmVkZGluZ0Z1bmN0aW9uLFxuICBtZXRhZGF0YSxcbiAgc2NoZW1hXG59KSA9PiB7XG4gIGxldCBzY2hlbWFFbWJlZGRpbmdGdW5jdGlvbiA9IHZvaWQgMDtcbiAgaWYgKHNjaGVtYSkge1xuICAgIHNjaGVtYUVtYmVkZGluZ0Z1bmN0aW9uID0gc2NoZW1hLnJlc29sdmVFbWJlZGRpbmdGdW5jdGlvbigpO1xuICB9XG4gIGlmIChjb25maWd1cmF0aW9uPy5obnN3ICYmIGNvbmZpZ3VyYXRpb24/LnNwYW5uKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkNhbm5vdCBzcGVjaWZ5IGJvdGggSE5TVyBhbmQgU1BBTk4gY29uZmlndXJhdGlvbnNcIlxuICAgICk7XG4gIH1cbiAgbGV0IGVtYmVkZGluZ0Z1bmN0aW9uQ29uZmlndXJhdGlvbiA9IHNlcmlhbGl6ZUVtYmVkZGluZ0Z1bmN0aW9uKHtcbiAgICBlbWJlZGRpbmdGdW5jdGlvbjogZW1iZWRkaW5nRnVuY3Rpb24gPz8gdm9pZCAwLFxuICAgIGNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uOiBjb25maWd1cmF0aW9uPy5lbWJlZGRpbmdGdW5jdGlvblxuICB9KTtcbiAgaWYgKCFlbWJlZGRpbmdGdW5jdGlvbkNvbmZpZ3VyYXRpb24gJiYgZW1iZWRkaW5nRnVuY3Rpb24gIT09IG51bGwgJiYgc2NoZW1hRW1iZWRkaW5nRnVuY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIGVtYmVkZGluZ0Z1bmN0aW9uQ29uZmlndXJhdGlvbiA9IGF3YWl0IGdldERlZmF1bHRFRkNvbmZpZygpO1xuICB9XG4gIGNvbnN0IG92ZXJhbGxFZiA9IGVtYmVkZGluZ0Z1bmN0aW9uIHx8IGNvbmZpZ3VyYXRpb24/LmVtYmVkZGluZ0Z1bmN0aW9uO1xuICBpZiAob3ZlcmFsbEVmICYmIG92ZXJhbGxFZi5kZWZhdWx0U3BhY2UgJiYgb3ZlcmFsbEVmLnN1cHBvcnRlZFNwYWNlcykge1xuICAgIGlmIChjb25maWd1cmF0aW9uPy5obnN3ID09PSB2b2lkIDAgJiYgY29uZmlndXJhdGlvbj8uc3Bhbm4gPT09IHZvaWQgMCkge1xuICAgICAgaWYgKG1ldGFkYXRhID09PSB2b2lkIDAgfHwgbWV0YWRhdGE/LltcImhuc3c6c3BhY2VcIl0gPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24pIGNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5obnN3ID0geyBzcGFjZTogb3ZlcmFsbEVmLmRlZmF1bHRTcGFjZSgpIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25maWd1cmF0aW9uPy5obnN3ICYmICFjb25maWd1cmF0aW9uLmhuc3cuc3BhY2UgJiYgb3ZlcmFsbEVmLmRlZmF1bHRTcGFjZSkge1xuICAgICAgY29uZmlndXJhdGlvbi5obnN3LnNwYWNlID0gb3ZlcmFsbEVmLmRlZmF1bHRTcGFjZSgpO1xuICAgIH1cbiAgICBpZiAoY29uZmlndXJhdGlvbj8uc3Bhbm4gJiYgIWNvbmZpZ3VyYXRpb24uc3Bhbm4uc3BhY2UgJiYgb3ZlcmFsbEVmLmRlZmF1bHRTcGFjZSkge1xuICAgICAgY29uZmlndXJhdGlvbi5zcGFubi5zcGFjZSA9IG92ZXJhbGxFZi5kZWZhdWx0U3BhY2UoKTtcbiAgICB9XG4gICAgaWYgKG92ZXJhbGxFZi5zdXBwb3J0ZWRTcGFjZXMpIHtcbiAgICAgIGNvbnN0IHN1cHBvcnRlZFNwYWNlcyA9IG92ZXJhbGxFZi5zdXBwb3J0ZWRTcGFjZXMoKTtcbiAgICAgIGlmIChjb25maWd1cmF0aW9uPy5obnN3Py5zcGFjZSAmJiAhc3VwcG9ydGVkU3BhY2VzLmluY2x1ZGVzKGNvbmZpZ3VyYXRpb24uaG5zdy5zcGFjZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBTcGFjZSAnJHtjb25maWd1cmF0aW9uLmhuc3cuc3BhY2V9JyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGVtYmVkZGluZyBmdW5jdGlvbiAnJHtvdmVyYWxsRWYubmFtZSB8fCBcInVua25vd25cIn0nLiBTdXBwb3J0ZWQgc3BhY2VzOiAke3N1cHBvcnRlZFNwYWNlcy5qb2luKFwiLCBcIil9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24/LnNwYW5uPy5zcGFjZSAmJiAhc3VwcG9ydGVkU3BhY2VzLmluY2x1ZGVzKGNvbmZpZ3VyYXRpb24uc3Bhbm4uc3BhY2UpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgU3BhY2UgJyR7Y29uZmlndXJhdGlvbi5zcGFubi5zcGFjZX0nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgZW1iZWRkaW5nIGZ1bmN0aW9uICcke292ZXJhbGxFZi5uYW1lIHx8IFwidW5rbm93blwifScuIFN1cHBvcnRlZCBzcGFjZXM6ICR7c3VwcG9ydGVkU3BhY2VzLmpvaW4oXCIsIFwiKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpZ3VyYXRpb24/Lmhuc3cgJiYgIWNvbmZpZ3VyYXRpb24/LnNwYW5uICYmIG1ldGFkYXRhICYmIHR5cGVvZiBtZXRhZGF0YVtcImhuc3c6c3BhY2VcIl0gPT09IFwic3RyaW5nXCIgJiYgIXN1cHBvcnRlZFNwYWNlcy5pbmNsdWRlcyhcbiAgICAgICAgbWV0YWRhdGFbXCJobnN3OnNwYWNlXCJdXG4gICAgICApKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgU3BhY2UgJyR7bWV0YWRhdGFbXCJobnN3OnNwYWNlXCJdfScgZnJvbSBtZXRhZGF0YSBpcyBub3Qgc3VwcG9ydGVkIGJ5IGVtYmVkZGluZyBmdW5jdGlvbiAnJHtvdmVyYWxsRWYubmFtZSB8fCBcInVua25vd25cIn0nLiBTdXBwb3J0ZWQgc3BhY2VzOiAke3N1cHBvcnRlZFNwYWNlcy5qb2luKFwiLCBcIil9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmNvbmZpZ3VyYXRpb24gfHwge30sXG4gICAgZW1iZWRkaW5nX2Z1bmN0aW9uOiBlbWJlZGRpbmdGdW5jdGlvbkNvbmZpZ3VyYXRpb25cbiAgfTtcbn07XG52YXIgcHJvY2Vzc1VwZGF0ZUNvbGxlY3Rpb25Db25maWcgPSBhc3luYyAoe1xuICBjb2xsZWN0aW9uTmFtZSxcbiAgY3VycmVudENvbmZpZ3VyYXRpb24sXG4gIGN1cnJlbnRFbWJlZGRpbmdGdW5jdGlvbixcbiAgbmV3Q29uZmlndXJhdGlvbixcbiAgY2xpZW50OiBjbGllbnQyXG59KSA9PiB7XG4gIGlmIChuZXdDb25maWd1cmF0aW9uLmhuc3cgJiYgdHlwZW9mIG5ld0NvbmZpZ3VyYXRpb24uaG5zdyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgXCJJbnZhbGlkIEhOU1cgY29uZmlnIHByb3ZpZGVkIGluIFVwZGF0ZUNvbGxlY3Rpb25Db25maWd1cmF0aW9uXCJcbiAgICApO1xuICB9XG4gIGlmIChuZXdDb25maWd1cmF0aW9uLnNwYW5uICYmIHR5cGVvZiBuZXdDb25maWd1cmF0aW9uLnNwYW5uICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkludmFsaWQgU1BBTk4gY29uZmlnIHByb3ZpZGVkIGluIFVwZGF0ZUNvbGxlY3Rpb25Db25maWd1cmF0aW9uXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IGVtYmVkZGluZ0Z1bmN0aW9uID0gY3VycmVudEVtYmVkZGluZ0Z1bmN0aW9uIHx8IGF3YWl0IGdldEVtYmVkZGluZ0Z1bmN0aW9uKHtcbiAgICBjb2xsZWN0aW9uTmFtZSxcbiAgICBjbGllbnQ6IGNsaWVudDIsXG4gICAgZWZDb25maWc6IGN1cnJlbnRDb25maWd1cmF0aW9uLmVtYmVkZGluZ0Z1bmN0aW9uID8/IHZvaWQgMFxuICB9KTtcbiAgY29uc3QgbmV3RW1iZWRkaW5nRnVuY3Rpb24gPSBuZXdDb25maWd1cmF0aW9uLmVtYmVkZGluZ0Z1bmN0aW9uO1xuICBpZiAoZW1iZWRkaW5nRnVuY3Rpb24gJiYgZW1iZWRkaW5nRnVuY3Rpb24udmFsaWRhdGVDb25maWdVcGRhdGUgJiYgbmV3RW1iZWRkaW5nRnVuY3Rpb24gJiYgbmV3RW1iZWRkaW5nRnVuY3Rpb24uZ2V0Q29uZmlnKSB7XG4gICAgZW1iZWRkaW5nRnVuY3Rpb24udmFsaWRhdGVDb25maWdVcGRhdGUobmV3RW1iZWRkaW5nRnVuY3Rpb24uZ2V0Q29uZmlnKCkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdXBkYXRlQ29uZmlndXJhdGlvbjoge1xuICAgICAgaG5zdzogbmV3Q29uZmlndXJhdGlvbi5obnN3LFxuICAgICAgc3Bhbm46IG5ld0NvbmZpZ3VyYXRpb24uc3Bhbm4sXG4gICAgICBlbWJlZGRpbmdfZnVuY3Rpb246IG5ld0VtYmVkZGluZ0Z1bmN0aW9uICYmIHNlcmlhbGl6ZUVtYmVkZGluZ0Z1bmN0aW9uKHsgZW1iZWRkaW5nRnVuY3Rpb246IG5ld0VtYmVkZGluZ0Z1bmN0aW9uIH0pXG4gICAgfSxcbiAgICB1cGRhdGVFbWJlZGRpbmdGdW5jdGlvbjogbmV3RW1iZWRkaW5nRnVuY3Rpb25cbiAgfTtcbn07XG5cbi8vIHNyYy9leGVjdXRpb24vZXhwcmVzc2lvbi9jb21tb24udHNcbnZhciBpc1BsYWluT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgcHJvdG90eXBlID09PSBudWxsO1xufTtcbnZhciBkZWVwQ2xvbmUgPSAodmFsdWUpID0+IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbnZhciBpdGVyYWJsZVRvQXJyYXkgPSAodmFsdWVzKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICByZXR1cm4gdmFsdWVzLnNsaWNlKCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20odmFsdWVzKTtcbn07XG52YXIgYXNzZXJ0Tm9uRW1wdHlBcnJheSA9ICh2YWx1ZXMsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9leGVjdXRpb24vZXhwcmVzc2lvbi93aGVyZS50c1xudmFyIFdoZXJlRXhwcmVzc2lvbkJhc2UgPSBjbGFzcyB7XG4gIGFuZChvdGhlcikge1xuICAgIGNvbnN0IHRhcmdldCA9IFdoZXJlRXhwcmVzc2lvbi5mcm9tKG90aGVyKTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBBbmRXaGVyZS5jb21iaW5lKHRoaXMsIHRhcmdldCk7XG4gIH1cbiAgb3Iob3RoZXIpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBXaGVyZUV4cHJlc3Npb24uZnJvbShvdGhlcik7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gT3JXaGVyZS5jb21iaW5lKHRoaXMsIHRhcmdldCk7XG4gIH1cbn07XG52YXIgV2hlcmVFeHByZXNzaW9uID0gY2xhc3MgX1doZXJlRXhwcmVzc2lvbiBleHRlbmRzIFdoZXJlRXhwcmVzc2lvbkJhc2Uge1xuICBzdGF0aWMgZnJvbShpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIF9XaGVyZUV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmICghaXNQbGFpbk9iamVjdChpbnB1dCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJXaGVyZSBpbnB1dCBtdXN0IGJlIGEgV2hlcmVFeHByZXNzaW9uIG9yIHBsYWluIG9iamVjdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlV2hlcmVEaWN0KGlucHV0KTtcbiAgfVxufTtcbnZhciBBbmRXaGVyZSA9IGNsYXNzIF9BbmRXaGVyZSBleHRlbmRzIFdoZXJlRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbmRpdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZGl0aW9ucyA9IGNvbmRpdGlvbnM7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7ICRhbmQ6IHRoaXMuY29uZGl0aW9ucy5tYXAoKGNvbmRpdGlvbikgPT4gY29uZGl0aW9uLnRvSlNPTigpKSB9O1xuICB9XG4gIGdldCBvcGVyYW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zLnNsaWNlKCk7XG4gIH1cbiAgc3RhdGljIGNvbWJpbmUobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSBbXTtcbiAgICBjb25zdCBhZGQgPSAoZXhwcikgPT4ge1xuICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBfQW5kV2hlcmUpIHtcbiAgICAgICAgZmxhdHRlbmVkLnB1c2goLi4uZXhwci5vcGVyYW5kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0dGVuZWQucHVzaChleHByKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFkZChsZWZ0KTtcbiAgICBhZGQocmlnaHQpO1xuICAgIGlmIChmbGF0dGVuZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9BbmRXaGVyZShmbGF0dGVuZWQpO1xuICB9XG59O1xudmFyIE9yV2hlcmUgPSBjbGFzcyBfT3JXaGVyZSBleHRlbmRzIFdoZXJlRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbmRpdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZGl0aW9ucyA9IGNvbmRpdGlvbnM7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7ICRvcjogdGhpcy5jb25kaXRpb25zLm1hcCgoY29uZGl0aW9uKSA9PiBjb25kaXRpb24udG9KU09OKCkpIH07XG4gIH1cbiAgZ2V0IG9wZXJhbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnMuc2xpY2UoKTtcbiAgfVxuICBzdGF0aWMgY29tYmluZShsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IFtdO1xuICAgIGNvbnN0IGFkZCA9IChleHByKSA9PiB7XG4gICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIF9PcldoZXJlKSB7XG4gICAgICAgIGZsYXR0ZW5lZC5wdXNoKC4uLmV4cHIub3BlcmFuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdHRlbmVkLnB1c2goZXhwcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBhZGQobGVmdCk7XG4gICAgYWRkKHJpZ2h0KTtcbiAgICBpZiAoZmxhdHRlbmVkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZsYXR0ZW5lZFswXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfT3JXaGVyZShmbGF0dGVuZWQpO1xuICB9XG59O1xudmFyIENvbXBhcmlzb25XaGVyZSA9IGNsYXNzIGV4dGVuZHMgV2hlcmVFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3Ioa2V5LCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5rZXldOiB7XG4gICAgICAgIFt0aGlzLm9wZXJhdG9yXTogdGhpcy52YWx1ZVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgY29tcGFyaXNvbk9wZXJhdG9yTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCIkZXFcIiwgKGtleSwgdmFsdWUpID0+IG5ldyBDb21wYXJpc29uV2hlcmUoa2V5LCBcIiRlcVwiLCB2YWx1ZSldLFxuICBbXCIkbmVcIiwgKGtleSwgdmFsdWUpID0+IG5ldyBDb21wYXJpc29uV2hlcmUoa2V5LCBcIiRuZVwiLCB2YWx1ZSldLFxuICBbXCIkZ3RcIiwgKGtleSwgdmFsdWUpID0+IG5ldyBDb21wYXJpc29uV2hlcmUoa2V5LCBcIiRndFwiLCB2YWx1ZSldLFxuICBbXCIkZ3RlXCIsIChrZXksIHZhbHVlKSA9PiBuZXcgQ29tcGFyaXNvbldoZXJlKGtleSwgXCIkZ3RlXCIsIHZhbHVlKV0sXG4gIFtcIiRsdFwiLCAoa2V5LCB2YWx1ZSkgPT4gbmV3IENvbXBhcmlzb25XaGVyZShrZXksIFwiJGx0XCIsIHZhbHVlKV0sXG4gIFtcIiRsdGVcIiwgKGtleSwgdmFsdWUpID0+IG5ldyBDb21wYXJpc29uV2hlcmUoa2V5LCBcIiRsdGVcIiwgdmFsdWUpXSxcbiAgW1wiJGluXCIsIChrZXksIHZhbHVlKSA9PiBuZXcgQ29tcGFyaXNvbldoZXJlKGtleSwgXCIkaW5cIiwgdmFsdWUpXSxcbiAgW1wiJG5pblwiLCAoa2V5LCB2YWx1ZSkgPT4gbmV3IENvbXBhcmlzb25XaGVyZShrZXksIFwiJG5pblwiLCB2YWx1ZSldLFxuICBbXCIkY29udGFpbnNcIiwgKGtleSwgdmFsdWUpID0+IG5ldyBDb21wYXJpc29uV2hlcmUoa2V5LCBcIiRjb250YWluc1wiLCB2YWx1ZSldLFxuICBbXCIkbm90X2NvbnRhaW5zXCIsIChrZXksIHZhbHVlKSA9PiBuZXcgQ29tcGFyaXNvbldoZXJlKGtleSwgXCIkbm90X2NvbnRhaW5zXCIsIHZhbHVlKV0sXG4gIFtcIiRyZWdleFwiLCAoa2V5LCB2YWx1ZSkgPT4gbmV3IENvbXBhcmlzb25XaGVyZShrZXksIFwiJHJlZ2V4XCIsIHZhbHVlKV0sXG4gIFtcIiRub3RfcmVnZXhcIiwgKGtleSwgdmFsdWUpID0+IG5ldyBDb21wYXJpc29uV2hlcmUoa2V5LCBcIiRub3RfcmVnZXhcIiwgdmFsdWUpXVxuXSk7XG52YXIgcGFyc2VXaGVyZURpY3QgPSAoZGF0YSkgPT4ge1xuICBpZiAoXCIkYW5kXCIgaW4gZGF0YSkge1xuICAgIGlmIChPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIiRhbmQgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggb3RoZXIga2V5c1wiKTtcbiAgICB9XG4gICAgY29uc3QgcmF3Q29uZGl0aW9ucyA9IGRhdGFbXCIkYW5kXCJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYXdDb25kaXRpb25zKSB8fCByYXdDb25kaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIiRhbmQgbXVzdCBiZSBhIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICB9XG4gICAgY29uc3QgY29uZGl0aW9ucyA9IHJhd0NvbmRpdGlvbnMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZXhwciA9IFdoZXJlRXhwcmVzc2lvbi5mcm9tKGl0ZW0pO1xuICAgICAgaWYgKCFleHByKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgd2hlcmUgY2xhdXNlIGF0IGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9KTtcbiAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBjb25kaXRpb25zWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uZGl0aW9ucy5zbGljZSgxKS5yZWR1Y2UoKGFjYywgY29uZGl0aW9uKSA9PiBBbmRXaGVyZS5jb21iaW5lKGFjYywgY29uZGl0aW9uKSwgY29uZGl0aW9uc1swXSk7XG4gIH1cbiAgaWYgKFwiJG9yXCIgaW4gZGF0YSkge1xuICAgIGlmIChPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIiRvciBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBvdGhlciBrZXlzXCIpO1xuICAgIH1cbiAgICBjb25zdCByYXdDb25kaXRpb25zID0gZGF0YVtcIiRvclwiXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3Q29uZGl0aW9ucykgfHwgcmF3Q29uZGl0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCIkb3IgbXVzdCBiZSBhIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICB9XG4gICAgY29uc3QgY29uZGl0aW9ucyA9IHJhd0NvbmRpdGlvbnMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZXhwciA9IFdoZXJlRXhwcmVzc2lvbi5mcm9tKGl0ZW0pO1xuICAgICAgaWYgKCFleHByKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgd2hlcmUgY2xhdXNlIGF0IGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9KTtcbiAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBjb25kaXRpb25zWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uZGl0aW9ucy5zbGljZSgxKS5yZWR1Y2UoKGFjYywgY29uZGl0aW9uKSA9PiBPcldoZXJlLmNvbWJpbmUoYWNjLCBjb25kaXRpb24pLCBjb25kaXRpb25zWzBdKTtcbiAgfVxuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZGF0YSk7XG4gIGlmIChlbnRyaWVzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldoZXJlIGRpY3Rpb25hcnkgbXVzdCBjb250YWluIGV4YWN0bHkgb25lIGZpZWxkXCIpO1xuICB9XG4gIGNvbnN0IFtmaWVsZCwgdmFsdWVdID0gZW50cmllc1swXTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgQ29tcGFyaXNvbldoZXJlKGZpZWxkLCBcIiRlcVwiLCB2YWx1ZSk7XG4gIH1cbiAgY29uc3Qgb3BlcmF0b3JFbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBpZiAob3BlcmF0b3JFbnRyaWVzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgT3BlcmF0b3IgZGljdGlvbmFyeSBmb3IgZmllbGQgXCIke2ZpZWxkfVwiIG11c3QgY29udGFpbiBleGFjdGx5IG9uZSBvcGVyYXRvcmApO1xuICB9XG4gIGNvbnN0IFtvcGVyYXRvciwgb3BlcmFuZF0gPSBvcGVyYXRvckVudHJpZXNbMF07XG4gIGNvbnN0IGZhY3RvcnkgPSBjb21wYXJpc29uT3BlcmF0b3JNYXAuZ2V0KG9wZXJhdG9yKTtcbiAgaWYgKCFmYWN0b3J5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB3aGVyZSBvcGVyYXRvcjogJHtvcGVyYXRvcn1gKTtcbiAgfVxuICByZXR1cm4gZmFjdG9yeShmaWVsZCwgb3BlcmFuZCk7XG59O1xudmFyIGNyZWF0ZUNvbXBhcmlzb25XaGVyZSA9IChrZXksIG9wZXJhdG9yLCB2YWx1ZSkgPT4gbmV3IENvbXBhcmlzb25XaGVyZShrZXksIG9wZXJhdG9yLCB2YWx1ZSk7XG5cbi8vIHNyYy9leGVjdXRpb24vZXhwcmVzc2lvbi9rZXkudHNcbnZhciBfS2V5ID0gY2xhc3MgX0tleSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG4gIGVxKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBhcmlzb25XaGVyZSh0aGlzLm5hbWUsIFwiJGVxXCIsIHZhbHVlKTtcbiAgfVxuICBuZSh2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVDb21wYXJpc29uV2hlcmUodGhpcy5uYW1lLCBcIiRuZVwiLCB2YWx1ZSk7XG4gIH1cbiAgZ3QodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29tcGFyaXNvbldoZXJlKHRoaXMubmFtZSwgXCIkZ3RcIiwgdmFsdWUpO1xuICB9XG4gIGd0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVDb21wYXJpc29uV2hlcmUodGhpcy5uYW1lLCBcIiRndGVcIiwgdmFsdWUpO1xuICB9XG4gIGx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBhcmlzb25XaGVyZSh0aGlzLm5hbWUsIFwiJGx0XCIsIHZhbHVlKTtcbiAgfVxuICBsdGUodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29tcGFyaXNvbldoZXJlKHRoaXMubmFtZSwgXCIkbHRlXCIsIHZhbHVlKTtcbiAgfVxuICBpc0luKHZhbHVlcykge1xuICAgIGNvbnN0IGFycmF5ID0gaXRlcmFibGVUb0FycmF5KHZhbHVlcyk7XG4gICAgYXNzZXJ0Tm9uRW1wdHlBcnJheShhcnJheSwgXCIkaW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHZhbHVlXCIpO1xuICAgIHJldHVybiBjcmVhdGVDb21wYXJpc29uV2hlcmUodGhpcy5uYW1lLCBcIiRpblwiLCBhcnJheSk7XG4gIH1cbiAgbm90SW4odmFsdWVzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBpdGVyYWJsZVRvQXJyYXkodmFsdWVzKTtcbiAgICBhc3NlcnROb25FbXB0eUFycmF5KGFycmF5LCBcIiRuaW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHZhbHVlXCIpO1xuICAgIHJldHVybiBjcmVhdGVDb21wYXJpc29uV2hlcmUodGhpcy5uYW1lLCBcIiRuaW5cIiwgYXJyYXkpO1xuICB9XG4gIGNvbnRhaW5zKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIiRjb250YWlucyByZXF1aXJlcyBhIHN0cmluZyB2YWx1ZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBhcmlzb25XaGVyZSh0aGlzLm5hbWUsIFwiJGNvbnRhaW5zXCIsIHZhbHVlKTtcbiAgfVxuICBub3RDb250YWlucyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCIkbm90X2NvbnRhaW5zIHJlcXVpcmVzIGEgc3RyaW5nIHZhbHVlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ29tcGFyaXNvbldoZXJlKHRoaXMubmFtZSwgXCIkbm90X2NvbnRhaW5zXCIsIHZhbHVlKTtcbiAgfVxuICByZWdleChwYXR0ZXJuKSB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJHJlZ2V4IHJlcXVpcmVzIGEgc3RyaW5nIHBhdHRlcm5cIik7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDb21wYXJpc29uV2hlcmUodGhpcy5uYW1lLCBcIiRyZWdleFwiLCBwYXR0ZXJuKTtcbiAgfVxuICBub3RSZWdleChwYXR0ZXJuKSB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJG5vdF9yZWdleCByZXF1aXJlcyBhIHN0cmluZyBwYXR0ZXJuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ29tcGFyaXNvbldoZXJlKHRoaXMubmFtZSwgXCIkbm90X3JlZ2V4XCIsIHBhdHRlcm4pO1xuICB9XG59O1xuX0tleS5JRCA9IG5ldyBfS2V5KFwiI2lkXCIpO1xuX0tleS5ET0NVTUVOVCA9IG5ldyBfS2V5KFwiI2RvY3VtZW50XCIpO1xuX0tleS5FTUJFRERJTkcgPSBuZXcgX0tleShcIiNlbWJlZGRpbmdcIik7XG5fS2V5Lk1FVEFEQVRBID0gbmV3IF9LZXkoXCIjbWV0YWRhdGFcIik7XG5fS2V5LlNDT1JFID0gbmV3IF9LZXkoXCIjc2NvcmVcIik7XG52YXIgS2V5ID0gX0tleTtcbnZhciBjcmVhdGVLZXlGYWN0b3J5ID0gKCkgPT4ge1xuICBjb25zdCBmYWN0b3J5ID0gKG5hbWUpID0+IG5ldyBLZXkobmFtZSk7XG4gIGZhY3RvcnkuSUQgPSBLZXkuSUQ7XG4gIGZhY3RvcnkuRE9DVU1FTlQgPSBLZXkuRE9DVU1FTlQ7XG4gIGZhY3RvcnkuRU1CRURESU5HID0gS2V5LkVNQkVERElORztcbiAgZmFjdG9yeS5NRVRBREFUQSA9IEtleS5NRVRBREFUQTtcbiAgZmFjdG9yeS5TQ09SRSA9IEtleS5TQ09SRTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xudmFyIEsgPSBjcmVhdGVLZXlGYWN0b3J5KCk7XG5cbi8vIHNyYy9leGVjdXRpb24vZXhwcmVzc2lvbi9saW1pdC50c1xudmFyIExpbWl0ID0gY2xhc3MgX0xpbWl0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBvZmZzZXQgPSAwLCBsaW1pdCB9ID0gb3B0aW9ucztcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob2Zmc2V0KSB8fCBvZmZzZXQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTGltaXQgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlclwiKTtcbiAgICB9XG4gICAgaWYgKGxpbWl0ICE9PSBudWxsICYmIGxpbWl0ICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsaW1pdCkgfHwgbGltaXQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgd2hlbiBwcm92aWRlZFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgICB9XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH1cbiAgc3RhdGljIGZyb20oaW5wdXQsIG9mZnNldE92ZXJyaWRlKSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgX0xpbWl0KSB7XG4gICAgICByZXR1cm4gbmV3IF9MaW1pdCh7IG9mZnNldDogaW5wdXQub2Zmc2V0LCBsaW1pdDogaW5wdXQubGltaXQgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBuZXcgX0xpbWl0KHsgbGltaXQ6IGlucHV0LCBvZmZzZXQ6IG9mZnNldE92ZXJyaWRlID8/IDAgfSk7XG4gICAgfVxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbmV3IF9MaW1pdCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gbmV3IF9MaW1pdChpbnB1dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGxpbWl0IGlucHV0XCIpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IG9mZnNldDogdGhpcy5vZmZzZXQgfTtcbiAgICBpZiAodGhpcy5saW1pdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXN1bHQubGltaXQgPSB0aGlzLmxpbWl0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyBzcmMvZXhlY3V0aW9uL2V4cHJlc3Npb24vc2VsZWN0LnRzXG52YXIgU2VsZWN0ID0gY2xhc3MgX1NlbGVjdCB7XG4gIGNvbnN0cnVjdG9yKGtleXMgPSBbXSkge1xuICAgIGNvbnN0IHVuaXF1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGtleSBpbnN0YW5jZW9mIEtleSA/IGtleS5uYW1lIDoga2V5O1xuICAgICAgaWYgKHR5cGVvZiBub3JtYWxpemVkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTZWxlY3Qga2V5cyBtdXN0IGJlIHN0cmluZ3Mgb3IgS2V5IGluc3RhbmNlc1wiKTtcbiAgICAgIH1cbiAgICAgIHVuaXF1ZS5hZGQobm9ybWFsaXplZCk7XG4gICAgfVxuICAgIHRoaXMua2V5cyA9IEFycmF5LmZyb20odW5pcXVlKTtcbiAgfVxuICBzdGF0aWMgZnJvbShpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIF9TZWxlY3QpIHtcbiAgICAgIHJldHVybiBuZXcgX1NlbGVjdChpbnB1dC5rZXlzKTtcbiAgICB9XG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBuZXcgX1NlbGVjdCgpO1xuICAgIH1cbiAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpbnB1dCkpIHtcbiAgICAgIHJldHVybiBuZXcgX1NlbGVjdChpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgXCJrZXlzXCIgaW4gaW5wdXQpIHtcbiAgICAgIGNvbnN0IHsga2V5cyB9ID0gaW5wdXQ7XG4gICAgICByZXR1cm4gbmV3IF9TZWxlY3Qoa2V5cyA/PyBbXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBzZWxlY3QgaW5wdXRcIik7XG4gIH1cbiAgc3RhdGljIGFsbCgpIHtcbiAgICByZXR1cm4gbmV3IF9TZWxlY3QoW0tleS5ET0NVTUVOVCwgS2V5LkVNQkVERElORywgS2V5Lk1FVEFEQVRBLCBLZXkuU0NPUkVdKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLmtleXMuc2xpY2UoKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsga2V5czogdGhpcy52YWx1ZXMgfTtcbiAgfVxufTtcblxuLy8gc3JjL2V4ZWN1dGlvbi9leHByZXNzaW9uL3JhbmsudHNcbnZhciByZXF1aXJlTnVtYmVyID0gKHZhbHVlLCBtZXNzYWdlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHwgTnVtYmVyLmlzTmFOKHZhbHVlKSB8fCAhTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBSYW5rRXhwcmVzc2lvbkJhc2UgPSBjbGFzcyB7XG4gIGFkZCguLi5vdGhlcnMpIHtcbiAgICBpZiAob3RoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW1xuICAgICAgdGhpcyxcbiAgICAgIC4uLm90aGVycy5tYXAoKGl0ZW0sIGluZGV4KSA9PiByZXF1aXJlUmFuayhpdGVtLCBgYWRkIG9wZXJhbmQgJHtpbmRleH1gKSlcbiAgICBdO1xuICAgIHJldHVybiBTdW1SYW5rRXhwcmVzc2lvbi5jcmVhdGUoZXhwcmVzc2lvbnMpO1xuICB9XG4gIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJSYW5rRXhwcmVzc2lvbihcbiAgICAgIHRoaXMsXG4gICAgICByZXF1aXJlUmFuayhvdGhlciwgXCJzdWJ0cmFjdCBvcGVyYW5kXCIpXG4gICAgKTtcbiAgfVxuICBtdWx0aXBseSguLi5vdGhlcnMpIHtcbiAgICBpZiAob3RoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW1xuICAgICAgdGhpcyxcbiAgICAgIC4uLm90aGVycy5tYXAoKGl0ZW0sIGluZGV4KSA9PiByZXF1aXJlUmFuayhpdGVtLCBgbXVsdGlwbHkgb3BlcmFuZCAke2luZGV4fWApKVxuICAgIF07XG4gICAgcmV0dXJuIE11bFJhbmtFeHByZXNzaW9uLmNyZWF0ZShleHByZXNzaW9ucyk7XG4gIH1cbiAgZGl2aWRlKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBEaXZSYW5rRXhwcmVzc2lvbihcbiAgICAgIHRoaXMsXG4gICAgICByZXF1aXJlUmFuayhvdGhlciwgXCJkaXZpZGUgb3BlcmFuZFwiKVxuICAgICk7XG4gIH1cbiAgbmVnYXRlKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5KC0xKTtcbiAgfVxuICBhYnMoKSB7XG4gICAgcmV0dXJuIG5ldyBBYnNSYW5rRXhwcmVzc2lvbih0aGlzKTtcbiAgfVxuICBleHAoKSB7XG4gICAgcmV0dXJuIG5ldyBFeHBSYW5rRXhwcmVzc2lvbih0aGlzKTtcbiAgfVxuICBsb2coKSB7XG4gICAgcmV0dXJuIG5ldyBMb2dSYW5rRXhwcmVzc2lvbih0aGlzKTtcbiAgfVxuICBtYXgoLi4ub3RoZXJzKSB7XG4gICAgaWYgKG90aGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBleHByZXNzaW9ucyA9IFtcbiAgICAgIHRoaXMsXG4gICAgICAuLi5vdGhlcnMubWFwKChpdGVtLCBpbmRleCkgPT4gcmVxdWlyZVJhbmsoaXRlbSwgYG1heCBvcGVyYW5kICR7aW5kZXh9YCkpXG4gICAgXTtcbiAgICByZXR1cm4gTWF4UmFua0V4cHJlc3Npb24uY3JlYXRlKGV4cHJlc3Npb25zKTtcbiAgfVxuICBtaW4oLi4ub3RoZXJzKSB7XG4gICAgaWYgKG90aGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBleHByZXNzaW9ucyA9IFtcbiAgICAgIHRoaXMsXG4gICAgICAuLi5vdGhlcnMubWFwKChpdGVtLCBpbmRleCkgPT4gcmVxdWlyZVJhbmsoaXRlbSwgYG1pbiBvcGVyYW5kICR7aW5kZXh9YCkpXG4gICAgXTtcbiAgICByZXR1cm4gTWluUmFua0V4cHJlc3Npb24uY3JlYXRlKGV4cHJlc3Npb25zKTtcbiAgfVxufTtcbnZhciBSYW5rRXhwcmVzc2lvbiA9IGNsYXNzIF9SYW5rRXhwcmVzc2lvbiBleHRlbmRzIFJhbmtFeHByZXNzaW9uQmFzZSB7XG4gIHN0YXRpYyBmcm9tKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgX1JhbmtFeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlUmFua0V4cHJlc3Npb24oaW5wdXQpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iamVjdChpbnB1dCkpIHtcbiAgICAgIHJldHVybiBuZXcgUmF3UmFua0V4cHJlc3Npb24oaW5wdXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmFuayBpbnB1dCBtdXN0IGJlIGEgUmFua0V4cHJlc3Npb24sIG51bWJlciwgb3IgcGxhaW4gb2JqZWN0XCIpO1xuICB9XG59O1xudmFyIFJhd1JhbmtFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBSYW5rRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHJhdykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yYXcgPSByYXc7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5yYXcpO1xuICB9XG59O1xudmFyIFZhbHVlUmFua0V4cHJlc3Npb24gPSBjbGFzcyBleHRlbmRzIFJhbmtFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsgJHZhbDogdGhpcy52YWx1ZSB9O1xuICB9XG59O1xudmFyIFN1bVJhbmtFeHByZXNzaW9uID0gY2xhc3MgX1N1bVJhbmtFeHByZXNzaW9uIGV4dGVuZHMgUmFua0V4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihyYW5rcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yYW5rcyA9IHJhbmtzO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUocmFua3MpIHtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJhbmsgb2YgcmFua3MpIHtcbiAgICAgIGlmIChyYW5rIGluc3RhbmNlb2YgX1N1bVJhbmtFeHByZXNzaW9uKSB7XG4gICAgICAgIGZsYXR0ZW5lZC5wdXNoKC4uLnJhbmsub3BlcmFuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdHRlbmVkLnB1c2gocmFuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbGF0dGVuZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9TdW1SYW5rRXhwcmVzc2lvbihmbGF0dGVuZWQpO1xuICB9XG4gIGdldCBvcGVyYW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5rcy5zbGljZSgpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4geyAkc3VtOiB0aGlzLnJhbmtzLm1hcCgocmFuaykgPT4gcmFuay50b0pTT04oKSkgfTtcbiAgfVxufTtcbnZhciBTdWJSYW5rRXhwcmVzc2lvbiA9IGNsYXNzIGV4dGVuZHMgUmFua0V4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAkc3ViOiB7XG4gICAgICAgIGxlZnQ6IHRoaXMubGVmdC50b0pTT04oKSxcbiAgICAgICAgcmlnaHQ6IHRoaXMucmlnaHQudG9KU09OKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIE11bFJhbmtFeHByZXNzaW9uID0gY2xhc3MgX011bFJhbmtFeHByZXNzaW9uIGV4dGVuZHMgUmFua0V4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihyYW5rcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yYW5rcyA9IHJhbmtzO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUocmFua3MpIHtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJhbmsgb2YgcmFua3MpIHtcbiAgICAgIGlmIChyYW5rIGluc3RhbmNlb2YgX011bFJhbmtFeHByZXNzaW9uKSB7XG4gICAgICAgIGZsYXR0ZW5lZC5wdXNoKC4uLnJhbmsub3BlcmFuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdHRlbmVkLnB1c2gocmFuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbGF0dGVuZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9NdWxSYW5rRXhwcmVzc2lvbihmbGF0dGVuZWQpO1xuICB9XG4gIGdldCBvcGVyYW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5rcy5zbGljZSgpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4geyAkbXVsOiB0aGlzLnJhbmtzLm1hcCgocmFuaykgPT4gcmFuay50b0pTT04oKSkgfTtcbiAgfVxufTtcbnZhciBEaXZSYW5rRXhwcmVzc2lvbiA9IGNsYXNzIGV4dGVuZHMgUmFua0V4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAkZGl2OiB7XG4gICAgICAgIGxlZnQ6IHRoaXMubGVmdC50b0pTT04oKSxcbiAgICAgICAgcmlnaHQ6IHRoaXMucmlnaHQudG9KU09OKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIEFic1JhbmtFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBSYW5rRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKG9wZXJhbmQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7ICRhYnM6IHRoaXMub3BlcmFuZC50b0pTT04oKSB9O1xuICB9XG59O1xudmFyIEV4cFJhbmtFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBSYW5rRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKG9wZXJhbmQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7ICRleHA6IHRoaXMub3BlcmFuZC50b0pTT04oKSB9O1xuICB9XG59O1xudmFyIExvZ1JhbmtFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBSYW5rRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKG9wZXJhbmQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7ICRsb2c6IHRoaXMub3BlcmFuZC50b0pTT04oKSB9O1xuICB9XG59O1xudmFyIE1heFJhbmtFeHByZXNzaW9uID0gY2xhc3MgX01heFJhbmtFeHByZXNzaW9uIGV4dGVuZHMgUmFua0V4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihyYW5rcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yYW5rcyA9IHJhbmtzO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUocmFua3MpIHtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJhbmsgb2YgcmFua3MpIHtcbiAgICAgIGlmIChyYW5rIGluc3RhbmNlb2YgX01heFJhbmtFeHByZXNzaW9uKSB7XG4gICAgICAgIGZsYXR0ZW5lZC5wdXNoKC4uLnJhbmsub3BlcmFuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdHRlbmVkLnB1c2gocmFuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbGF0dGVuZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9NYXhSYW5rRXhwcmVzc2lvbihmbGF0dGVuZWQpO1xuICB9XG4gIGdldCBvcGVyYW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5rcy5zbGljZSgpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4geyAkbWF4OiB0aGlzLnJhbmtzLm1hcCgocmFuaykgPT4gcmFuay50b0pTT04oKSkgfTtcbiAgfVxufTtcbnZhciBNaW5SYW5rRXhwcmVzc2lvbiA9IGNsYXNzIF9NaW5SYW5rRXhwcmVzc2lvbiBleHRlbmRzIFJhbmtFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocmFua3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmFua3MgPSByYW5rcztcbiAgfVxuICBzdGF0aWMgY3JlYXRlKHJhbmtzKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkID0gW107XG4gICAgZm9yIChjb25zdCByYW5rIG9mIHJhbmtzKSB7XG4gICAgICBpZiAocmFuayBpbnN0YW5jZW9mIF9NaW5SYW5rRXhwcmVzc2lvbikge1xuICAgICAgICBmbGF0dGVuZWQucHVzaCguLi5yYW5rLm9wZXJhbmRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXR0ZW5lZC5wdXNoKHJhbmspO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmxhdHRlbmVkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZsYXR0ZW5lZFswXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTWluUmFua0V4cHJlc3Npb24oZmxhdHRlbmVkKTtcbiAgfVxuICBnZXQgb3BlcmFuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFua3Muc2xpY2UoKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsgJG1pbjogdGhpcy5yYW5rcy5tYXAoKHJhbmspID0+IHJhbmsudG9KU09OKCkpIH07XG4gIH1cbn07XG52YXIgS25uUmFua0V4cHJlc3Npb24gPSBjbGFzcyBleHRlbmRzIFJhbmtFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgYmFzZSA9IHtcbiAgICAgIHF1ZXJ5OiB0aGlzLmNvbmZpZy5xdWVyeSxcbiAgICAgIGtleTogdGhpcy5jb25maWcua2V5LFxuICAgICAgbGltaXQ6IHRoaXMuY29uZmlnLmxpbWl0XG4gICAgfTtcbiAgICBpZiAodGhpcy5jb25maWcuZGVmYXVsdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIGJhc2UuZGVmYXVsdCA9IHRoaXMuY29uZmlnLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLnJldHVyblJhbmspIHtcbiAgICAgIGJhc2UucmV0dXJuX3JhbmsgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geyAka25uOiBiYXNlIH07XG4gIH1cbn07XG52YXIgbm9ybWFsaXplRGVuc2VWZWN0b3IgPSAodmVjdG9yKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZlY3RvcikpIHtcbiAgICByZXR1cm4gdmVjdG9yLnNsaWNlKCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20odmVjdG9yLCAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IE51bWJlci5pc05hTih2YWx1ZSkgfHwgIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZW5zZSBxdWVyeSB2ZWN0b3IgdmFsdWVzIG11c3QgYmUgZmluaXRlIG51bWJlcnNcIik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59O1xudmFyIG5vcm1hbGl6ZUtubk9wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXQgPz8gMTI4O1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobGltaXQpIHx8IGxpbWl0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiS25uIGxpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG4gIGNvbnN0IHF1ZXJ5SW5wdXQgPSBvcHRpb25zLnF1ZXJ5O1xuICBsZXQgcXVlcnk7XG4gIGlmICh0eXBlb2YgcXVlcnlJbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHF1ZXJ5ID0gcXVlcnlJbnB1dDtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHF1ZXJ5SW5wdXQpICYmIEFycmF5LmlzQXJyYXkocXVlcnlJbnB1dC5pbmRpY2VzKSAmJiBBcnJheS5pc0FycmF5KHF1ZXJ5SW5wdXQudmFsdWVzKSkge1xuICAgIGNvbnN0IHNwYXJzZSA9IHF1ZXJ5SW5wdXQ7XG4gICAgcXVlcnkgPSB7XG4gICAgICBpbmRpY2VzOiBzcGFyc2UuaW5kaWNlcy5zbGljZSgpLFxuICAgICAgdmFsdWVzOiBzcGFyc2UudmFsdWVzLnNsaWNlKClcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHF1ZXJ5ID0gbm9ybWFsaXplRGVuc2VWZWN0b3IocXVlcnlJbnB1dCk7XG4gIH1cbiAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXkgaW5zdGFuY2VvZiBLZXkgPyBvcHRpb25zLmtleS5uYW1lIDogb3B0aW9ucy5rZXkgPz8gXCIjZW1iZWRkaW5nXCI7XG4gIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIktubiBrZXkgbXVzdCBiZSBhIHN0cmluZyBvciBLZXkgaW5zdGFuY2VcIik7XG4gIH1cbiAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0aW9ucy5kZWZhdWx0ID09PSBudWxsIHx8IG9wdGlvbnMuZGVmYXVsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVxdWlyZU51bWJlcihvcHRpb25zLmRlZmF1bHQsIFwiS25uIGRlZmF1bHQgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwICYmICFOdW1iZXIuaXNGaW5pdGUoZGVmYXVsdFZhbHVlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJLbm4gZGVmYXVsdCBtdXN0IGJlIGEgZmluaXRlIG51bWJlclwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHF1ZXJ5OiBBcnJheS5pc0FycmF5KHF1ZXJ5KSB8fCB0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIgPyBxdWVyeSA6IGRlZXBDbG9uZShxdWVyeSksXG4gICAga2V5LFxuICAgIGxpbWl0LFxuICAgIGRlZmF1bHRWYWx1ZSxcbiAgICByZXR1cm5SYW5rOiBvcHRpb25zLnJldHVyblJhbmsgPz8gZmFsc2VcbiAgfTtcbn07XG52YXIgcmVxdWlyZVJhbmsgPSAoaW5wdXQsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gUmFua0V4cHJlc3Npb24uZnJvbShpbnB1dCk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBtdXN0IGJlIGEgcmFuayBleHByZXNzaW9uYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgVmFsID0gKHZhbHVlKSA9PiBuZXcgVmFsdWVSYW5rRXhwcmVzc2lvbihyZXF1aXJlTnVtYmVyKHZhbHVlLCBcIlZhbCByZXF1aXJlcyBhIG51bWVyaWMgdmFsdWVcIikpO1xudmFyIEtubiA9IChvcHRpb25zKSA9PiBuZXcgS25uUmFua0V4cHJlc3Npb24obm9ybWFsaXplS25uT3B0aW9ucyhvcHRpb25zKSk7XG52YXIgUnJmID0gKHsgcmFua3MsIGsgPSA2MCwgd2VpZ2h0cywgbm9ybWFsaXplID0gZmFsc2UgfSkgPT4ge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoaykgfHwgayA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJyZiBrIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShyYW5rcykgfHwgcmFua3MubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJyZiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgcmFuayBleHByZXNzaW9uXCIpO1xuICB9XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gcmFua3MubWFwKChyYW5rLCBpbmRleCkgPT4gcmVxdWlyZVJhbmsocmFuaywgYHJhbmtzWyR7aW5kZXh9XWApKTtcbiAgbGV0IHdlaWdodFZhbHVlcyA9IHdlaWdodHMgPyB3ZWlnaHRzLnNsaWNlKCkgOiBuZXcgQXJyYXkoZXhwcmVzc2lvbnMubGVuZ3RoKS5maWxsKDEpO1xuICBpZiAod2VpZ2h0VmFsdWVzLmxlbmd0aCAhPT0gZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIG9mIHdlaWdodHMgbXVzdCBtYXRjaCBudW1iZXIgb2YgcmFua3NcIik7XG4gIH1cbiAgaWYgKHdlaWdodFZhbHVlcy5zb21lKCh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiV2VpZ2h0cyBtdXN0IGJlIG5vbi1uZWdhdGl2ZSBudW1iZXJzXCIpO1xuICB9XG4gIGlmIChub3JtYWxpemUpIHtcbiAgICBjb25zdCB0b3RhbCA9IHdlaWdodFZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlLCAwKTtcbiAgICBpZiAodG90YWwgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0cyBtdXN0IHN1bSB0byBhIHBvc2l0aXZlIHZhbHVlIHdoZW4gbm9ybWFsaXplPXRydWVcIik7XG4gICAgfVxuICAgIHdlaWdodFZhbHVlcyA9IHdlaWdodFZhbHVlcy5tYXAoKHZhbHVlKSA9PiB2YWx1ZSAvIHRvdGFsKTtcbiAgfVxuICBjb25zdCB0ZXJtcyA9IGV4cHJlc3Npb25zLm1hcCgocmFuaywgaW5kZXgpID0+IHtcbiAgICBjb25zdCB3ZWlnaHQgPSB3ZWlnaHRWYWx1ZXNbaW5kZXhdO1xuICAgIGNvbnN0IG51bWVyYXRvciA9IFZhbCh3ZWlnaHQpO1xuICAgIGNvbnN0IGRlbm9taW5hdG9yID0gcmFuay5hZGQoayk7XG4gICAgcmV0dXJuIG51bWVyYXRvci5kaXZpZGUoZGVub21pbmF0b3IpO1xuICB9KTtcbiAgY29uc3QgZnVzZWQgPSB0ZXJtcy5yZWR1Y2UoKGFjYywgdGVybSkgPT4gYWNjLmFkZCh0ZXJtKSk7XG4gIHJldHVybiBmdXNlZC5uZWdhdGUoKTtcbn07XG52YXIgU3VtID0gKC4uLmlucHV0cykgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN1bSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgcmFuayBleHByZXNzaW9uXCIpO1xuICB9XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gaW5wdXRzLm1hcCgocmFuaywgaW5kZXgpID0+IHJlcXVpcmVSYW5rKHJhbmssIGBTdW0gb3BlcmFuZCAke2luZGV4fWApKTtcbiAgcmV0dXJuIFN1bVJhbmtFeHByZXNzaW9uLmNyZWF0ZShleHByZXNzaW9ucyk7XG59O1xudmFyIFN1YiA9IChsZWZ0LCByaWdodCkgPT4gbmV3IFN1YlJhbmtFeHByZXNzaW9uKHJlcXVpcmVSYW5rKGxlZnQsIFwiU3ViIGxlZnRcIiksIHJlcXVpcmVSYW5rKHJpZ2h0LCBcIlN1YiByaWdodFwiKSk7XG52YXIgTXVsID0gKC4uLmlucHV0cykgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk11bCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgcmFuayBleHByZXNzaW9uXCIpO1xuICB9XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gaW5wdXRzLm1hcCgocmFuaywgaW5kZXgpID0+IHJlcXVpcmVSYW5rKHJhbmssIGBNdWwgb3BlcmFuZCAke2luZGV4fWApKTtcbiAgcmV0dXJuIE11bFJhbmtFeHByZXNzaW9uLmNyZWF0ZShleHByZXNzaW9ucyk7XG59O1xudmFyIERpdiA9IChsZWZ0LCByaWdodCkgPT4gbmV3IERpdlJhbmtFeHByZXNzaW9uKHJlcXVpcmVSYW5rKGxlZnQsIFwiRGl2IGxlZnRcIiksIHJlcXVpcmVSYW5rKHJpZ2h0LCBcIkRpdiByaWdodFwiKSk7XG52YXIgQWJzID0gKGlucHV0KSA9PiByZXF1aXJlUmFuayhpbnB1dCwgXCJBYnNcIikuYWJzKCk7XG52YXIgRXhwID0gKGlucHV0KSA9PiByZXF1aXJlUmFuayhpbnB1dCwgXCJFeHBcIikuZXhwKCk7XG52YXIgTG9nID0gKGlucHV0KSA9PiByZXF1aXJlUmFuayhpbnB1dCwgXCJMb2dcIikubG9nKCk7XG52YXIgTWF4ID0gKC4uLmlucHV0cykgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1heCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgcmFuayBleHByZXNzaW9uXCIpO1xuICB9XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gaW5wdXRzLm1hcCgocmFuaywgaW5kZXgpID0+IHJlcXVpcmVSYW5rKHJhbmssIGBNYXggb3BlcmFuZCAke2luZGV4fWApKTtcbiAgcmV0dXJuIE1heFJhbmtFeHByZXNzaW9uLmNyZWF0ZShleHByZXNzaW9ucyk7XG59O1xudmFyIE1pbiA9ICguLi5pbnB1dHMpID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHJhbmsgZXhwcmVzc2lvblwiKTtcbiAgfVxuICBjb25zdCBleHByZXNzaW9ucyA9IGlucHV0cy5tYXAoKHJhbmssIGluZGV4KSA9PiByZXF1aXJlUmFuayhyYW5rLCBgTWluIG9wZXJhbmQgJHtpbmRleH1gKSk7XG4gIHJldHVybiBNaW5SYW5rRXhwcmVzc2lvbi5jcmVhdGUoZXhwcmVzc2lvbnMpO1xufTtcblxuLy8gc3JjL2V4ZWN1dGlvbi9leHByZXNzaW9uL2dyb3VwQnkudHNcbnZhciBBZ2dyZWdhdGUgPSBjbGFzcyBfQWdncmVnYXRlIHtcbiAgc3RhdGljIGZyb20oaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBfQWdncmVnYXRlKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KGlucHV0KSkge1xuICAgICAgaWYgKFwiJG1pbl9rXCIgaW4gaW5wdXQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGlucHV0LiRtaW5faztcbiAgICAgICAgcmV0dXJuIG5ldyBNaW5LKFxuICAgICAgICAgIGRhdGEua2V5cy5tYXAoKGspID0+IG5ldyBLZXkoaykpLFxuICAgICAgICAgIGRhdGEua1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwiJG1heF9rXCIgaW4gaW5wdXQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGlucHV0LiRtYXhfaztcbiAgICAgICAgcmV0dXJuIG5ldyBNYXhLKFxuICAgICAgICAgIGRhdGEua2V5cy5tYXAoKGspID0+IG5ldyBLZXkoaykpLFxuICAgICAgICAgIGRhdGEua1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJBZ2dyZWdhdGUgaW5wdXQgbXVzdCBiZSBhbiBBZ2dyZWdhdGUgaW5zdGFuY2Ugb3Igb2JqZWN0IHdpdGggJG1pbl9rIG9yICRtYXhfa1wiXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgbWluSyhrZXlzLCBrKSB7XG4gICAgcmV0dXJuIG5ldyBNaW5LKFxuICAgICAga2V5cy5tYXAoKGtleSkgPT4ga2V5IGluc3RhbmNlb2YgS2V5ID8ga2V5IDogbmV3IEtleShrZXkpKSxcbiAgICAgIGtcbiAgICApO1xuICB9XG4gIHN0YXRpYyBtYXhLKGtleXMsIGspIHtcbiAgICByZXR1cm4gbmV3IE1heEsoXG4gICAgICBrZXlzLm1hcCgoa2V5KSA9PiBrZXkgaW5zdGFuY2VvZiBLZXkgPyBrZXkgOiBuZXcgS2V5KGtleSkpLFxuICAgICAga1xuICAgICk7XG4gIH1cbn07XG52YXIgTWluSyA9IGNsYXNzIGV4dGVuZHMgQWdncmVnYXRlIHtcbiAgY29uc3RydWN0b3Ioa2V5cywgaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLmsgPSBrO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWluSyBrZXlzIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgaWYgKGsgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWluSyBrIG11c3QgYmUgcG9zaXRpdmVcIik7XG4gICAgfVxuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJG1pbl9rOiB7XG4gICAgICAgIGtleXM6IHRoaXMua2V5cy5tYXAoKGtleSkgPT4ga2V5Lm5hbWUpLFxuICAgICAgICBrOiB0aGlzLmtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIE1heEsgPSBjbGFzcyBleHRlbmRzIEFnZ3JlZ2F0ZSB7XG4gIGNvbnN0cnVjdG9yKGtleXMsIGspIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgdGhpcy5rID0gaztcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1heEsga2V5cyBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIGlmIChrIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1heEsgayBtdXN0IGJlIHBvc2l0aXZlXCIpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICRtYXhfazoge1xuICAgICAgICBrZXlzOiB0aGlzLmtleXMubWFwKChrZXkpID0+IGtleS5uYW1lKSxcbiAgICAgICAgazogdGhpcy5rXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBHcm91cEJ5ID0gY2xhc3MgX0dyb3VwQnkge1xuICBjb25zdHJ1Y3RvcihrZXlzLCBhZ2dyZWdhdGUpIHtcbiAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgIHRoaXMuYWdncmVnYXRlID0gYWdncmVnYXRlO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JvdXBCeSBrZXlzIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb20oaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IHZvaWQgMCB8fCBpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgX0dyb3VwQnkpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoaW5wdXQpKSB7XG4gICAgICBjb25zdCBkYXRhID0gaW5wdXQ7XG4gICAgICBpZiAoIWRhdGEua2V5cyB8fCAhQXJyYXkuaXNBcnJheShkYXRhLmtleXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHcm91cEJ5IHJlcXVpcmVzICdrZXlzJyBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YS5hZ2dyZWdhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyb3VwQnkgcmVxdWlyZXMgJ2FnZ3JlZ2F0ZSdcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IF9Hcm91cEJ5KFxuICAgICAgICBkYXRhLmtleXMubWFwKChrKSA9PiBuZXcgS2V5KGspKSxcbiAgICAgICAgQWdncmVnYXRlLmZyb20oZGF0YS5hZ2dyZWdhdGUpXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR3JvdXBCeSBpbnB1dCBtdXN0IGJlIGEgR3JvdXBCeSBpbnN0YW5jZSBvciBwbGFpbiBvYmplY3RcIik7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMubWFwKChrZXkpID0+IGtleS5uYW1lKSxcbiAgICAgIGFnZ3JlZ2F0ZTogdGhpcy5hZ2dyZWdhdGUudG9KU09OKClcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvZXhlY3V0aW9uL2V4cHJlc3Npb24vc2VhcmNoLnRzXG52YXIgU2VhcmNoID0gY2xhc3MgX1NlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKGluaXQgPSB7fSkge1xuICAgIHRoaXMuX3doZXJlID0gaW5pdC53aGVyZSA/IFdoZXJlRXhwcmVzc2lvbi5mcm9tKGluaXQud2hlcmUpIDogdm9pZCAwO1xuICAgIHRoaXMuX3JhbmsgPSBpbml0LnJhbmsgPyBSYW5rRXhwcmVzc2lvbi5mcm9tKGluaXQucmFuaykgOiB2b2lkIDA7XG4gICAgdGhpcy5fZ3JvdXBCeSA9IGluaXQuZ3JvdXBCeSA/IEdyb3VwQnkuZnJvbShpbml0Lmdyb3VwQnkpIDogdm9pZCAwO1xuICAgIHRoaXMuX2xpbWl0ID0gTGltaXQuZnJvbShpbml0LmxpbWl0ID8/IHZvaWQgMCk7XG4gICAgdGhpcy5fc2VsZWN0ID0gU2VsZWN0LmZyb20oaW5pdC5zZWxlY3QgPz8gdm9pZCAwKTtcbiAgfVxuICBjbG9uZShvdmVycmlkZXMpIHtcbiAgICBjb25zdCBuZXh0ID0gT2JqZWN0LmNyZWF0ZShfU2VhcmNoLnByb3RvdHlwZSk7XG4gICAgbmV4dC5fd2hlcmUgPSBvdmVycmlkZXMud2hlcmUgPz8gdGhpcy5fd2hlcmU7XG4gICAgbmV4dC5fcmFuayA9IG92ZXJyaWRlcy5yYW5rID8/IHRoaXMuX3Jhbms7XG4gICAgbmV4dC5fZ3JvdXBCeSA9IG92ZXJyaWRlcy5ncm91cEJ5ID8/IHRoaXMuX2dyb3VwQnk7XG4gICAgbmV4dC5fbGltaXQgPSBvdmVycmlkZXMubGltaXQgPz8gdGhpcy5fbGltaXQ7XG4gICAgbmV4dC5fc2VsZWN0ID0gb3ZlcnJpZGVzLnNlbGVjdCA/PyB0aGlzLl9zZWxlY3Q7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgd2hlcmUod2hlcmUpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IHdoZXJlOiBXaGVyZUV4cHJlc3Npb24uZnJvbSh3aGVyZSkgfSk7XG4gIH1cbiAgcmFuayhyYW5rKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyByYW5rOiBSYW5rRXhwcmVzc2lvbi5mcm9tKHJhbmsgPz8gdm9pZCAwKSB9KTtcbiAgfVxuICBncm91cEJ5KGdyb3VwQnkpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IGdyb3VwQnk6IEdyb3VwQnkuZnJvbShncm91cEJ5KSB9KTtcbiAgfVxuICBsaW1pdChsaW1pdCwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiBsaW1pdCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoeyBsaW1pdDogTGltaXQuZnJvbShsaW1pdCwgb2Zmc2V0KSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyBsaW1pdDogTGltaXQuZnJvbShsaW1pdCA/PyB2b2lkIDApIH0pO1xuICB9XG4gIHNlbGVjdChmaXJzdCwgLi4ucmVzdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpcnN0KSB8fCBmaXJzdCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoe1xuICAgICAgICBzZWxlY3Q6IFNlbGVjdC5mcm9tKGZpcnN0KVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIFNlbGVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoeyBzZWxlY3Q6IFNlbGVjdC5mcm9tKGZpcnN0KSB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJvYmplY3RcIiAmJiBmaXJzdCAhPT0gbnVsbCAmJiBcImtleXNcIiBpbiBmaXJzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoeyBzZWxlY3Q6IFNlbGVjdC5mcm9tKGZpcnN0KSB9KTtcbiAgICB9XG4gICAgY29uc3QgYWxsS2V5cyA9IFtdO1xuICAgIGlmIChmaXJzdCAhPT0gdm9pZCAwKSB7XG4gICAgICBhbGxLZXlzLnB1c2goZmlyc3QpO1xuICAgIH1cbiAgICBpZiAocmVzdC5sZW5ndGgpIHtcbiAgICAgIGFsbEtleXMucHVzaCguLi5yZXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyBzZWxlY3Q6IFNlbGVjdC5mcm9tKGFsbEtleXMpIH0pO1xuICB9XG4gIHNlbGVjdEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IHNlbGVjdDogU2VsZWN0LmFsbCgpIH0pO1xuICB9XG4gIGdldCB3aGVyZUNsYXVzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2hlcmU7XG4gIH1cbiAgZ2V0IHJhbmtFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5rO1xuICB9XG4gIGdldCBncm91cEJ5Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cEJ5O1xuICB9XG4gIGdldCBsaW1pdENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGltaXQ7XG4gIH1cbiAgZ2V0IHNlbGVjdENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0O1xuICB9XG4gIHRvUGF5bG9hZCgpIHtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgbGltaXQ6IHRoaXMuX2xpbWl0LnRvSlNPTigpLFxuICAgICAgc2VsZWN0OiB0aGlzLl9zZWxlY3QudG9KU09OKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl93aGVyZSkge1xuICAgICAgcGF5bG9hZC5maWx0ZXIgPSB0aGlzLl93aGVyZS50b0pTT04oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JhbmspIHtcbiAgICAgIHBheWxvYWQucmFuayA9IHRoaXMuX3JhbmsudG9KU09OKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9ncm91cEJ5KSB7XG4gICAgICBwYXlsb2FkLmdyb3VwX2J5ID0gdGhpcy5fZ3JvdXBCeS50b0pTT04oKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH1cbn07XG52YXIgdG9TZWFyY2ggPSAoaW5wdXQpID0+IGlucHV0IGluc3RhbmNlb2YgU2VhcmNoID8gaW5wdXQgOiBuZXcgU2VhcmNoKGlucHV0KTtcblxuLy8gc3JjL2V4ZWN1dGlvbi9leHByZXNzaW9uL3NlYXJjaFJlc3VsdC50c1xudmFyIG5vcm1hbGl6ZVBheWxvYWRBcnJheSA9IChwYXlsb2FkLCBjb3VudCkgPT4ge1xuICBpZiAoIXBheWxvYWQpIHtcbiAgICByZXR1cm4gQXJyYXkoY291bnQpLmZpbGwobnVsbCk7XG4gIH1cbiAgaWYgKHBheWxvYWQubGVuZ3RoID09PSBjb3VudCkge1xuICAgIHJldHVybiBwYXlsb2FkLm1hcCgoaXRlbSkgPT4gaXRlbSA/IGl0ZW0uc2xpY2UoKSA6IG51bGwpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHBheWxvYWQubWFwKChpdGVtKSA9PiBpdGVtID8gaXRlbS5zbGljZSgpIDogbnVsbCk7XG4gIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgY291bnQpIHtcbiAgICByZXN1bHQucHVzaChudWxsKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBTZWFyY2hSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgdGhpcy5pZHMgPSByZXNwb25zZS5pZHM7XG4gICAgY29uc3QgcGF5bG9hZENvdW50ID0gdGhpcy5pZHMubGVuZ3RoO1xuICAgIHRoaXMuZG9jdW1lbnRzID0gbm9ybWFsaXplUGF5bG9hZEFycmF5KHJlc3BvbnNlLmRvY3VtZW50cywgcGF5bG9hZENvdW50KTtcbiAgICB0aGlzLmVtYmVkZGluZ3MgPSBub3JtYWxpemVQYXlsb2FkQXJyYXkocmVzcG9uc2UuZW1iZWRkaW5ncywgcGF5bG9hZENvdW50KTtcbiAgICBjb25zdCByYXdNZXRhZGF0YXMgPSBub3JtYWxpemVQYXlsb2FkQXJyYXkocmVzcG9uc2UubWV0YWRhdGFzLCBwYXlsb2FkQ291bnQpO1xuICAgIHRoaXMubWV0YWRhdGFzID0gcmF3TWV0YWRhdGFzLm1hcCgocGF5bG9hZCkgPT4ge1xuICAgICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2VyaWFsaXplTWV0YWRhdGFzKHBheWxvYWQpID8/IFtdO1xuICAgIH0pO1xuICAgIHRoaXMuc2NvcmVzID0gbm9ybWFsaXplUGF5bG9hZEFycmF5KHJlc3BvbnNlLnNjb3JlcywgcGF5bG9hZENvdW50KTtcbiAgICB0aGlzLnNlbGVjdCA9IHJlc3BvbnNlLnNlbGVjdCA/PyBbXTtcbiAgfVxuICByb3dzKCkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBwYXlsb2FkSW5kZXggPSAwOyBwYXlsb2FkSW5kZXggPCB0aGlzLmlkcy5sZW5ndGg7IHBheWxvYWRJbmRleCArPSAxKSB7XG4gICAgICBjb25zdCBpZHMgPSB0aGlzLmlkc1twYXlsb2FkSW5kZXhdO1xuICAgICAgY29uc3QgZG9jUGF5bG9hZCA9IHRoaXMuZG9jdW1lbnRzW3BheWxvYWRJbmRleF0gPz8gW107XG4gICAgICBjb25zdCBlbWJlZFBheWxvYWQgPSB0aGlzLmVtYmVkZGluZ3NbcGF5bG9hZEluZGV4XSA/PyBbXTtcbiAgICAgIGNvbnN0IG1ldGFQYXlsb2FkID0gdGhpcy5tZXRhZGF0YXNbcGF5bG9hZEluZGV4XSA/PyBbXTtcbiAgICAgIGNvbnN0IHNjb3JlUGF5bG9hZCA9IHRoaXMuc2NvcmVzW3BheWxvYWRJbmRleF0gPz8gW107XG4gICAgICBjb25zdCByb3dzID0gaWRzLm1hcCgoaWQsIHJvd0luZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHsgaWQgfTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBkb2NQYXlsb2FkW3Jvd0luZGV4XTtcbiAgICAgICAgaWYgKGRvY3VtZW50ICE9PSB2b2lkIDAgJiYgZG9jdW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICByb3cuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWJlZGRpbmcgPSBlbWJlZFBheWxvYWRbcm93SW5kZXhdO1xuICAgICAgICBpZiAoZW1iZWRkaW5nICE9PSB2b2lkIDAgJiYgZW1iZWRkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgcm93LmVtYmVkZGluZyA9IGVtYmVkZGluZztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFQYXlsb2FkW3Jvd0luZGV4XTtcbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB2b2lkIDAgJiYgbWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICByb3cubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY29yZSA9IHNjb3JlUGF5bG9hZFtyb3dJbmRleF07XG4gICAgICAgIGlmIChzY29yZSAhPT0gdm9pZCAwICYmIHNjb3JlICE9PSBudWxsKSB7XG4gICAgICAgICAgcm93LnNjb3JlID0gc2NvcmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0cy5wdXNoKHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufTtcblxuLy8gc3JjL3NjaGVtYS50c1xudmFyIERPQ1VNRU5UX0tFWSA9IFwiI2RvY3VtZW50XCI7XG52YXIgRU1CRURESU5HX0tFWSA9IFwiI2VtYmVkZGluZ1wiO1xudmFyIENtZWtQcm92aWRlciA9IC8qIEBfX1BVUkVfXyAqLyAoKENtZWtQcm92aWRlcjIpID0+IHtcbiAgQ21la1Byb3ZpZGVyMltcIkdDUFwiXSA9IFwiZ2NwXCI7XG4gIHJldHVybiBDbWVrUHJvdmlkZXIyO1xufSkoQ21la1Byb3ZpZGVyIHx8IHt9KTtcbnZhciBfQ21layA9IGNsYXNzIF9DbWVrIHtcbiAgY29uc3RydWN0b3IocHJvdmlkZXIsIHJlc291cmNlKSB7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgQ01FSyBpbnN0YW5jZSBmb3IgR29vZ2xlIENsb3VkIFBsYXRmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0gcmVzb3VyY2UgLSBHQ1AgQ2xvdWQgS01TIHJlc291cmNlIG5hbWUgaW4gdGhlIGZvcm1hdDpcbiAgICogICBwcm9qZWN0cy97cHJvamVjdC1pZH0vbG9jYXRpb25zL3tsb2NhdGlvbn0va2V5UmluZ3Mve2tleS1yaW5nfS9jcnlwdG9LZXlzL3trZXktbmFtZX1cbiAgICpcbiAgICogQHJldHVybnMgQSBuZXcgQ01FSyBpbnN0YW5jZSBjb25maWd1cmVkIGZvciBHQ1BcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjbWVrID0gQ21lay5nY3AoXG4gICAqICAgXCJwcm9qZWN0cy9teS1wcm9qZWN0L2xvY2F0aW9ucy91cy1jZW50cmFsMS9rZXlSaW5ncy9teS1yaW5nL2NyeXB0b0tleXMvbXkta2V5XCJcbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZ2NwKHJlc291cmNlKSB7XG4gICAgcmV0dXJuIG5ldyBfQ21layhcImdjcFwiIC8qIEdDUCAqLywgcmVzb3VyY2UpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgQ01FSyByZXNvdXJjZSBuYW1lIGZvcm1hdC5cbiAgICpcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHJlc291cmNlIG5hbWUgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgcGF0dGVybiBmb3IgdGhlXG4gICAqIHByb3ZpZGVyLiBUaGlzIGlzIGEgZm9ybWF0IGNoZWNrIG9ubHkgYW5kIGRvZXMgbm90IHZlcmlmeSB0aGF0IHRoZSBrZXlcbiAgICogZXhpc3RzIG9yIHRoYXQgeW91IGhhdmUgYWNjZXNzIHRvIGl0LlxuICAgKlxuICAgKiBGb3IgR0NQLCB0aGUgZXhwZWN0ZWQgZm9ybWF0IGlzOlxuICAgKiAgIHByb2plY3RzL3twcm9qZWN0fS9sb2NhdGlvbnMve2xvY2F0aW9ufS9rZXlSaW5ncy97a2V5UmluZ30vY3J5cHRvS2V5cy97Y3J5cHRvS2V5fVxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSByZXNvdXJjZSBuYW1lIGZvcm1hdCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY21layA9IENtZWsuZ2NwKFwicHJvamVjdHMvcC9sb2NhdGlvbnMvbC9rZXlSaW5ncy9yL2NyeXB0b0tleXMva1wiKTtcbiAgICogY21lay52YWxpZGF0ZVBhdHRlcm4oKTsgLy8gUmV0dXJucyB0cnVlXG4gICAqXG4gICAqIGNvbnN0IGJhZENtZWsgPSBDbWVrLmdjcChcImludmFsaWQtZm9ybWF0XCIpO1xuICAgKiBiYWRDbWVrLnZhbGlkYXRlUGF0dGVybigpOyAvLyBSZXR1cm5zIGZhbHNlXG4gICAqIGBgYFxuICAgKi9cbiAgdmFsaWRhdGVQYXR0ZXJuKCkge1xuICAgIGlmICh0aGlzLnByb3ZpZGVyID09PSBcImdjcFwiIC8qIEdDUCAqLykge1xuICAgICAgcmV0dXJuIF9DbWVrLkdDUF9QQVRURVJOLnRlc3QodGhpcy5yZXNvdXJjZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIENNRUsgdG8gb2JqZWN0IGZvcm1hdCBmb3IgQVBJIHRyYW5zcG9ydC5cbiAgICpcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZXIgdmFyaWFudCBhcyB0aGUga2V5IGFuZCByZXNvdXJjZSBhcyB0aGUgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm5zIE9iamVjdCBjb250YWluaW5nIHRoZSBwcm92aWRlciB2YXJpYW50IGFuZCByZXNvdXJjZSBpZGVudGlmaWVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY21layA9IENtZWsuZ2NwKFwicHJvamVjdHMvcC9sb2NhdGlvbnMvbC9rZXlSaW5ncy9yL2NyeXB0b0tleXMva1wiKTtcbiAgICogY21lay50b0pTT04oKTtcbiAgICogLy8gUmV0dXJuczogeyBnY3A6ICdwcm9qZWN0cy9wL2xvY2F0aW9ucy9sL2tleVJpbmdzL3IvY3J5cHRvS2V5cy9rJyB9XG4gICAqIGBgYFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGlmICh0aGlzLnByb3ZpZGVyID09PSBcImdjcFwiIC8qIEdDUCAqLykge1xuICAgICAgcmV0dXJuIHsgZ2NwOiB0aGlzLnJlc291cmNlIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBDTUVLIHByb3ZpZGVyOiAke3RoaXMucHJvdmlkZXJ9YCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIENNRUsgZnJvbSBvYmplY3QgZm9ybWF0LlxuICAgKlxuICAgKiBFeHBlY3RzIHRoZSBwcm92aWRlciB2YXJpYW50IGFzIHRoZSBrZXkgYW5kIHJlc291cmNlIGFzIHRoZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBPYmplY3QgY29udGFpbmluZyBwcm92aWRlciB2YXJpYW50IGFuZCByZXNvdXJjZVxuICAgKiBAcmV0dXJucyBEZXNlcmlhbGl6ZWQgQ01FSyBpbnN0YW5jZVxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBwcm92aWRlciBpcyB1bnN1cHBvcnRlZCBvciBkYXRhIGlzIG1hbGZvcm1lZFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGRhdGEgPSB7IGdjcDogJ3Byb2plY3RzL3AvbG9jYXRpb25zL2wva2V5UmluZ3Mvci9jcnlwdG9LZXlzL2snIH07XG4gICAqIGNvbnN0IGNtZWsgPSBDbWVrLmZyb21KU09OKGRhdGEpO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG4gICAgaWYgKFwiZ2NwXCIgaW4gZGF0YSAmJiB0eXBlb2YgZGF0YS5nY3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBfQ21lay5nY3AoZGF0YS5nY3ApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgb3IgbWlzc2luZyBDTUVLIHByb3ZpZGVyIGluIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YFxuICAgICk7XG4gIH1cbn07XG5fQ21lay5HQ1BfUEFUVEVSTiA9IC9ecHJvamVjdHNcXC8uK1xcL2xvY2F0aW9uc1xcLy4rXFwva2V5UmluZ3NcXC8uK1xcL2NyeXB0b0tleXNcXC8uKyQvO1xudmFyIENtZWsgPSBfQ21laztcbnZhciBTVFJJTkdfVkFMVUVfTkFNRSA9IFwic3RyaW5nXCI7XG52YXIgRkxPQVRfTElTVF9WQUxVRV9OQU1FID0gXCJmbG9hdF9saXN0XCI7XG52YXIgU1BBUlNFX1ZFQ1RPUl9WQUxVRV9OQU1FID0gXCJzcGFyc2VfdmVjdG9yXCI7XG52YXIgSU5UX1ZBTFVFX05BTUUgPSBcImludFwiO1xudmFyIEZMT0FUX1ZBTFVFX05BTUUgPSBcImZsb2F0XCI7XG52YXIgQk9PTF9WQUxVRV9OQU1FID0gXCJib29sXCI7XG52YXIgRlRTX0lOREVYX05BTUUgPSBcImZ0c19pbmRleFwiO1xudmFyIFNUUklOR19JTlZFUlRFRF9JTkRFWF9OQU1FID0gXCJzdHJpbmdfaW52ZXJ0ZWRfaW5kZXhcIjtcbnZhciBWRUNUT1JfSU5ERVhfTkFNRSA9IFwidmVjdG9yX2luZGV4XCI7XG52YXIgU1BBUlNFX1ZFQ1RPUl9JTkRFWF9OQU1FID0gXCJzcGFyc2VfdmVjdG9yX2luZGV4XCI7XG52YXIgSU5UX0lOVkVSVEVEX0lOREVYX05BTUUgPSBcImludF9pbnZlcnRlZF9pbmRleFwiO1xudmFyIEZMT0FUX0lOVkVSVEVEX0lOREVYX05BTUUgPSBcImZsb2F0X2ludmVydGVkX2luZGV4XCI7XG52YXIgQk9PTF9JTlZFUlRFRF9JTkRFWF9OQU1FID0gXCJib29sX2ludmVydGVkX2luZGV4XCI7XG52YXIgRnRzSW5kZXhDb25maWcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHlwZSA9IFwiRnRzSW5kZXhDb25maWdcIjtcbiAgfVxufTtcbnZhciBTdHJpbmdJbnZlcnRlZEluZGV4Q29uZmlnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnR5cGUgPSBcIlN0cmluZ0ludmVydGVkSW5kZXhDb25maWdcIjtcbiAgfVxufTtcbnZhciBJbnRJbnZlcnRlZEluZGV4Q29uZmlnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnR5cGUgPSBcIkludEludmVydGVkSW5kZXhDb25maWdcIjtcbiAgfVxufTtcbnZhciBGbG9hdEludmVydGVkSW5kZXhDb25maWcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHlwZSA9IFwiRmxvYXRJbnZlcnRlZEluZGV4Q29uZmlnXCI7XG4gIH1cbn07XG52YXIgQm9vbEludmVydGVkSW5kZXhDb25maWcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHlwZSA9IFwiQm9vbEludmVydGVkSW5kZXhDb25maWdcIjtcbiAgfVxufTtcbnZhciBWZWN0b3JJbmRleENvbmZpZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gXCJWZWN0b3JJbmRleENvbmZpZ1wiO1xuICAgIHRoaXMuc3BhY2UgPSBvcHRpb25zLnNwYWNlID8/IG51bGw7XG4gICAgdGhpcy5lbWJlZGRpbmdGdW5jdGlvbiA9IG9wdGlvbnMuZW1iZWRkaW5nRnVuY3Rpb247XG4gICAgdGhpcy5zb3VyY2VLZXkgPSBvcHRpb25zLnNvdXJjZUtleSBpbnN0YW5jZW9mIEtleSA/IG9wdGlvbnMuc291cmNlS2V5Lm5hbWUgOiBvcHRpb25zLnNvdXJjZUtleSA/PyBudWxsO1xuICAgIHRoaXMuaG5zdyA9IG9wdGlvbnMuaG5zdyA/PyBudWxsO1xuICAgIHRoaXMuc3Bhbm4gPSBvcHRpb25zLnNwYW5uID8/IG51bGw7XG4gIH1cbn07XG52YXIgU3BhcnNlVmVjdG9ySW5kZXhDb25maWcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMudHlwZSA9IFwiU3BhcnNlVmVjdG9ySW5kZXhDb25maWdcIjtcbiAgICB0aGlzLmVtYmVkZGluZ0Z1bmN0aW9uID0gb3B0aW9ucy5lbWJlZGRpbmdGdW5jdGlvbjtcbiAgICB0aGlzLnNvdXJjZUtleSA9IG9wdGlvbnMuc291cmNlS2V5IGluc3RhbmNlb2YgS2V5ID8gb3B0aW9ucy5zb3VyY2VLZXkubmFtZSA6IG9wdGlvbnMuc291cmNlS2V5ID8/IG51bGw7XG4gICAgdGhpcy5ibTI1ID0gb3B0aW9ucy5ibTI1ID8/IG51bGw7XG4gIH1cbn07XG52YXIgRnRzSW5kZXhUeXBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbmFibGVkLCBjb25maWcpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG59O1xudmFyIFN0cmluZ0ludmVydGVkSW5kZXhUeXBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbmFibGVkLCBjb25maWcpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG59O1xudmFyIFZlY3RvckluZGV4VHlwZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZW5hYmxlZCwgY29uZmlnKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxufTtcbnZhciBTcGFyc2VWZWN0b3JJbmRleFR5cGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVuYWJsZWQsIGNvbmZpZykge1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbn07XG52YXIgSW50SW52ZXJ0ZWRJbmRleFR5cGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVuYWJsZWQsIGNvbmZpZykge1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbn07XG52YXIgRmxvYXRJbnZlcnRlZEluZGV4VHlwZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZW5hYmxlZCwgY29uZmlnKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxufTtcbnZhciBCb29sSW52ZXJ0ZWRJbmRleFR5cGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVuYWJsZWQsIGNvbmZpZykge1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbn07XG52YXIgU3RyaW5nVmFsdWVUeXBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihmdHNJbmRleCA9IG51bGwsIHN0cmluZ0ludmVydGVkSW5kZXggPSBudWxsKSB7XG4gICAgdGhpcy5mdHNJbmRleCA9IGZ0c0luZGV4O1xuICAgIHRoaXMuc3RyaW5nSW52ZXJ0ZWRJbmRleCA9IHN0cmluZ0ludmVydGVkSW5kZXg7XG4gIH1cbn07XG52YXIgRmxvYXRMaXN0VmFsdWVUeXBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2ZWN0b3JJbmRleCA9IG51bGwpIHtcbiAgICB0aGlzLnZlY3RvckluZGV4ID0gdmVjdG9ySW5kZXg7XG4gIH1cbn07XG52YXIgU3BhcnNlVmVjdG9yVmFsdWVUeXBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzcGFyc2VWZWN0b3JJbmRleCA9IG51bGwpIHtcbiAgICB0aGlzLnNwYXJzZVZlY3RvckluZGV4ID0gc3BhcnNlVmVjdG9ySW5kZXg7XG4gIH1cbn07XG52YXIgSW50VmFsdWVUeXBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpbnRJbnZlcnRlZEluZGV4ID0gbnVsbCkge1xuICAgIHRoaXMuaW50SW52ZXJ0ZWRJbmRleCA9IGludEludmVydGVkSW5kZXg7XG4gIH1cbn07XG52YXIgRmxvYXRWYWx1ZVR5cGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZsb2F0SW52ZXJ0ZWRJbmRleCA9IG51bGwpIHtcbiAgICB0aGlzLmZsb2F0SW52ZXJ0ZWRJbmRleCA9IGZsb2F0SW52ZXJ0ZWRJbmRleDtcbiAgfVxufTtcbnZhciBCb29sVmFsdWVUeXBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihib29sSW52ZXJ0ZWRJbmRleCA9IG51bGwpIHtcbiAgICB0aGlzLmJvb2xJbnZlcnRlZEluZGV4ID0gYm9vbEludmVydGVkSW5kZXg7XG4gIH1cbn07XG52YXIgVmFsdWVUeXBlcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBudWxsO1xuICAgIHRoaXMuZmxvYXRMaXN0ID0gbnVsbDtcbiAgICB0aGlzLnNwYXJzZVZlY3RvciA9IG51bGw7XG4gICAgdGhpcy5pbnRWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5mbG9hdFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLmJvb2xlYW4gPSBudWxsO1xuICB9XG59O1xudmFyIGNsb25lT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKChpdGVtKSA9PiBjbG9uZU9iamVjdChpdGVtKSkgOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiBbXG4gICAgICBrLFxuICAgICAgY2xvbmVPYmplY3QodilcbiAgICBdKVxuICApO1xufTtcbnZhciByZXNvbHZlRW1iZWRkaW5nRnVuY3Rpb25OYW1lID0gKGZuKSA9PiB7XG4gIGlmICghZm4pIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlb2YgZm4ubmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZm4ubmFtZSgpO1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdm9pZCAwO1xuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZm4ubmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmbi5uYW1lO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59O1xudmFyIHByZXBhcmVFbWJlZGRpbmdGdW5jdGlvbkNvbmZpZyA9IChmbikgPT4ge1xuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJsZWdhY3lcIiB9O1xuICB9XG4gIGNvbnN0IG5hbWUgPSByZXNvbHZlRW1iZWRkaW5nRnVuY3Rpb25OYW1lKGZuKTtcbiAgY29uc3QgZ2V0Q29uZmlnID0gdHlwZW9mIGZuLmdldENvbmZpZyA9PT0gXCJmdW5jdGlvblwiID8gZm4uZ2V0Q29uZmlnLmJpbmQoZm4pIDogdm9pZCAwO1xuICBjb25zdCBidWlsZEZyb21Db25maWcgPSBmbi5jb25zdHJ1Y3Rvcj8uYnVpbGRGcm9tQ29uZmlnO1xuICBpZiAoIW5hbWUgfHwgIWdldENvbmZpZyB8fCB0eXBlb2YgYnVpbGRGcm9tQ29uZmlnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImxlZ2FjeVwiIH07XG4gIH1cbiAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKCk7XG4gIGlmICh0eXBlb2YgZm4udmFsaWRhdGVDb25maWcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZuLnZhbGlkYXRlQ29uZmlnKGNvbmZpZyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImtub3duXCIsXG4gICAgbmFtZSxcbiAgICBjb25maWdcbiAgfTtcbn07XG52YXIgZW5zdXJlVmFsdWVUeXBlcyA9ICh2YWx1ZVR5cGVzKSA9PiB2YWx1ZVR5cGVzID8/IG5ldyBWYWx1ZVR5cGVzKCk7XG52YXIgZW5zdXJlU3RyaW5nVmFsdWVUeXBlID0gKHZhbHVlVHlwZXMpID0+IHtcbiAgaWYgKCF2YWx1ZVR5cGVzLnN0cmluZykge1xuICAgIHZhbHVlVHlwZXMuc3RyaW5nID0gbmV3IFN0cmluZ1ZhbHVlVHlwZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZVR5cGVzLnN0cmluZztcbn07XG52YXIgZW5zdXJlRmxvYXRMaXN0VmFsdWVUeXBlID0gKHZhbHVlVHlwZXMpID0+IHtcbiAgaWYgKCF2YWx1ZVR5cGVzLmZsb2F0TGlzdCkge1xuICAgIHZhbHVlVHlwZXMuZmxvYXRMaXN0ID0gbmV3IEZsb2F0TGlzdFZhbHVlVHlwZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZVR5cGVzLmZsb2F0TGlzdDtcbn07XG52YXIgZW5zdXJlU3BhcnNlVmVjdG9yVmFsdWVUeXBlID0gKHZhbHVlVHlwZXMpID0+IHtcbiAgaWYgKCF2YWx1ZVR5cGVzLnNwYXJzZVZlY3Rvcikge1xuICAgIHZhbHVlVHlwZXMuc3BhcnNlVmVjdG9yID0gbmV3IFNwYXJzZVZlY3RvclZhbHVlVHlwZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZVR5cGVzLnNwYXJzZVZlY3Rvcjtcbn07XG52YXIgZW5zdXJlSW50VmFsdWVUeXBlID0gKHZhbHVlVHlwZXMpID0+IHtcbiAgaWYgKCF2YWx1ZVR5cGVzLmludFZhbHVlKSB7XG4gICAgdmFsdWVUeXBlcy5pbnRWYWx1ZSA9IG5ldyBJbnRWYWx1ZVR5cGUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVUeXBlcy5pbnRWYWx1ZTtcbn07XG52YXIgZW5zdXJlRmxvYXRWYWx1ZVR5cGUgPSAodmFsdWVUeXBlcykgPT4ge1xuICBpZiAoIXZhbHVlVHlwZXMuZmxvYXRWYWx1ZSkge1xuICAgIHZhbHVlVHlwZXMuZmxvYXRWYWx1ZSA9IG5ldyBGbG9hdFZhbHVlVHlwZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZVR5cGVzLmZsb2F0VmFsdWU7XG59O1xudmFyIGVuc3VyZUJvb2xWYWx1ZVR5cGUgPSAodmFsdWVUeXBlcykgPT4ge1xuICBpZiAoIXZhbHVlVHlwZXMuYm9vbGVhbikge1xuICAgIHZhbHVlVHlwZXMuYm9vbGVhbiA9IG5ldyBCb29sVmFsdWVUeXBlKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlVHlwZXMuYm9vbGVhbjtcbn07XG52YXIgU2NoZW1hID0gY2xhc3MgX1NjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVmYXVsdHMgPSBuZXcgVmFsdWVUeXBlcygpO1xuICAgIHRoaXMua2V5cyA9IHt9O1xuICAgIHRoaXMuY21layA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsaXplRGVmYXVsdHMoKTtcbiAgICB0aGlzLmluaXRpYWxpemVLZXlzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VzdG9tZXItbWFuYWdlZCBlbmNyeXB0aW9uIGtleSBmb3IgdGhpcyBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBDTUVLIGFsbG93cyB5b3UgdG8gdXNlIHlvdXIgb3duIGVuY3J5cHRpb24ga2V5cyBtYW5hZ2VkIGJ5IGNsb3VkIHByb3ZpZGVycydcbiAgICoga2V5IG1hbmFnZW1lbnQgc2VydmljZXMgaW5zdGVhZCBvZiBkZWZhdWx0IHByb3ZpZGVyLW1hbmFnZWQga2V5cy5cbiAgICpcbiAgICogQHBhcmFtIGNtZWsgLSBDTUVLIGluc3RhbmNlIG9yIG51bGwgdG8gcmVtb3ZlIGVuY3J5cHRpb25cbiAgICogQHJldHVybnMgdGhpcyBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSgpO1xuICAgKiBzY2hlbWEuc2V0Q21layhDbWVrLmdjcChcbiAgICogICBcInByb2plY3RzL215LXByb2plY3QvbG9jYXRpb25zL3VzLWNlbnRyYWwxL2tleVJpbmdzL215LXJpbmcvY3J5cHRvS2V5cy9teS1rZXlcIlxuICAgKiApKTtcbiAgICogYGBgXG4gICAqL1xuICBzZXRDbWVrKGNtZWspIHtcbiAgICB0aGlzLmNtZWsgPSBjbWVrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNyZWF0ZUluZGV4KGNvbmZpZywga2V5KSB7XG4gICAgY29uc3QgY29uZmlnUHJvdmlkZWQgPSBjb25maWcgIT09IHZvaWQgMCAmJiBjb25maWcgIT09IG51bGw7XG4gICAgY29uc3Qga2V5UHJvdmlkZWQgPSBrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IG51bGw7XG4gICAgaWYgKCFjb25maWdQcm92aWRlZCAmJiAha2V5UHJvdmlkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW5ub3QgZW5hYmxlIGFsbCBpbmRleCB0eXBlcyBnbG9iYWxseS4gTXVzdCBzcGVjaWZ5IGVpdGhlciBjb25maWcgb3Iga2V5LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoa2V5UHJvdmlkZWQgJiYga2V5ICYmIChrZXkgPT09IEVNQkVERElOR19LRVkgfHwga2V5ID09PSBET0NVTUVOVF9LRVkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIGluZGV4IG9uIHNwZWNpYWwga2V5ICcke2tleX0nLiBUaGVzZSBrZXlzIGFyZSBtYW5hZ2VkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHN5c3RlbS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgVmVjdG9ySW5kZXhDb25maWcpIHtcbiAgICAgIGlmICgha2V5UHJvdmlkZWQpIHtcbiAgICAgICAgdGhpcy5zZXRWZWN0b3JJbmRleENvbmZpZyhjb25maWcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJWZWN0b3IgaW5kZXggY2Fubm90IGJlIGVuYWJsZWQgb24gc3BlY2lmaWMga2V5cy4gVXNlIGNyZWF0ZUluZGV4KGNvbmZpZz1WZWN0b3JJbmRleENvbmZpZyguLi4pKSB3aXRob3V0IHNwZWNpZnlpbmcgYSBrZXkgdG8gY29uZmlndXJlIHRoZSB2ZWN0b3IgaW5kZXggZ2xvYmFsbHkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBGdHNJbmRleENvbmZpZykge1xuICAgICAgaWYgKCFrZXlQcm92aWRlZCkge1xuICAgICAgICB0aGlzLnNldEZ0c0luZGV4Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkZUUyBpbmRleCBjYW5ub3QgYmUgZW5hYmxlZCBvbiBzcGVjaWZpYyBrZXlzLiBVc2UgY3JlYXRlSW5kZXgoY29uZmlnPUZ0c0luZGV4Q29uZmlnKC4uLikpIHdpdGhvdXQgc3BlY2lmeWluZyBhIGtleSB0byBjb25maWd1cmUgdGhlIEZUUyBpbmRleCBnbG9iYWxseS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFNwYXJzZVZlY3RvckluZGV4Q29uZmlnICYmICFrZXlQcm92aWRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlNwYXJzZSB2ZWN0b3IgaW5kZXggbXVzdCBiZSBjcmVhdGVkIG9uIGEgc3BlY2lmaWMga2V5LiBQbGVhc2Ugc3BlY2lmeSBhIGtleSB1c2luZzogY3JlYXRlSW5kZXgoY29uZmlnPVNwYXJzZVZlY3RvckluZGV4Q29uZmlnKC4uLiksIGtleT0neW91cl9rZXknKVwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZ1Byb3ZpZGVkICYmIGtleVByb3ZpZGVkICYmIGtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGVuYWJsZSBhbGwgaW5kZXggdHlwZXMgZm9yIGtleSAnJHtrZXl9Jy4gUGxlYXNlIHNwZWNpZnkgYSBzcGVjaWZpYyBpbmRleCBjb25maWd1cmF0aW9uLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChjb25maWdQcm92aWRlZCAmJiAha2V5UHJvdmlkZWQpIHtcbiAgICAgIHRoaXMuc2V0SW5kZXhJbkRlZmF1bHRzKGNvbmZpZywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChjb25maWdQcm92aWRlZCAmJiBrZXlQcm92aWRlZCAmJiBrZXkpIHtcbiAgICAgIHRoaXMuc2V0SW5kZXhGb3JLZXkoa2V5LCBjb25maWcsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZWxldGVJbmRleChjb25maWcsIGtleSkge1xuICAgIGNvbnN0IGNvbmZpZ1Byb3ZpZGVkID0gY29uZmlnICE9PSB2b2lkIDAgJiYgY29uZmlnICE9PSBudWxsO1xuICAgIGNvbnN0IGtleVByb3ZpZGVkID0ga2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSBudWxsO1xuICAgIGlmICghY29uZmlnUHJvdmlkZWQgJiYgIWtleVByb3ZpZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IGRpc2FibGUgYWxsIGluZGV4ZXMuIE11c3Qgc3BlY2lmeSBlaXRoZXIgY29uZmlnIG9yIGtleS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGtleVByb3ZpZGVkICYmIGtleSAmJiAoa2V5ID09PSBFTUJFRERJTkdfS0VZIHx8IGtleSA9PT0gRE9DVU1FTlRfS0VZKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGRlbGV0ZSBpbmRleCBvbiBzcGVjaWFsIGtleSAnJHtrZXl9Jy4gVGhlc2Uga2V5cyBhcmUgbWFuYWdlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBzeXN0ZW0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFZlY3RvckluZGV4Q29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWxldGluZyB2ZWN0b3IgaW5kZXggaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgRnRzSW5kZXhDb25maWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlbGV0aW5nIEZUUyBpbmRleCBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBTcGFyc2VWZWN0b3JJbmRleENvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkRlbGV0aW5nIHNwYXJzZSB2ZWN0b3IgaW5kZXggaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChrZXlQcm92aWRlZCAmJiAhY29uZmlnUHJvdmlkZWQgJiYga2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGlzYWJsZSBhbGwgaW5kZXggdHlwZXMgZm9yIGtleSAnJHtrZXl9Jy4gUGxlYXNlIHNwZWNpZnkgYSBzcGVjaWZpYyBpbmRleCBjb25maWd1cmF0aW9uLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChrZXlQcm92aWRlZCAmJiBjb25maWdQcm92aWRlZCAmJiBrZXkpIHtcbiAgICAgIHRoaXMuc2V0SW5kZXhGb3JLZXkoa2V5LCBjb25maWcsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKCFrZXlQcm92aWRlZCAmJiBjb25maWdQcm92aWRlZCkge1xuICAgICAgdGhpcy5zZXRJbmRleEluRGVmYXVsdHMoY29uZmlnLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNlcmlhbGl6ZVRvSlNPTigpIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHRoaXMuc2VyaWFsaXplVmFsdWVUeXBlcyh0aGlzLmRlZmF1bHRzKTtcbiAgICBjb25zdCBrZXlzID0ge307XG4gICAgZm9yIChjb25zdCBba2V5TmFtZSwgdmFsdWVUeXBlc10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5rZXlzKSkge1xuICAgICAga2V5c1trZXlOYW1lXSA9IHRoaXMuc2VyaWFsaXplVmFsdWVUeXBlcyh2YWx1ZVR5cGVzKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgZGVmYXVsdHMsXG4gICAgICBrZXlzXG4gICAgfTtcbiAgICBpZiAodGhpcy5jbWVrICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQuY21layA9IHRoaXMuY21lay50b0pTT04oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemVGcm9tSlNPTihqc29uLCBjbGllbnQyKSB7XG4gICAgaWYgKGpzb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGpzb247XG4gICAgY29uc3QgaW5zdGFuY2UgPSBPYmplY3QuY3JlYXRlKF9TY2hlbWEucHJvdG90eXBlKTtcbiAgICBpbnN0YW5jZS5kZWZhdWx0cyA9IGF3YWl0IF9TY2hlbWEuZGVzZXJpYWxpemVWYWx1ZVR5cGVzKFxuICAgICAgZGF0YS5kZWZhdWx0cyA/PyB7fSxcbiAgICAgIGNsaWVudDJcbiAgICApO1xuICAgIGluc3RhbmNlLmtleXMgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gZGF0YS5rZXlzID8/IHt9O1xuICAgIGZvciAoY29uc3QgW2tleU5hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhrZXlzKSkge1xuICAgICAgaW5zdGFuY2Uua2V5c1trZXlOYW1lXSA9IGF3YWl0IF9TY2hlbWEuZGVzZXJpYWxpemVWYWx1ZVR5cGVzKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY2xpZW50MlxuICAgICAgKTtcbiAgICB9XG4gICAgaW5zdGFuY2UuY21layA9IG51bGw7XG4gICAgaWYgKGRhdGEuY21layAmJiB0eXBlb2YgZGF0YS5jbWVrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpbnN0YW5jZS5jbWVrID0gQ21lay5mcm9tSlNPTihkYXRhLmNtZWspO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgc2V0VmVjdG9ySW5kZXhDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3QgZGVmYXVsdHNGbG9hdExpc3QgPSBlbnN1cmVGbG9hdExpc3RWYWx1ZVR5cGUodGhpcy5kZWZhdWx0cyk7XG4gICAgY29uc3QgY3VycmVudERlZmF1bHRzVmVjdG9yID0gZGVmYXVsdHNGbG9hdExpc3QudmVjdG9ySW5kZXggPz8gbmV3IFZlY3RvckluZGV4VHlwZShmYWxzZSwgbmV3IFZlY3RvckluZGV4Q29uZmlnKCkpO1xuICAgIGRlZmF1bHRzRmxvYXRMaXN0LnZlY3RvckluZGV4ID0gbmV3IFZlY3RvckluZGV4VHlwZShcbiAgICAgIGN1cnJlbnREZWZhdWx0c1ZlY3Rvci5lbmFibGVkLFxuICAgICAgbmV3IFZlY3RvckluZGV4Q29uZmlnKHtcbiAgICAgICAgc3BhY2U6IGNvbmZpZy5zcGFjZSA/PyBudWxsLFxuICAgICAgICBlbWJlZGRpbmdGdW5jdGlvbjogY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uLFxuICAgICAgICBzb3VyY2VLZXk6IGNvbmZpZy5zb3VyY2VLZXkgPz8gbnVsbCxcbiAgICAgICAgaG5zdzogY29uZmlnLmhuc3cgPyBjbG9uZU9iamVjdChjb25maWcuaG5zdykgOiBudWxsLFxuICAgICAgICBzcGFubjogY29uZmlnLnNwYW5uID8gY2xvbmVPYmplY3QoY29uZmlnLnNwYW5uKSA6IG51bGxcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBlbWJlZGRpbmdWYWx1ZVR5cGVzID0gZW5zdXJlVmFsdWVUeXBlcyh0aGlzLmtleXNbRU1CRURESU5HX0tFWV0pO1xuICAgIHRoaXMua2V5c1tFTUJFRERJTkdfS0VZXSA9IGVtYmVkZGluZ1ZhbHVlVHlwZXM7XG4gICAgY29uc3Qgb3ZlcnJpZGVGbG9hdExpc3QgPSBlbnN1cmVGbG9hdExpc3RWYWx1ZVR5cGUoZW1iZWRkaW5nVmFsdWVUeXBlcyk7XG4gICAgY29uc3QgY3VycmVudE92ZXJyaWRlVmVjdG9yID0gb3ZlcnJpZGVGbG9hdExpc3QudmVjdG9ySW5kZXggPz8gbmV3IFZlY3RvckluZGV4VHlwZShcbiAgICAgIHRydWUsXG4gICAgICBuZXcgVmVjdG9ySW5kZXhDb25maWcoeyBzb3VyY2VLZXk6IERPQ1VNRU5UX0tFWSB9KVxuICAgICk7XG4gICAgY29uc3QgcHJlc2VydmVkU291cmNlS2V5ID0gY3VycmVudE92ZXJyaWRlVmVjdG9yLmNvbmZpZy5zb3VyY2VLZXkgPz8gRE9DVU1FTlRfS0VZO1xuICAgIG92ZXJyaWRlRmxvYXRMaXN0LnZlY3RvckluZGV4ID0gbmV3IFZlY3RvckluZGV4VHlwZShcbiAgICAgIGN1cnJlbnRPdmVycmlkZVZlY3Rvci5lbmFibGVkLFxuICAgICAgbmV3IFZlY3RvckluZGV4Q29uZmlnKHtcbiAgICAgICAgc3BhY2U6IGNvbmZpZy5zcGFjZSA/PyBudWxsLFxuICAgICAgICBlbWJlZGRpbmdGdW5jdGlvbjogY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uLFxuICAgICAgICBzb3VyY2VLZXk6IHByZXNlcnZlZFNvdXJjZUtleSxcbiAgICAgICAgaG5zdzogY29uZmlnLmhuc3cgPyBjbG9uZU9iamVjdChjb25maWcuaG5zdykgOiBudWxsLFxuICAgICAgICBzcGFubjogY29uZmlnLnNwYW5uID8gY2xvbmVPYmplY3QoY29uZmlnLnNwYW5uKSA6IG51bGxcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBzZXRGdHNJbmRleENvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBkZWZhdWx0c1N0cmluZyA9IGVuc3VyZVN0cmluZ1ZhbHVlVHlwZSh0aGlzLmRlZmF1bHRzKTtcbiAgICBjb25zdCBjdXJyZW50RGVmYXVsdHNGdHMgPSBkZWZhdWx0c1N0cmluZy5mdHNJbmRleCA/PyBuZXcgRnRzSW5kZXhUeXBlKGZhbHNlLCBuZXcgRnRzSW5kZXhDb25maWcoKSk7XG4gICAgZGVmYXVsdHNTdHJpbmcuZnRzSW5kZXggPSBuZXcgRnRzSW5kZXhUeXBlKFxuICAgICAgY3VycmVudERlZmF1bHRzRnRzLmVuYWJsZWQsXG4gICAgICBjb25maWdcbiAgICApO1xuICAgIGNvbnN0IGRvY3VtZW50VmFsdWVUeXBlcyA9IGVuc3VyZVZhbHVlVHlwZXModGhpcy5rZXlzW0RPQ1VNRU5UX0tFWV0pO1xuICAgIHRoaXMua2V5c1tET0NVTUVOVF9LRVldID0gZG9jdW1lbnRWYWx1ZVR5cGVzO1xuICAgIGNvbnN0IG92ZXJyaWRlU3RyaW5nID0gZW5zdXJlU3RyaW5nVmFsdWVUeXBlKGRvY3VtZW50VmFsdWVUeXBlcyk7XG4gICAgY29uc3QgY3VycmVudE92ZXJyaWRlRnRzID0gb3ZlcnJpZGVTdHJpbmcuZnRzSW5kZXggPz8gbmV3IEZ0c0luZGV4VHlwZSh0cnVlLCBuZXcgRnRzSW5kZXhDb25maWcoKSk7XG4gICAgb3ZlcnJpZGVTdHJpbmcuZnRzSW5kZXggPSBuZXcgRnRzSW5kZXhUeXBlKFxuICAgICAgY3VycmVudE92ZXJyaWRlRnRzLmVuYWJsZWQsXG4gICAgICBjb25maWdcbiAgICApO1xuICB9XG4gIHNldEluZGV4SW5EZWZhdWx0cyhjb25maWcsIGVuYWJsZWQpIHtcbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgRnRzSW5kZXhDb25maWcpIHtcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGVuc3VyZVN0cmluZ1ZhbHVlVHlwZSh0aGlzLmRlZmF1bHRzKTtcbiAgICAgIHZhbHVlVHlwZS5mdHNJbmRleCA9IG5ldyBGdHNJbmRleFR5cGUoZW5hYmxlZCwgY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFN0cmluZ0ludmVydGVkSW5kZXhDb25maWcpIHtcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGVuc3VyZVN0cmluZ1ZhbHVlVHlwZSh0aGlzLmRlZmF1bHRzKTtcbiAgICAgIHZhbHVlVHlwZS5zdHJpbmdJbnZlcnRlZEluZGV4ID0gbmV3IFN0cmluZ0ludmVydGVkSW5kZXhUeXBlKFxuICAgICAgICBlbmFibGVkLFxuICAgICAgICBjb25maWdcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb25maWcgaW5zdGFuY2VvZiBWZWN0b3JJbmRleENvbmZpZykge1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gZW5zdXJlRmxvYXRMaXN0VmFsdWVUeXBlKHRoaXMuZGVmYXVsdHMpO1xuICAgICAgdmFsdWVUeXBlLnZlY3RvckluZGV4ID0gbmV3IFZlY3RvckluZGV4VHlwZShlbmFibGVkLCBjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnIGluc3RhbmNlb2YgU3BhcnNlVmVjdG9ySW5kZXhDb25maWcpIHtcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGVuc3VyZVNwYXJzZVZlY3RvclZhbHVlVHlwZSh0aGlzLmRlZmF1bHRzKTtcbiAgICAgIHZhbHVlVHlwZS5zcGFyc2VWZWN0b3JJbmRleCA9IG5ldyBTcGFyc2VWZWN0b3JJbmRleFR5cGUoZW5hYmxlZCwgY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIEludEludmVydGVkSW5kZXhDb25maWcpIHtcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGVuc3VyZUludFZhbHVlVHlwZSh0aGlzLmRlZmF1bHRzKTtcbiAgICAgIHZhbHVlVHlwZS5pbnRJbnZlcnRlZEluZGV4ID0gbmV3IEludEludmVydGVkSW5kZXhUeXBlKGVuYWJsZWQsIGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChjb25maWcgaW5zdGFuY2VvZiBGbG9hdEludmVydGVkSW5kZXhDb25maWcpIHtcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGVuc3VyZUZsb2F0VmFsdWVUeXBlKHRoaXMuZGVmYXVsdHMpO1xuICAgICAgdmFsdWVUeXBlLmZsb2F0SW52ZXJ0ZWRJbmRleCA9IG5ldyBGbG9hdEludmVydGVkSW5kZXhUeXBlKFxuICAgICAgICBlbmFibGVkLFxuICAgICAgICBjb25maWdcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb25maWcgaW5zdGFuY2VvZiBCb29sSW52ZXJ0ZWRJbmRleENvbmZpZykge1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gZW5zdXJlQm9vbFZhbHVlVHlwZSh0aGlzLmRlZmF1bHRzKTtcbiAgICAgIHZhbHVlVHlwZS5ib29sSW52ZXJ0ZWRJbmRleCA9IG5ldyBCb29sSW52ZXJ0ZWRJbmRleFR5cGUoZW5hYmxlZCwgY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgc2V0SW5kZXhGb3JLZXkoa2V5LCBjb25maWcsIGVuYWJsZWQpIHtcbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgU3BhcnNlVmVjdG9ySW5kZXhDb25maWcgJiYgZW5hYmxlZCkge1xuICAgICAgdGhpcy52YWxpZGF0ZVNpbmdsZVNwYXJzZVZlY3RvckluZGV4KGtleSk7XG4gICAgICB0aGlzLnZhbGlkYXRlU3BhcnNlVmVjdG9yQ29uZmlnKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmtleXNba2V5XSA9IGVuc3VyZVZhbHVlVHlwZXModGhpcy5rZXlzW2tleV0pO1xuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBTdHJpbmdJbnZlcnRlZEluZGV4Q29uZmlnKSB7XG4gICAgICBjb25zdCB2YWx1ZVR5cGUgPSBlbnN1cmVTdHJpbmdWYWx1ZVR5cGUoY3VycmVudCk7XG4gICAgICB2YWx1ZVR5cGUuc3RyaW5nSW52ZXJ0ZWRJbmRleCA9IG5ldyBTdHJpbmdJbnZlcnRlZEluZGV4VHlwZShcbiAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgY29uZmlnXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnIGluc3RhbmNlb2YgRnRzSW5kZXhDb25maWcpIHtcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGVuc3VyZVN0cmluZ1ZhbHVlVHlwZShjdXJyZW50KTtcbiAgICAgIHZhbHVlVHlwZS5mdHNJbmRleCA9IG5ldyBGdHNJbmRleFR5cGUoZW5hYmxlZCwgY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFNwYXJzZVZlY3RvckluZGV4Q29uZmlnKSB7XG4gICAgICBjb25zdCB2YWx1ZVR5cGUgPSBlbnN1cmVTcGFyc2VWZWN0b3JWYWx1ZVR5cGUoY3VycmVudCk7XG4gICAgICB2YWx1ZVR5cGUuc3BhcnNlVmVjdG9ySW5kZXggPSBuZXcgU3BhcnNlVmVjdG9ySW5kZXhUeXBlKGVuYWJsZWQsIGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChjb25maWcgaW5zdGFuY2VvZiBWZWN0b3JJbmRleENvbmZpZykge1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gZW5zdXJlRmxvYXRMaXN0VmFsdWVUeXBlKGN1cnJlbnQpO1xuICAgICAgdmFsdWVUeXBlLnZlY3RvckluZGV4ID0gbmV3IFZlY3RvckluZGV4VHlwZShlbmFibGVkLCBjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnIGluc3RhbmNlb2YgSW50SW52ZXJ0ZWRJbmRleENvbmZpZykge1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gZW5zdXJlSW50VmFsdWVUeXBlKGN1cnJlbnQpO1xuICAgICAgdmFsdWVUeXBlLmludEludmVydGVkSW5kZXggPSBuZXcgSW50SW52ZXJ0ZWRJbmRleFR5cGUoZW5hYmxlZCwgY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIEZsb2F0SW52ZXJ0ZWRJbmRleENvbmZpZykge1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gZW5zdXJlRmxvYXRWYWx1ZVR5cGUoY3VycmVudCk7XG4gICAgICB2YWx1ZVR5cGUuZmxvYXRJbnZlcnRlZEluZGV4ID0gbmV3IEZsb2F0SW52ZXJ0ZWRJbmRleFR5cGUoXG4gICAgICAgIGVuYWJsZWQsXG4gICAgICAgIGNvbmZpZ1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIEJvb2xJbnZlcnRlZEluZGV4Q29uZmlnKSB7XG4gICAgICBjb25zdCB2YWx1ZVR5cGUgPSBlbnN1cmVCb29sVmFsdWVUeXBlKGN1cnJlbnQpO1xuICAgICAgdmFsdWVUeXBlLmJvb2xJbnZlcnRlZEluZGV4ID0gbmV3IEJvb2xJbnZlcnRlZEluZGV4VHlwZShlbmFibGVkLCBjb25maWcpO1xuICAgIH1cbiAgfVxuICBlbmFibGVBbGxJbmRleGVzRm9yS2V5KGtleSkge1xuICAgIGlmIChrZXkgPT09IEVNQkVERElOR19LRVkgfHwga2V5ID09PSBET0NVTUVOVF9LRVkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBlbmFibGUgYWxsIGluZGV4ZXMgZm9yIHNwZWNpYWwga2V5ICcke2tleX0nLiBUaGVzZSBrZXlzIGFyZSBtYW5hZ2VkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHN5c3RlbS5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5rZXlzW2tleV0gPSBlbnN1cmVWYWx1ZVR5cGVzKHRoaXMua2V5c1trZXldKTtcbiAgICBjdXJyZW50LnN0cmluZyA9IG5ldyBTdHJpbmdWYWx1ZVR5cGUoXG4gICAgICBuZXcgRnRzSW5kZXhUeXBlKHRydWUsIG5ldyBGdHNJbmRleENvbmZpZygpKSxcbiAgICAgIG5ldyBTdHJpbmdJbnZlcnRlZEluZGV4VHlwZSh0cnVlLCBuZXcgU3RyaW5nSW52ZXJ0ZWRJbmRleENvbmZpZygpKVxuICAgICk7XG4gICAgY3VycmVudC5mbG9hdExpc3QgPSBuZXcgRmxvYXRMaXN0VmFsdWVUeXBlKFxuICAgICAgbmV3IFZlY3RvckluZGV4VHlwZSh0cnVlLCBuZXcgVmVjdG9ySW5kZXhDb25maWcoKSlcbiAgICApO1xuICAgIGN1cnJlbnQuc3BhcnNlVmVjdG9yID0gbmV3IFNwYXJzZVZlY3RvclZhbHVlVHlwZShcbiAgICAgIG5ldyBTcGFyc2VWZWN0b3JJbmRleFR5cGUoZmFsc2UsIG5ldyBTcGFyc2VWZWN0b3JJbmRleENvbmZpZygpKVxuICAgICk7XG4gICAgY3VycmVudC5pbnRWYWx1ZSA9IG5ldyBJbnRWYWx1ZVR5cGUoXG4gICAgICBuZXcgSW50SW52ZXJ0ZWRJbmRleFR5cGUodHJ1ZSwgbmV3IEludEludmVydGVkSW5kZXhDb25maWcoKSlcbiAgICApO1xuICAgIGN1cnJlbnQuZmxvYXRWYWx1ZSA9IG5ldyBGbG9hdFZhbHVlVHlwZShcbiAgICAgIG5ldyBGbG9hdEludmVydGVkSW5kZXhUeXBlKHRydWUsIG5ldyBGbG9hdEludmVydGVkSW5kZXhDb25maWcoKSlcbiAgICApO1xuICAgIGN1cnJlbnQuYm9vbGVhbiA9IG5ldyBCb29sVmFsdWVUeXBlKFxuICAgICAgbmV3IEJvb2xJbnZlcnRlZEluZGV4VHlwZSh0cnVlLCBuZXcgQm9vbEludmVydGVkSW5kZXhDb25maWcoKSlcbiAgICApO1xuICB9XG4gIGRpc2FibGVBbGxJbmRleGVzRm9yS2V5KGtleSkge1xuICAgIGlmIChrZXkgPT09IEVNQkVERElOR19LRVkgfHwga2V5ID09PSBET0NVTUVOVF9LRVkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBkaXNhYmxlIGFsbCBpbmRleGVzIGZvciBzcGVjaWFsIGtleSAnJHtrZXl9Jy4gVGhlc2Uga2V5cyBhcmUgbWFuYWdlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBzeXN0ZW0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMua2V5c1trZXldID0gZW5zdXJlVmFsdWVUeXBlcyh0aGlzLmtleXNba2V5XSk7XG4gICAgY3VycmVudC5zdHJpbmcgPSBuZXcgU3RyaW5nVmFsdWVUeXBlKFxuICAgICAgbmV3IEZ0c0luZGV4VHlwZShmYWxzZSwgbmV3IEZ0c0luZGV4Q29uZmlnKCkpLFxuICAgICAgbmV3IFN0cmluZ0ludmVydGVkSW5kZXhUeXBlKGZhbHNlLCBuZXcgU3RyaW5nSW52ZXJ0ZWRJbmRleENvbmZpZygpKVxuICAgICk7XG4gICAgY3VycmVudC5mbG9hdExpc3QgPSBuZXcgRmxvYXRMaXN0VmFsdWVUeXBlKFxuICAgICAgbmV3IFZlY3RvckluZGV4VHlwZShmYWxzZSwgbmV3IFZlY3RvckluZGV4Q29uZmlnKCkpXG4gICAgKTtcbiAgICBjdXJyZW50LnNwYXJzZVZlY3RvciA9IG5ldyBTcGFyc2VWZWN0b3JWYWx1ZVR5cGUoXG4gICAgICBuZXcgU3BhcnNlVmVjdG9ySW5kZXhUeXBlKGZhbHNlLCBuZXcgU3BhcnNlVmVjdG9ySW5kZXhDb25maWcoKSlcbiAgICApO1xuICAgIGN1cnJlbnQuaW50VmFsdWUgPSBuZXcgSW50VmFsdWVUeXBlKFxuICAgICAgbmV3IEludEludmVydGVkSW5kZXhUeXBlKGZhbHNlLCBuZXcgSW50SW52ZXJ0ZWRJbmRleENvbmZpZygpKVxuICAgICk7XG4gICAgY3VycmVudC5mbG9hdFZhbHVlID0gbmV3IEZsb2F0VmFsdWVUeXBlKFxuICAgICAgbmV3IEZsb2F0SW52ZXJ0ZWRJbmRleFR5cGUoZmFsc2UsIG5ldyBGbG9hdEludmVydGVkSW5kZXhDb25maWcoKSlcbiAgICApO1xuICAgIGN1cnJlbnQuYm9vbGVhbiA9IG5ldyBCb29sVmFsdWVUeXBlKFxuICAgICAgbmV3IEJvb2xJbnZlcnRlZEluZGV4VHlwZShmYWxzZSwgbmV3IEJvb2xJbnZlcnRlZEluZGV4Q29uZmlnKCkpXG4gICAgKTtcbiAgfVxuICB2YWxpZGF0ZVNpbmdsZVNwYXJzZVZlY3RvckluZGV4KHRhcmdldEtleSkge1xuICAgIGZvciAoY29uc3QgW2V4aXN0aW5nS2V5LCB2YWx1ZVR5cGVzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmtleXMpKSB7XG4gICAgICBpZiAoZXhpc3RpbmdLZXkgPT09IHRhcmdldEtleSkgY29udGludWU7XG4gICAgICBjb25zdCBzcGFyc2VJbmRleCA9IHZhbHVlVHlwZXMuc3BhcnNlVmVjdG9yPy5zcGFyc2VWZWN0b3JJbmRleDtcbiAgICAgIGlmIChzcGFyc2VJbmRleD8uZW5hYmxlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBlbmFibGUgc3BhcnNlIHZlY3RvciBpbmRleCBvbiBrZXkgJyR7dGFyZ2V0S2V5fScuIEEgc3BhcnNlIHZlY3RvciBpbmRleCBpcyBhbHJlYWR5IGVuYWJsZWQgb24ga2V5ICcke2V4aXN0aW5nS2V5fScuIE9ubHkgb25lIHNwYXJzZSB2ZWN0b3IgaW5kZXggaXMgYWxsb3dlZCBwZXIgY29sbGVjdGlvbi5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlU3BhcnNlVmVjdG9yQ29uZmlnKGNvbmZpZykge1xuICAgIGlmIChjb25maWcuc291cmNlS2V5ICE9PSBudWxsICYmIGNvbmZpZy5zb3VyY2VLZXkgIT09IHZvaWQgMCAmJiAhY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJZiBzb3VyY2VLZXkgaXMgcHJvdmlkZWQgdGhlbiBlbWJlZGRpbmdGdW5jdGlvbiBtdXN0IGFsc28gYmUgcHJvdmlkZWQgc2luY2UgdGhlcmUgaXMgbm8gZGVmYXVsdCBlbWJlZGRpbmcgZnVuY3Rpb24uIENvbmZpZzogJHtKU09OLnN0cmluZ2lmeShjb25maWcpfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGluaXRpYWxpemVEZWZhdWx0cygpIHtcbiAgICB0aGlzLmRlZmF1bHRzLnN0cmluZyA9IG5ldyBTdHJpbmdWYWx1ZVR5cGUoXG4gICAgICBuZXcgRnRzSW5kZXhUeXBlKGZhbHNlLCBuZXcgRnRzSW5kZXhDb25maWcoKSksXG4gICAgICBuZXcgU3RyaW5nSW52ZXJ0ZWRJbmRleFR5cGUodHJ1ZSwgbmV3IFN0cmluZ0ludmVydGVkSW5kZXhDb25maWcoKSlcbiAgICApO1xuICAgIHRoaXMuZGVmYXVsdHMuZmxvYXRMaXN0ID0gbmV3IEZsb2F0TGlzdFZhbHVlVHlwZShcbiAgICAgIG5ldyBWZWN0b3JJbmRleFR5cGUoZmFsc2UsIG5ldyBWZWN0b3JJbmRleENvbmZpZygpKVxuICAgICk7XG4gICAgdGhpcy5kZWZhdWx0cy5zcGFyc2VWZWN0b3IgPSBuZXcgU3BhcnNlVmVjdG9yVmFsdWVUeXBlKFxuICAgICAgbmV3IFNwYXJzZVZlY3RvckluZGV4VHlwZShmYWxzZSwgbmV3IFNwYXJzZVZlY3RvckluZGV4Q29uZmlnKCkpXG4gICAgKTtcbiAgICB0aGlzLmRlZmF1bHRzLmludFZhbHVlID0gbmV3IEludFZhbHVlVHlwZShcbiAgICAgIG5ldyBJbnRJbnZlcnRlZEluZGV4VHlwZSh0cnVlLCBuZXcgSW50SW52ZXJ0ZWRJbmRleENvbmZpZygpKVxuICAgICk7XG4gICAgdGhpcy5kZWZhdWx0cy5mbG9hdFZhbHVlID0gbmV3IEZsb2F0VmFsdWVUeXBlKFxuICAgICAgbmV3IEZsb2F0SW52ZXJ0ZWRJbmRleFR5cGUodHJ1ZSwgbmV3IEZsb2F0SW52ZXJ0ZWRJbmRleENvbmZpZygpKVxuICAgICk7XG4gICAgdGhpcy5kZWZhdWx0cy5ib29sZWFuID0gbmV3IEJvb2xWYWx1ZVR5cGUoXG4gICAgICBuZXcgQm9vbEludmVydGVkSW5kZXhUeXBlKHRydWUsIG5ldyBCb29sSW52ZXJ0ZWRJbmRleENvbmZpZygpKVxuICAgICk7XG4gIH1cbiAgaW5pdGlhbGl6ZUtleXMoKSB7XG4gICAgdGhpcy5rZXlzW0RPQ1VNRU5UX0tFWV0gPSBuZXcgVmFsdWVUeXBlcygpO1xuICAgIHRoaXMua2V5c1tET0NVTUVOVF9LRVldLnN0cmluZyA9IG5ldyBTdHJpbmdWYWx1ZVR5cGUoXG4gICAgICBuZXcgRnRzSW5kZXhUeXBlKHRydWUsIG5ldyBGdHNJbmRleENvbmZpZygpKSxcbiAgICAgIG5ldyBTdHJpbmdJbnZlcnRlZEluZGV4VHlwZShmYWxzZSwgbmV3IFN0cmluZ0ludmVydGVkSW5kZXhDb25maWcoKSlcbiAgICApO1xuICAgIHRoaXMua2V5c1tFTUJFRERJTkdfS0VZXSA9IG5ldyBWYWx1ZVR5cGVzKCk7XG4gICAgdGhpcy5rZXlzW0VNQkVERElOR19LRVldLmZsb2F0TGlzdCA9IG5ldyBGbG9hdExpc3RWYWx1ZVR5cGUoXG4gICAgICBuZXcgVmVjdG9ySW5kZXhUeXBlKFxuICAgICAgICB0cnVlLFxuICAgICAgICBuZXcgVmVjdG9ySW5kZXhDb25maWcoeyBzb3VyY2VLZXk6IERPQ1VNRU5UX0tFWSB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgc2VyaWFsaXplVmFsdWVUeXBlcyh2YWx1ZVR5cGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKHZhbHVlVHlwZXMuc3RyaW5nKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gdGhpcy5zZXJpYWxpemVTdHJpbmdWYWx1ZVR5cGUodmFsdWVUeXBlcy5zdHJpbmcpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHNlcmlhbGl6ZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0W1NUUklOR19WQUxVRV9OQU1FXSA9IHNlcmlhbGl6ZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZVR5cGVzLmZsb2F0TGlzdCkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHRoaXMuc2VyaWFsaXplRmxvYXRMaXN0VmFsdWVUeXBlKHZhbHVlVHlwZXMuZmxvYXRMaXN0KTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhzZXJpYWxpemVkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdFtGTE9BVF9MSVNUX1ZBTFVFX05BTUVdID0gc2VyaWFsaXplZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlVHlwZXMuc3BhcnNlVmVjdG9yKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gdGhpcy5zZXJpYWxpemVTcGFyc2VWZWN0b3JWYWx1ZVR5cGUoXG4gICAgICAgIHZhbHVlVHlwZXMuc3BhcnNlVmVjdG9yXG4gICAgICApO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHNlcmlhbGl6ZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0W1NQQVJTRV9WRUNUT1JfVkFMVUVfTkFNRV0gPSBzZXJpYWxpemVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWVUeXBlcy5pbnRWYWx1ZSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHRoaXMuc2VyaWFsaXplSW50VmFsdWVUeXBlKHZhbHVlVHlwZXMuaW50VmFsdWUpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHNlcmlhbGl6ZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0W0lOVF9WQUxVRV9OQU1FXSA9IHNlcmlhbGl6ZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZVR5cGVzLmZsb2F0VmFsdWUpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB0aGlzLnNlcmlhbGl6ZUZsb2F0VmFsdWVUeXBlKHZhbHVlVHlwZXMuZmxvYXRWYWx1ZSk7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoc2VyaWFsaXplZCkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHRbRkxPQVRfVkFMVUVfTkFNRV0gPSBzZXJpYWxpemVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWVUeXBlcy5ib29sZWFuKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gdGhpcy5zZXJpYWxpemVCb29sVmFsdWVUeXBlKHZhbHVlVHlwZXMuYm9vbGVhbik7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoc2VyaWFsaXplZCkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHRbQk9PTF9WQUxVRV9OQU1FXSA9IHNlcmlhbGl6ZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2VyaWFsaXplU3RyaW5nVmFsdWVUeXBlKHZhbHVlVHlwZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmICh2YWx1ZVR5cGUuZnRzSW5kZXgpIHtcbiAgICAgIHJlc3VsdFtGVFNfSU5ERVhfTkFNRV0gPSB7XG4gICAgICAgIGVuYWJsZWQ6IHZhbHVlVHlwZS5mdHNJbmRleC5lbmFibGVkLFxuICAgICAgICBjb25maWc6IHRoaXMuc2VyaWFsaXplQ29uZmlnKHZhbHVlVHlwZS5mdHNJbmRleC5jb25maWcpXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodmFsdWVUeXBlLnN0cmluZ0ludmVydGVkSW5kZXgpIHtcbiAgICAgIHJlc3VsdFtTVFJJTkdfSU5WRVJURURfSU5ERVhfTkFNRV0gPSB7XG4gICAgICAgIGVuYWJsZWQ6IHZhbHVlVHlwZS5zdHJpbmdJbnZlcnRlZEluZGV4LmVuYWJsZWQsXG4gICAgICAgIGNvbmZpZzogdGhpcy5zZXJpYWxpemVDb25maWcodmFsdWVUeXBlLnN0cmluZ0ludmVydGVkSW5kZXguY29uZmlnKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzZXJpYWxpemVGbG9hdExpc3RWYWx1ZVR5cGUodmFsdWVUeXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKHZhbHVlVHlwZS52ZWN0b3JJbmRleCkge1xuICAgICAgcmVzdWx0W1ZFQ1RPUl9JTkRFWF9OQU1FXSA9IHtcbiAgICAgICAgZW5hYmxlZDogdmFsdWVUeXBlLnZlY3RvckluZGV4LmVuYWJsZWQsXG4gICAgICAgIGNvbmZpZzogdGhpcy5zZXJpYWxpemVDb25maWcodmFsdWVUeXBlLnZlY3RvckluZGV4LmNvbmZpZylcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2VyaWFsaXplU3BhcnNlVmVjdG9yVmFsdWVUeXBlKHZhbHVlVHlwZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmICh2YWx1ZVR5cGUuc3BhcnNlVmVjdG9ySW5kZXgpIHtcbiAgICAgIHJlc3VsdFtTUEFSU0VfVkVDVE9SX0lOREVYX05BTUVdID0ge1xuICAgICAgICBlbmFibGVkOiB2YWx1ZVR5cGUuc3BhcnNlVmVjdG9ySW5kZXguZW5hYmxlZCxcbiAgICAgICAgY29uZmlnOiB0aGlzLnNlcmlhbGl6ZUNvbmZpZyh2YWx1ZVR5cGUuc3BhcnNlVmVjdG9ySW5kZXguY29uZmlnKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzZXJpYWxpemVJbnRWYWx1ZVR5cGUodmFsdWVUeXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKHZhbHVlVHlwZS5pbnRJbnZlcnRlZEluZGV4KSB7XG4gICAgICByZXN1bHRbSU5UX0lOVkVSVEVEX0lOREVYX05BTUVdID0ge1xuICAgICAgICBlbmFibGVkOiB2YWx1ZVR5cGUuaW50SW52ZXJ0ZWRJbmRleC5lbmFibGVkLFxuICAgICAgICBjb25maWc6IHRoaXMuc2VyaWFsaXplQ29uZmlnKHZhbHVlVHlwZS5pbnRJbnZlcnRlZEluZGV4LmNvbmZpZylcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2VyaWFsaXplRmxvYXRWYWx1ZVR5cGUodmFsdWVUeXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKHZhbHVlVHlwZS5mbG9hdEludmVydGVkSW5kZXgpIHtcbiAgICAgIHJlc3VsdFtGTE9BVF9JTlZFUlRFRF9JTkRFWF9OQU1FXSA9IHtcbiAgICAgICAgZW5hYmxlZDogdmFsdWVUeXBlLmZsb2F0SW52ZXJ0ZWRJbmRleC5lbmFibGVkLFxuICAgICAgICBjb25maWc6IHRoaXMuc2VyaWFsaXplQ29uZmlnKHZhbHVlVHlwZS5mbG9hdEludmVydGVkSW5kZXguY29uZmlnKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzZXJpYWxpemVCb29sVmFsdWVUeXBlKHZhbHVlVHlwZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmICh2YWx1ZVR5cGUuYm9vbEludmVydGVkSW5kZXgpIHtcbiAgICAgIHJlc3VsdFtCT09MX0lOVkVSVEVEX0lOREVYX05BTUVdID0ge1xuICAgICAgICBlbmFibGVkOiB2YWx1ZVR5cGUuYm9vbEludmVydGVkSW5kZXguZW5hYmxlZCxcbiAgICAgICAgY29uZmlnOiB0aGlzLnNlcmlhbGl6ZUNvbmZpZyh2YWx1ZVR5cGUuYm9vbEludmVydGVkSW5kZXguY29uZmlnKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzZXJpYWxpemVDb25maWcoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFZlY3RvckluZGV4Q29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVWZWN0b3JDb25maWcoY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFNwYXJzZVZlY3RvckluZGV4Q29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVTcGFyc2VWZWN0b3JDb25maWcoY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHNlcmlhbGl6ZVZlY3RvckNvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0ge307XG4gICAgY29uc3QgZW1iZWRkaW5nRnVuY3Rpb24gPSBjb25maWcuZW1iZWRkaW5nRnVuY3Rpb247XG4gICAgY29uc3QgZWZDb25maWcgPSBwcmVwYXJlRW1iZWRkaW5nRnVuY3Rpb25Db25maWcoZW1iZWRkaW5nRnVuY3Rpb24pO1xuICAgIHNlcmlhbGl6ZWRbXCJlbWJlZGRpbmdfZnVuY3Rpb25cIl0gPSBlZkNvbmZpZztcbiAgICBsZXQgcmVzb2x2ZWRTcGFjZSA9IGNvbmZpZy5zcGFjZSA/PyBudWxsO1xuICAgIGlmICghcmVzb2x2ZWRTcGFjZSAmJiBlbWJlZGRpbmdGdW5jdGlvbj8uZGVmYXVsdFNwYWNlKSB7XG4gICAgICByZXNvbHZlZFNwYWNlID0gZW1iZWRkaW5nRnVuY3Rpb24uZGVmYXVsdFNwYWNlKCk7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZFNwYWNlICYmIGVtYmVkZGluZ0Z1bmN0aW9uPy5zdXBwb3J0ZWRTcGFjZXMgJiYgIWVtYmVkZGluZ0Z1bmN0aW9uLnN1cHBvcnRlZFNwYWNlcygpLmluY2x1ZGVzKHJlc29sdmVkU3BhY2UpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBTcGFjZSAnJHtyZXNvbHZlZFNwYWNlfScgaXMgbm90IHN1cHBvcnRlZCBieSBlbWJlZGRpbmcgZnVuY3Rpb24gJyR7cmVzb2x2ZUVtYmVkZGluZ0Z1bmN0aW9uTmFtZShlbWJlZGRpbmdGdW5jdGlvbikgPz8gXCJ1bmtub3duXCJ9Jy4gU3VwcG9ydGVkIHNwYWNlczogJHtlbWJlZGRpbmdGdW5jdGlvbi5zdXBwb3J0ZWRTcGFjZXMoKS5qb2luKFwiLCBcIil9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHJlc29sdmVkU3BhY2UpIHtcbiAgICAgIHNlcmlhbGl6ZWQuc3BhY2UgPSByZXNvbHZlZFNwYWNlO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnNvdXJjZUtleSkge1xuICAgICAgc2VyaWFsaXplZC5zb3VyY2Vfa2V5ID0gY29uZmlnLnNvdXJjZUtleTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5obnN3KSB7XG4gICAgICBzZXJpYWxpemVkLmhuc3cgPSBjbG9uZU9iamVjdChjb25maWcuaG5zdyk7XG4gICAgfVxuICAgIGlmIChjb25maWcuc3Bhbm4pIHtcbiAgICAgIHNlcmlhbGl6ZWQuc3Bhbm4gPSBjbG9uZU9iamVjdChjb25maWcuc3Bhbm4pO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICBzZXJpYWxpemVTcGFyc2VWZWN0b3JDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHt9O1xuICAgIGNvbnN0IGVtYmVkZGluZ0Z1bmN0aW9uID0gY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uO1xuICAgIHNlcmlhbGl6ZWRbXCJlbWJlZGRpbmdfZnVuY3Rpb25cIl0gPSBwcmVwYXJlRW1iZWRkaW5nRnVuY3Rpb25Db25maWcoZW1iZWRkaW5nRnVuY3Rpb24pO1xuICAgIGlmIChjb25maWcuc291cmNlS2V5KSB7XG4gICAgICBzZXJpYWxpemVkLnNvdXJjZV9rZXkgPSBjb25maWcuc291cmNlS2V5O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5ibTI1ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgc2VyaWFsaXplZC5ibTI1ID0gY29uZmlnLmJtMjU7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZVZhbHVlVHlwZXMoanNvbiwgY2xpZW50Mikge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBWYWx1ZVR5cGVzKCk7XG4gICAgaWYgKGpzb25bU1RSSU5HX1ZBTFVFX05BTUVdKSB7XG4gICAgICByZXN1bHQuc3RyaW5nID0gX1NjaGVtYS5kZXNlcmlhbGl6ZVN0cmluZ1ZhbHVlVHlwZShcbiAgICAgICAganNvbltTVFJJTkdfVkFMVUVfTkFNRV1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChqc29uW0ZMT0FUX0xJU1RfVkFMVUVfTkFNRV0pIHtcbiAgICAgIHJlc3VsdC5mbG9hdExpc3QgPSBhd2FpdCBfU2NoZW1hLmRlc2VyaWFsaXplRmxvYXRMaXN0VmFsdWVUeXBlKFxuICAgICAgICBqc29uW0ZMT0FUX0xJU1RfVkFMVUVfTkFNRV0sXG4gICAgICAgIGNsaWVudDJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChqc29uW1NQQVJTRV9WRUNUT1JfVkFMVUVfTkFNRV0pIHtcbiAgICAgIHJlc3VsdC5zcGFyc2VWZWN0b3IgPSBhd2FpdCBfU2NoZW1hLmRlc2VyaWFsaXplU3BhcnNlVmVjdG9yVmFsdWVUeXBlKFxuICAgICAgICBqc29uW1NQQVJTRV9WRUNUT1JfVkFMVUVfTkFNRV0sXG4gICAgICAgIGNsaWVudDJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChqc29uW0lOVF9WQUxVRV9OQU1FXSkge1xuICAgICAgcmVzdWx0LmludFZhbHVlID0gX1NjaGVtYS5kZXNlcmlhbGl6ZUludFZhbHVlVHlwZShqc29uW0lOVF9WQUxVRV9OQU1FXSk7XG4gICAgfVxuICAgIGlmIChqc29uW0ZMT0FUX1ZBTFVFX05BTUVdKSB7XG4gICAgICByZXN1bHQuZmxvYXRWYWx1ZSA9IF9TY2hlbWEuZGVzZXJpYWxpemVGbG9hdFZhbHVlVHlwZShcbiAgICAgICAganNvbltGTE9BVF9WQUxVRV9OQU1FXVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGpzb25bQk9PTF9WQUxVRV9OQU1FXSkge1xuICAgICAgcmVzdWx0LmJvb2xlYW4gPSBfU2NoZW1hLmRlc2VyaWFsaXplQm9vbFZhbHVlVHlwZShqc29uW0JPT0xfVkFMVUVfTkFNRV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZVN0cmluZ1ZhbHVlVHlwZShqc29uKSB7XG4gICAgbGV0IGZ0c0luZGV4ID0gbnVsbDtcbiAgICBsZXQgc3RyaW5nSW5kZXggPSBudWxsO1xuICAgIGlmIChqc29uW0ZUU19JTkRFWF9OQU1FXSkge1xuICAgICAgY29uc3QgZGF0YSA9IGpzb25bRlRTX0lOREVYX05BTUVdO1xuICAgICAgZnRzSW5kZXggPSBuZXcgRnRzSW5kZXhUeXBlKEJvb2xlYW4oZGF0YS5lbmFibGVkKSwgbmV3IEZ0c0luZGV4Q29uZmlnKCkpO1xuICAgIH1cbiAgICBpZiAoanNvbltTVFJJTkdfSU5WRVJURURfSU5ERVhfTkFNRV0pIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBqc29uW1NUUklOR19JTlZFUlRFRF9JTkRFWF9OQU1FXTtcbiAgICAgIHN0cmluZ0luZGV4ID0gbmV3IFN0cmluZ0ludmVydGVkSW5kZXhUeXBlKFxuICAgICAgICBCb29sZWFuKGRhdGEuZW5hYmxlZCksXG4gICAgICAgIG5ldyBTdHJpbmdJbnZlcnRlZEluZGV4Q29uZmlnKClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWVUeXBlKGZ0c0luZGV4LCBzdHJpbmdJbmRleCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplRmxvYXRMaXN0VmFsdWVUeXBlKGpzb24sIGNsaWVudDIpIHtcbiAgICBsZXQgdmVjdG9ySW5kZXggPSBudWxsO1xuICAgIGlmIChqc29uW1ZFQ1RPUl9JTkRFWF9OQU1FXSkge1xuICAgICAgY29uc3QgZGF0YSA9IGpzb25bVkVDVE9SX0lOREVYX05BTUVdO1xuICAgICAgY29uc3QgZW5hYmxlZCA9IEJvb2xlYW4oZGF0YS5lbmFibGVkKTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IF9TY2hlbWEuZGVzZXJpYWxpemVWZWN0b3JDb25maWcoXG4gICAgICAgIGRhdGEuY29uZmlnID8/IHt9LFxuICAgICAgICBjbGllbnQyXG4gICAgICApO1xuICAgICAgdmVjdG9ySW5kZXggPSBuZXcgVmVjdG9ySW5kZXhUeXBlKGVuYWJsZWQsIGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRmxvYXRMaXN0VmFsdWVUeXBlKHZlY3RvckluZGV4KTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemVTcGFyc2VWZWN0b3JWYWx1ZVR5cGUoanNvbiwgY2xpZW50Mikge1xuICAgIGxldCBzcGFyc2VJbmRleCA9IG51bGw7XG4gICAgaWYgKGpzb25bU1BBUlNFX1ZFQ1RPUl9JTkRFWF9OQU1FXSkge1xuICAgICAgY29uc3QgZGF0YSA9IGpzb25bU1BBUlNFX1ZFQ1RPUl9JTkRFWF9OQU1FXTtcbiAgICAgIGNvbnN0IGVuYWJsZWQgPSBCb29sZWFuKGRhdGEuZW5hYmxlZCk7XG4gICAgICBjb25zdCBjb25maWcgPSBhd2FpdCBfU2NoZW1hLmRlc2VyaWFsaXplU3BhcnNlVmVjdG9yQ29uZmlnKFxuICAgICAgICBkYXRhLmNvbmZpZyA/PyB7fSxcbiAgICAgICAgY2xpZW50MlxuICAgICAgKTtcbiAgICAgIHNwYXJzZUluZGV4ID0gbmV3IFNwYXJzZVZlY3RvckluZGV4VHlwZShlbmFibGVkLCBjb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNwYXJzZVZlY3RvclZhbHVlVHlwZShzcGFyc2VJbmRleCk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplSW50VmFsdWVUeXBlKGpzb24pIHtcbiAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgIGlmIChqc29uW0lOVF9JTlZFUlRFRF9JTkRFWF9OQU1FXSkge1xuICAgICAgY29uc3QgZGF0YSA9IGpzb25bSU5UX0lOVkVSVEVEX0lOREVYX05BTUVdO1xuICAgICAgaW5kZXggPSBuZXcgSW50SW52ZXJ0ZWRJbmRleFR5cGUoXG4gICAgICAgIEJvb2xlYW4oZGF0YS5lbmFibGVkKSxcbiAgICAgICAgbmV3IEludEludmVydGVkSW5kZXhDb25maWcoKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnRWYWx1ZVR5cGUoaW5kZXgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZUZsb2F0VmFsdWVUeXBlKGpzb24pIHtcbiAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgIGlmIChqc29uW0ZMT0FUX0lOVkVSVEVEX0lOREVYX05BTUVdKSB7XG4gICAgICBjb25zdCBkYXRhID0ganNvbltGTE9BVF9JTlZFUlRFRF9JTkRFWF9OQU1FXTtcbiAgICAgIGluZGV4ID0gbmV3IEZsb2F0SW52ZXJ0ZWRJbmRleFR5cGUoXG4gICAgICAgIEJvb2xlYW4oZGF0YS5lbmFibGVkKSxcbiAgICAgICAgbmV3IEZsb2F0SW52ZXJ0ZWRJbmRleENvbmZpZygpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZsb2F0VmFsdWVUeXBlKGluZGV4KTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemVCb29sVmFsdWVUeXBlKGpzb24pIHtcbiAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgIGlmIChqc29uW0JPT0xfSU5WRVJURURfSU5ERVhfTkFNRV0pIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBqc29uW0JPT0xfSU5WRVJURURfSU5ERVhfTkFNRV07XG4gICAgICBpbmRleCA9IG5ldyBCb29sSW52ZXJ0ZWRJbmRleFR5cGUoXG4gICAgICAgIEJvb2xlYW4oZGF0YS5lbmFibGVkKSxcbiAgICAgICAgbmV3IEJvb2xJbnZlcnRlZEluZGV4Q29uZmlnKClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQm9vbFZhbHVlVHlwZShpbmRleCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplVmVjdG9yQ29uZmlnKGpzb24sIGNsaWVudDIpIHtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgVmVjdG9ySW5kZXhDb25maWcoe1xuICAgICAgc3BhY2U6IGpzb24uc3BhY2UgPz8gbnVsbCxcbiAgICAgIHNvdXJjZUtleToganNvbi5zb3VyY2Vfa2V5ID8/IG51bGwsXG4gICAgICBobnN3OiBqc29uLmhuc3cgPyBjbG9uZU9iamVjdChqc29uLmhuc3cpIDogbnVsbCxcbiAgICAgIHNwYW5uOiBqc29uLnNwYW5uID8gY2xvbmVPYmplY3QoanNvbi5zcGFubikgOiBudWxsXG4gICAgfSk7XG4gICAgY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uID0gYXdhaXQgZ2V0RW1iZWRkaW5nRnVuY3Rpb24oe1xuICAgICAgY29sbGVjdGlvbk5hbWU6IFwic2NoZW1hIGRlc2VyaWFsaXphdGlvblwiLFxuICAgICAgY2xpZW50OiBjbGllbnQyLFxuICAgICAgZWZDb25maWc6IGpzb24uZW1iZWRkaW5nX2Z1bmN0aW9uXG4gICAgfSk7XG4gICAgaWYgKCFjb25maWcuc3BhY2UgJiYgY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uPy5kZWZhdWx0U3BhY2UpIHtcbiAgICAgIGNvbmZpZy5zcGFjZSA9IGNvbmZpZy5lbWJlZGRpbmdGdW5jdGlvbi5kZWZhdWx0U3BhY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemVTcGFyc2VWZWN0b3JDb25maWcoanNvbiwgY2xpZW50Mikge1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBTcGFyc2VWZWN0b3JJbmRleENvbmZpZyh7XG4gICAgICBzb3VyY2VLZXk6IGpzb24uc291cmNlX2tleSA/PyBudWxsLFxuICAgICAgYm0yNTogdHlwZW9mIGpzb24uYm0yNSA9PT0gXCJib29sZWFuXCIgPyBqc29uLmJtMjUgOiBudWxsXG4gICAgfSk7XG4gICAgY29uc3QgZW1iZWRkaW5nRnVuY3Rpb24gPSBhd2FpdCBnZXRTcGFyc2VFbWJlZGRpbmdGdW5jdGlvbihcbiAgICAgIFwic2NoZW1hIGRlc2VyaWFsaXphdGlvblwiLFxuICAgICAgY2xpZW50MixcbiAgICAgIGpzb24uZW1iZWRkaW5nX2Z1bmN0aW9uXG4gICAgKSA/PyBjb25maWcuZW1iZWRkaW5nRnVuY3Rpb24gPz8gdm9pZCAwO1xuICAgIGNvbmZpZy5lbWJlZGRpbmdGdW5jdGlvbiA9IGVtYmVkZGluZ0Z1bmN0aW9uID8/IG51bGw7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICByZXNvbHZlRW1iZWRkaW5nRnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZW1iZWRkaW5nT3ZlcnJpZGUgPSB0aGlzLmtleXNbRU1CRURESU5HX0tFWV0/LmZsb2F0TGlzdD8udmVjdG9ySW5kZXg/LmNvbmZpZy5lbWJlZGRpbmdGdW5jdGlvbjtcbiAgICBpZiAoZW1iZWRkaW5nT3ZlcnJpZGUgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGVtYmVkZGluZ092ZXJyaWRlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0cy5mbG9hdExpc3Q/LnZlY3RvckluZGV4Py5jb25maWcuZW1iZWRkaW5nRnVuY3Rpb247XG4gIH1cbn07XG5cbi8vIHNyYy9jb2xsZWN0aW9uLnRzXG52YXIgQ29sbGVjdGlvbkltcGwgPSBjbGFzcyBfQ29sbGVjdGlvbkltcGwge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDb2xsZWN0aW9uQVBJSW1wbCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIGZvciB0aGUgY29sbGVjdGlvbiBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaHJvbWFDbGllbnQsXG4gICAgYXBpQ2xpZW50LFxuICAgIGlkLFxuICAgIHRlbmFudCxcbiAgICBkYXRhYmFzZSxcbiAgICBuYW1lLFxuICAgIG1ldGFkYXRhLFxuICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgZW1iZWRkaW5nRnVuY3Rpb24sXG4gICAgc2NoZW1hXG4gIH0pIHtcbiAgICB0aGlzLmNocm9tYUNsaWVudCA9IGNocm9tYUNsaWVudDtcbiAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy50ZW5hbnQgPSB0ZW5hbnQ7XG4gICAgdGhpcy5kYXRhYmFzZSA9IGRhdGFiYXNlO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX21ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgdGhpcy5fY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5fZW1iZWRkaW5nRnVuY3Rpb24gPSBlbWJlZGRpbmdGdW5jdGlvbjtcbiAgICB0aGlzLl9zY2hlbWEgPSBzY2hlbWE7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG4gIGdldCBjb25maWd1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWd1cmF0aW9uO1xuICB9XG4gIHNldCBjb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgICB0aGlzLl9jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgfVxuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhO1xuICB9XG4gIHNldCBtZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIHRoaXMuX21ldGFkYXRhID0gbWV0YWRhdGE7XG4gIH1cbiAgZ2V0IGVtYmVkZGluZ0Z1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbWJlZGRpbmdGdW5jdGlvbjtcbiAgfVxuICBzZXQgZW1iZWRkaW5nRnVuY3Rpb24oZW1iZWRkaW5nRnVuY3Rpb24pIHtcbiAgICB0aGlzLl9lbWJlZGRpbmdGdW5jdGlvbiA9IGVtYmVkZGluZ0Z1bmN0aW9uO1xuICB9XG4gIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NjaGVtYTtcbiAgfVxuICBzZXQgc2NoZW1hKHNjaGVtYSkge1xuICAgIHRoaXMuX3NjaGVtYSA9IHNjaGVtYTtcbiAgfVxuICBhc3luYyBwYXRoKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZW5hbnQ6IHRoaXMudGVuYW50LFxuICAgICAgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2UsXG4gICAgICBjb2xsZWN0aW9uX2lkOiB0aGlzLmlkXG4gICAgfTtcbiAgfVxuICBhc3luYyBlbWJlZChpbnB1dHMsIGlzUXVlcnkpIHtcbiAgICBjb25zdCBlbWJlZGRpbmdGdW5jdGlvbiA9IHRoaXMuX2VtYmVkZGluZ0Z1bmN0aW9uID8/IHRoaXMuZ2V0U2NoZW1hRW1iZWRkaW5nRnVuY3Rpb24oKTtcbiAgICBpZiAoIWVtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgXCJFbWJlZGRpbmcgZnVuY3Rpb24gbXVzdCBiZSBkZWZpbmVkIGZvciBvcGVyYXRpb25zIHJlcXVpcmluZyBlbWJlZGRpbmdzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNRdWVyeSAmJiBlbWJlZGRpbmdGdW5jdGlvbi5nZW5lcmF0ZUZvclF1ZXJpZXMpIHtcbiAgICAgIHJldHVybiBhd2FpdCBlbWJlZGRpbmdGdW5jdGlvbi5nZW5lcmF0ZUZvclF1ZXJpZXMoaW5wdXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGVtYmVkZGluZ0Z1bmN0aW9uLmdlbmVyYXRlKGlucHV0cyk7XG4gIH1cbiAgYXN5bmMgc3BhcnNlRW1iZWQoc3BhcnNlRW1iZWRkaW5nRnVuY3Rpb24sIGlucHV0cywgaXNRdWVyeSkge1xuICAgIGlmIChpc1F1ZXJ5ICYmIHNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9uLmdlbmVyYXRlRm9yUXVlcmllcykge1xuICAgICAgcmV0dXJuIGF3YWl0IHNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9uLmdlbmVyYXRlRm9yUXVlcmllcyhpbnB1dHMpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgc3BhcnNlRW1iZWRkaW5nRnVuY3Rpb24uZ2VuZXJhdGUoaW5wdXRzKTtcbiAgfVxuICBnZXRTcGFyc2VFbWJlZGRpbmdUYXJnZXRzKCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX3NjaGVtYTtcbiAgICBpZiAoIXNjaGVtYSkgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHRhcmdldHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlVHlwZXNdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5rZXlzKSkge1xuICAgICAgY29uc3Qgc3BhcnNlVmVjdG9yID0gdmFsdWVUeXBlcy5zcGFyc2VWZWN0b3I7XG4gICAgICBjb25zdCBzcGFyc2VJbmRleCA9IHNwYXJzZVZlY3Rvcj8uc3BhcnNlVmVjdG9ySW5kZXg7XG4gICAgICBpZiAoIXNwYXJzZUluZGV4Py5lbmFibGVkKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHNwYXJzZUluZGV4LmNvbmZpZztcbiAgICAgIGlmICghY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uIHx8ICFjb25maWcuc291cmNlS2V5KSBjb250aW51ZTtcbiAgICAgIHRhcmdldHNba2V5XSA9IGNvbmZpZztcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldHM7XG4gIH1cbiAgYXN5bmMgYXBwbHlTcGFyc2VFbWJlZGRpbmdzVG9NZXRhZGF0YXMobWV0YWRhdGFzLCBkb2N1bWVudHMpIHtcbiAgICBjb25zdCBzcGFyc2VUYXJnZXRzID0gdGhpcy5nZXRTcGFyc2VFbWJlZGRpbmdUYXJnZXRzKCk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNwYXJzZVRhcmdldHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG1ldGFkYXRhcztcbiAgICB9XG4gICAgaWYgKCFtZXRhZGF0YXMpIHtcbiAgICAgIGlmICghZG9jdW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBtZXRhZGF0YXMgPSBBcnJheShkb2N1bWVudHMubGVuZ3RoKS5maWxsKG51bGwpLm1hcCgoKSA9PiAoe30pKTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZE1ldGFkYXRhcyA9IG1ldGFkYXRhcy5tYXAoXG4gICAgICAobWV0YWRhdGEpID0+IG1ldGFkYXRhICE9PSBudWxsICYmIG1ldGFkYXRhICE9PSB2b2lkIDAgPyB7IC4uLm1ldGFkYXRhIH0gOiB7fVxuICAgICk7XG4gICAgY29uc3QgZG9jdW1lbnRzTGlzdCA9IGRvY3VtZW50cyA/IFsuLi5kb2N1bWVudHNdIDogdm9pZCAwO1xuICAgIGZvciAoY29uc3QgW3RhcmdldEtleSwgY29uZmlnXSBvZiBPYmplY3QuZW50cmllcyhzcGFyc2VUYXJnZXRzKSkge1xuICAgICAgY29uc3Qgc291cmNlS2V5ID0gY29uZmlnLnNvdXJjZUtleTtcbiAgICAgIGNvbnN0IGVtYmVkZGluZ0Z1bmN0aW9uID0gY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uO1xuICAgICAgaWYgKCFzb3VyY2VLZXkgfHwgIWVtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRzID0gW107XG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgIGlmIChzb3VyY2VLZXkgPT09IERPQ1VNRU5UX0tFWSkge1xuICAgICAgICBpZiAoIWRvY3VtZW50c0xpc3QpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkTWV0YWRhdGFzLmZvckVhY2goKG1ldGFkYXRhLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmICh0YXJnZXRLZXkgaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4IDwgZG9jdW1lbnRzTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50c0xpc3RbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgaW5wdXRzLnB1c2goZG9jKTtcbiAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BhcnNlRW1iZWRkaW5nczIgPSBhd2FpdCB0aGlzLnNwYXJzZUVtYmVkKFxuICAgICAgICAgIGVtYmVkZGluZ0Z1bmN0aW9uLFxuICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICBpZiAoc3BhcnNlRW1iZWRkaW5nczIubGVuZ3RoICE9PSBwb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgICAgICBcIlNwYXJzZSBlbWJlZGRpbmcgZnVuY3Rpb24gcmV0dXJuZWQgdW5leHBlY3RlZCBudW1iZXIgb2YgZW1iZWRkaW5ncy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25zLmZvckVhY2goKHBvc2l0aW9uLCBpZHgpID0+IHtcbiAgICAgICAgICB1cGRhdGVkTWV0YWRhdGFzW3Bvc2l0aW9uXVt0YXJnZXRLZXldID0gc3BhcnNlRW1iZWRkaW5nczJbaWR4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdXBkYXRlZE1ldGFkYXRhcy5mb3JFYWNoKChtZXRhZGF0YSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKHRhcmdldEtleSBpbiBtZXRhZGF0YSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IG1ldGFkYXRhW3NvdXJjZUtleV07XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlVmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRzLnB1c2goc291cmNlVmFsdWUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChpbmRleCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BhcnNlRW1iZWRkaW5ncyA9IGF3YWl0IHRoaXMuc3BhcnNlRW1iZWQoXG4gICAgICAgIGVtYmVkZGluZ0Z1bmN0aW9uLFxuICAgICAgICBpbnB1dHMsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgaWYgKHNwYXJzZUVtYmVkZGluZ3MubGVuZ3RoICE9PSBwb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIFwiU3BhcnNlIGVtYmVkZGluZyBmdW5jdGlvbiByZXR1cm5lZCB1bmV4cGVjdGVkIG51bWJlciBvZiBlbWJlZGRpbmdzLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zaXRpb24sIGlkeCkgPT4ge1xuICAgICAgICB1cGRhdGVkTWV0YWRhdGFzW3Bvc2l0aW9uXVt0YXJnZXRLZXldID0gc3BhcnNlRW1iZWRkaW5nc1tpZHhdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdE1ldGFkYXRhcyA9IHVwZGF0ZWRNZXRhZGF0YXMubWFwKFxuICAgICAgKG1ldGFkYXRhKSA9PiBPYmplY3Qua2V5cyhtZXRhZGF0YSkubGVuZ3RoID09PSAwID8gbnVsbCA6IG1ldGFkYXRhXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0TWV0YWRhdGFzO1xuICB9XG4gIGFzeW5jIGVtYmVkS25uTGl0ZXJhbChrbm4pIHtcbiAgICBjb25zdCBxdWVyeVZhbHVlID0ga25uLnF1ZXJ5O1xuICAgIGlmICh0eXBlb2YgcXVlcnlWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHsgLi4ua25uIH07XG4gICAgfVxuICAgIGNvbnN0IGtleVZhbHVlID0ga25uLmtleTtcbiAgICBjb25zdCBrZXkgPSB0eXBlb2Yga2V5VmFsdWUgPT09IFwic3RyaW5nXCIgPyBrZXlWYWx1ZSA6IEVNQkVERElOR19LRVk7XG4gICAgaWYgKGtleSA9PT0gRU1CRURESU5HX0tFWSkge1xuICAgICAgY29uc3QgZW1iZWRkaW5ncyA9IGF3YWl0IHRoaXMuZW1iZWQoW3F1ZXJ5VmFsdWVdLCB0cnVlKTtcbiAgICAgIGlmICghZW1iZWRkaW5ncyB8fCBlbWJlZGRpbmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgICBcIkVtYmVkZGluZyBmdW5jdGlvbiByZXR1cm5lZCB1bmV4cGVjdGVkIG51bWJlciBvZiBlbWJlZGRpbmdzLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5rbm4sIHF1ZXJ5OiBlbWJlZGRpbmdzWzBdIH07XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX3NjaGVtYTtcbiAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZW1iZWQgc3RyaW5nIHF1ZXJ5IGZvciBrZXkgJyR7a2V5fSc6IHNjaGVtYSBpcyBub3QgYXZhaWxhYmxlLiBQcm92aWRlIGFuIGVtYmVkZGVkIHZlY3RvciBvciBjb25maWd1cmUgYW4gZW1iZWRkaW5nIGZ1bmN0aW9uLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlVHlwZXMgPSBzY2hlbWEua2V5c1trZXldO1xuICAgIGlmICghdmFsdWVUeXBlcykge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZW1iZWQgc3RyaW5nIHF1ZXJ5IGZvciBrZXkgJyR7a2V5fSc6IGtleSBub3QgZm91bmQgaW4gc2NoZW1hLiBQcm92aWRlIGFuIGVtYmVkZGVkIHZlY3RvciBvciBjb25maWd1cmUgYW4gZW1iZWRkaW5nIGZ1bmN0aW9uLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHNwYXJzZUluZGV4ID0gdmFsdWVUeXBlcy5zcGFyc2VWZWN0b3I/LnNwYXJzZVZlY3RvckluZGV4O1xuICAgIGlmIChzcGFyc2VJbmRleD8uZW5hYmxlZCAmJiBzcGFyc2VJbmRleC5jb25maWcuZW1iZWRkaW5nRnVuY3Rpb24pIHtcbiAgICAgIGNvbnN0IHNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9uID0gc3BhcnNlSW5kZXguY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uO1xuICAgICAgY29uc3Qgc3BhcnNlRW1iZWRkaW5ncyA9IGF3YWl0IHRoaXMuc3BhcnNlRW1iZWQoXG4gICAgICAgIHNwYXJzZUVtYmVkZGluZ0Z1bmN0aW9uLFxuICAgICAgICBbcXVlcnlWYWx1ZV0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBpZiAoIXNwYXJzZUVtYmVkZGluZ3MgfHwgc3BhcnNlRW1iZWRkaW5ncy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgICAgXCJTcGFyc2UgZW1iZWRkaW5nIGZ1bmN0aW9uIHJldHVybmVkIHVuZXhwZWN0ZWQgbnVtYmVyIG9mIGVtYmVkZGluZ3MuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmtubiwgcXVlcnk6IHNwYXJzZUVtYmVkZGluZ3NbMF0gfTtcbiAgICB9XG4gICAgY29uc3QgdmVjdG9ySW5kZXggPSB2YWx1ZVR5cGVzLmZsb2F0TGlzdD8udmVjdG9ySW5kZXg7XG4gICAgaWYgKHZlY3RvckluZGV4Py5lbmFibGVkICYmIHZlY3RvckluZGV4LmNvbmZpZy5lbWJlZGRpbmdGdW5jdGlvbikge1xuICAgICAgY29uc3QgZW1iZWRkaW5nRnVuY3Rpb24gPSB2ZWN0b3JJbmRleC5jb25maWcuZW1iZWRkaW5nRnVuY3Rpb247XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gZW1iZWRkaW5nRnVuY3Rpb24uZ2VuZXJhdGVGb3JRdWVyaWVzID8gYXdhaXQgZW1iZWRkaW5nRnVuY3Rpb24uZ2VuZXJhdGVGb3JRdWVyaWVzKFtxdWVyeVZhbHVlXSkgOiBhd2FpdCBlbWJlZGRpbmdGdW5jdGlvbi5nZW5lcmF0ZShbcXVlcnlWYWx1ZV0pO1xuICAgICAgaWYgKCFlbWJlZGRpbmdzIHx8IGVtYmVkZGluZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIFwiRW1iZWRkaW5nIGZ1bmN0aW9uIHJldHVybmVkIHVuZXhwZWN0ZWQgbnVtYmVyIG9mIGVtYmVkZGluZ3MuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmtubiwgcXVlcnk6IGVtYmVkZGluZ3NbMF0gfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgQ2Fubm90IGVtYmVkIHN0cmluZyBxdWVyeSBmb3Iga2V5ICcke2tleX0nOiBubyBlbWJlZGRpbmcgZnVuY3Rpb24gY29uZmlndXJlZC4gUHJvdmlkZSBhbiBlbWJlZGRlZCB2ZWN0b3Igb3IgY29uZmlndXJlIGFuIGVtYmVkZGluZyBmdW5jdGlvbi5gXG4gICAgKTtcbiAgfVxuICBhc3luYyBlbWJlZFJhbmtMaXRlcmFsKHJhbmspIHtcbiAgICBpZiAocmFuayA9PT0gbnVsbCB8fCByYW5rID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiByYW5rO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyYW5rKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJhbmsubWFwKChpdGVtKSA9PiB0aGlzLmVtYmVkUmFua0xpdGVyYWwoaXRlbSkpKTtcbiAgICB9XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHJhbmspKSB7XG4gICAgICByZXR1cm4gcmFuaztcbiAgICB9XG4gICAgY29uc3QgZW50cmllcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmFuaykubWFwKGFzeW5jIChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCIka25uXCIgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gW2tleSwgYXdhaXQgdGhpcy5lbWJlZEtubkxpdGVyYWwodmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2tleSwgYXdhaXQgdGhpcy5lbWJlZFJhbmtMaXRlcmFsKHZhbHVlKV07XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzKTtcbiAgfVxuICBhc3luYyBlbWJlZFNlYXJjaFBheWxvYWQocGF5bG9hZCkge1xuICAgIGlmICghcGF5bG9hZC5yYW5rKSB7XG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgY29uc3QgZW1iZWRkZWRSYW5rID0gYXdhaXQgdGhpcy5lbWJlZFJhbmtMaXRlcmFsKHBheWxvYWQucmFuayk7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGVtYmVkZGVkUmFuaykpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGF5bG9hZCxcbiAgICAgIHJhbms6IGVtYmVkZGVkUmFua1xuICAgIH07XG4gIH1cbiAgZ2V0U2NoZW1hRW1iZWRkaW5nRnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fc2NoZW1hO1xuICAgIGlmICghc2NoZW1hKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IHNjaGVtYU92ZXJyaWRlID0gc2NoZW1hLmtleXNbRU1CRURESU5HX0tFWV07XG4gICAgY29uc3Qgb3ZlcnJpZGVGdW5jdGlvbiA9IHNjaGVtYU92ZXJyaWRlPy5mbG9hdExpc3Q/LnZlY3RvckluZGV4Py5jb25maWcuZW1iZWRkaW5nRnVuY3Rpb247XG4gICAgaWYgKG92ZXJyaWRlRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiBvdmVycmlkZUZ1bmN0aW9uO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0RnVuY3Rpb24gPSBzY2hlbWEuZGVmYXVsdHMuZmxvYXRMaXN0Py52ZWN0b3JJbmRleD8uY29uZmlnLmVtYmVkZGluZ0Z1bmN0aW9uO1xuICAgIHJldHVybiBkZWZhdWx0RnVuY3Rpb24gPz8gdm9pZCAwO1xuICB9XG4gIGFzeW5jIHByZXBhcmVSZWNvcmRzKHtcbiAgICByZWNvcmRTZXQsXG4gICAgdXBkYXRlID0gZmFsc2VcbiAgfSkge1xuICAgIGNvbnN0IG1heEJhdGNoU2l6ZSA9IGF3YWl0IHRoaXMuY2hyb21hQ2xpZW50LmdldE1heEJhdGNoU2l6ZSgpO1xuICAgIHZhbGlkYXRlUmVjb3JkU2V0TGVuZ3RoQ29uc2lzdGVuY3kocmVjb3JkU2V0KTtcbiAgICB2YWxpZGF0ZUlEcyhyZWNvcmRTZXQuaWRzKTtcbiAgICB2YWxpZGF0ZUJhc2VSZWNvcmRTZXQoeyByZWNvcmRTZXQsIHVwZGF0ZSB9KTtcbiAgICB2YWxpZGF0ZU1heEJhdGNoU2l6ZShyZWNvcmRTZXQuaWRzLmxlbmd0aCwgbWF4QmF0Y2hTaXplKTtcbiAgICBpZiAoIXJlY29yZFNldC5lbWJlZGRpbmdzICYmIHJlY29yZFNldC5kb2N1bWVudHMpIHtcbiAgICAgIHJlY29yZFNldC5lbWJlZGRpbmdzID0gYXdhaXQgdGhpcy5lbWJlZChyZWNvcmRTZXQuZG9jdW1lbnRzLCBmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhc1dpdGhTcGFyc2UgPSBhd2FpdCB0aGlzLmFwcGx5U3BhcnNlRW1iZWRkaW5nc1RvTWV0YWRhdGFzKFxuICAgICAgcmVjb3JkU2V0Lm1ldGFkYXRhcyxcbiAgICAgIHJlY29yZFNldC5kb2N1bWVudHNcbiAgICApO1xuICAgIGNvbnN0IHByZXBhcmVkUmVjb3JkU2V0ID0ge1xuICAgICAgLi4ucmVjb3JkU2V0LFxuICAgICAgbWV0YWRhdGFzOiBtZXRhZGF0YXNXaXRoU3BhcnNlXG4gICAgfTtcbiAgICBjb25zdCBiYXNlNjRTdXBwb3J0ZWQgPSBhd2FpdCB0aGlzLmNocm9tYUNsaWVudC5zdXBwb3J0c0Jhc2U2NEVuY29kaW5nKCk7XG4gICAgaWYgKGJhc2U2NFN1cHBvcnRlZCAmJiByZWNvcmRTZXQuZW1iZWRkaW5ncykge1xuICAgICAgcHJlcGFyZWRSZWNvcmRTZXQuZW1iZWRkaW5ncyA9IGVtYmVkZGluZ3NUb0Jhc2U2NEJ5dGVzKFxuICAgICAgICByZWNvcmRTZXQuZW1iZWRkaW5nc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXBhcmVkUmVjb3JkU2V0O1xuICB9XG4gIHZhbGlkYXRlR2V0KGluY2x1ZGUsIGlkcywgd2hlcmUsIHdoZXJlRG9jdW1lbnQpIHtcbiAgICB2YWxpZGF0ZUluY2x1ZGUoeyBpbmNsdWRlLCBleGNsdWRlOiBbXCJkaXN0YW5jZXNcIl0gfSk7XG4gICAgaWYgKGlkcykgdmFsaWRhdGVJRHMoaWRzKTtcbiAgICBpZiAod2hlcmUpIHZhbGlkYXRlV2hlcmUod2hlcmUpO1xuICAgIGlmICh3aGVyZURvY3VtZW50KSB2YWxpZGF0ZVdoZXJlRG9jdW1lbnQod2hlcmVEb2N1bWVudCk7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZVF1ZXJ5KHJlY29yZFNldCwgaW5jbHVkZSwgaWRzLCB3aGVyZSwgd2hlcmVEb2N1bWVudCwgblJlc3VsdHMpIHtcbiAgICB2YWxpZGF0ZUJhc2VSZWNvcmRTZXQoe1xuICAgICAgcmVjb3JkU2V0LFxuICAgICAgZW1iZWRkaW5nc0ZpZWxkOiBcInF1ZXJ5RW1iZWRkaW5nc1wiLFxuICAgICAgZG9jdW1lbnRzRmllbGQ6IFwicXVlcnlUZXh0c1wiXG4gICAgfSk7XG4gICAgdmFsaWRhdGVJbmNsdWRlKHsgaW5jbHVkZSB9KTtcbiAgICBpZiAoaWRzKSB2YWxpZGF0ZUlEcyhpZHMpO1xuICAgIGlmICh3aGVyZSkgdmFsaWRhdGVXaGVyZSh3aGVyZSk7XG4gICAgaWYgKHdoZXJlRG9jdW1lbnQpIHZhbGlkYXRlV2hlcmVEb2N1bWVudCh3aGVyZURvY3VtZW50KTtcbiAgICBpZiAoblJlc3VsdHMpIHZhbGlkYXRlTlJlc3VsdHMoblJlc3VsdHMpO1xuICAgIGxldCBlbWJlZGRpbmdzO1xuICAgIGlmICghcmVjb3JkU2V0LmVtYmVkZGluZ3MpIHtcbiAgICAgIGVtYmVkZGluZ3MgPSBhd2FpdCB0aGlzLmVtYmVkKHJlY29yZFNldC5kb2N1bWVudHMsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWJlZGRpbmdzID0gcmVjb3JkU2V0LmVtYmVkZGluZ3M7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5yZWNvcmRTZXQsXG4gICAgICBpZHMsXG4gICAgICBlbWJlZGRpbmdzXG4gICAgfTtcbiAgfVxuICB2YWxpZGF0ZURlbGV0ZShpZHMsIHdoZXJlLCB3aGVyZURvY3VtZW50KSB7XG4gICAgaWYgKGlkcykgdmFsaWRhdGVJRHMoaWRzKTtcbiAgICBpZiAod2hlcmUpIHZhbGlkYXRlV2hlcmUod2hlcmUpO1xuICAgIGlmICh3aGVyZURvY3VtZW50KSB2YWxpZGF0ZVdoZXJlRG9jdW1lbnQod2hlcmVEb2N1bWVudCk7XG4gIH1cbiAgYXN5bmMgY291bnQoKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5jb2xsZWN0aW9uQ291bnQoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgYWRkKHtcbiAgICBpZHMsXG4gICAgZW1iZWRkaW5ncyxcbiAgICBtZXRhZGF0YXMsXG4gICAgZG9jdW1lbnRzLFxuICAgIHVyaXNcbiAgfSkge1xuICAgIGNvbnN0IHJlY29yZFNldCA9IHtcbiAgICAgIGlkcyxcbiAgICAgIGVtYmVkZGluZ3MsXG4gICAgICBkb2N1bWVudHMsXG4gICAgICBtZXRhZGF0YXMsXG4gICAgICB1cmlzXG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlZFJlY29yZFNldCA9IGF3YWl0IHRoaXMucHJlcGFyZVJlY29yZHMoeyByZWNvcmRTZXQgfSk7XG4gICAgYXdhaXQgRGVmYXVsdFNlcnZpY2UuY29sbGVjdGlvbkFkZCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIGlkczogcHJlcGFyZWRSZWNvcmRTZXQuaWRzLFxuICAgICAgICBlbWJlZGRpbmdzOiBwcmVwYXJlZFJlY29yZFNldC5lbWJlZGRpbmdzLFxuICAgICAgICBkb2N1bWVudHM6IHByZXBhcmVkUmVjb3JkU2V0LmRvY3VtZW50cyxcbiAgICAgICAgbWV0YWRhdGFzOiBzZXJpYWxpemVNZXRhZGF0YXMocHJlcGFyZWRSZWNvcmRTZXQubWV0YWRhdGFzKSxcbiAgICAgICAgdXJpczogcHJlcGFyZWRSZWNvcmRTZXQudXJpc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldChhcmdzID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBpZHMsXG4gICAgICB3aGVyZSxcbiAgICAgIGxpbWl0LFxuICAgICAgb2Zmc2V0LFxuICAgICAgd2hlcmVEb2N1bWVudCxcbiAgICAgIGluY2x1ZGUgPSBbXCJkb2N1bWVudHNcIiwgXCJtZXRhZGF0YXNcIl1cbiAgICB9ID0gYXJncztcbiAgICB0aGlzLnZhbGlkYXRlR2V0KGluY2x1ZGUsIGlkcywgd2hlcmUsIHdoZXJlRG9jdW1lbnQpO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuY29sbGVjdGlvbkdldCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIGlkcyxcbiAgICAgICAgd2hlcmUsXG4gICAgICAgIGxpbWl0LFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHdoZXJlX2RvY3VtZW50OiB3aGVyZURvY3VtZW50LFxuICAgICAgICBpbmNsdWRlXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZGVzZXJpYWxpemVkTWV0YWRhdGFzID0gZGVzZXJpYWxpemVNZXRhZGF0YXMoZGF0YS5tZXRhZGF0YXMpID8/IFtdO1xuICAgIHJldHVybiBuZXcgR2V0UmVzdWx0KHtcbiAgICAgIGRvY3VtZW50czogZGF0YS5kb2N1bWVudHMgPz8gW10sXG4gICAgICBlbWJlZGRpbmdzOiBkYXRhLmVtYmVkZGluZ3MgPz8gW10sXG4gICAgICBpZHM6IGRhdGEuaWRzLFxuICAgICAgaW5jbHVkZTogZGF0YS5pbmNsdWRlLFxuICAgICAgbWV0YWRhdGFzOiBkZXNlcmlhbGl6ZWRNZXRhZGF0YXMsXG4gICAgICB1cmlzOiBkYXRhLnVyaXMgPz8gW11cbiAgICB9KTtcbiAgfVxuICBhc3luYyBwZWVrKHsgbGltaXQgPSAxMCB9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHsgbGltaXQgfSk7XG4gIH1cbiAgYXN5bmMgcXVlcnkoe1xuICAgIHF1ZXJ5RW1iZWRkaW5ncyxcbiAgICBxdWVyeVRleHRzLFxuICAgIHF1ZXJ5VVJJcyxcbiAgICBpZHMsXG4gICAgblJlc3VsdHMgPSAxMCxcbiAgICB3aGVyZSxcbiAgICB3aGVyZURvY3VtZW50LFxuICAgIGluY2x1ZGUgPSBbXCJtZXRhZGF0YXNcIiwgXCJkb2N1bWVudHNcIiwgXCJkaXN0YW5jZXNcIl1cbiAgfSkge1xuICAgIGNvbnN0IHJlY29yZFNldCA9IHtcbiAgICAgIGVtYmVkZGluZ3M6IHF1ZXJ5RW1iZWRkaW5ncyxcbiAgICAgIGRvY3VtZW50czogcXVlcnlUZXh0cyxcbiAgICAgIHVyaXM6IHF1ZXJ5VVJJc1xuICAgIH07XG4gICAgY29uc3QgcXVlcnlSZWNvcmRTZXQgPSBhd2FpdCB0aGlzLnByZXBhcmVRdWVyeShcbiAgICAgIHJlY29yZFNldCxcbiAgICAgIGluY2x1ZGUsXG4gICAgICBpZHMsXG4gICAgICB3aGVyZSxcbiAgICAgIHdoZXJlRG9jdW1lbnQsXG4gICAgICBuUmVzdWx0c1xuICAgICk7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5jb2xsZWN0aW9uUXVlcnkoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keToge1xuICAgICAgICBpZHM6IHF1ZXJ5UmVjb3JkU2V0LmlkcyxcbiAgICAgICAgaW5jbHVkZSxcbiAgICAgICAgbl9yZXN1bHRzOiBuUmVzdWx0cyxcbiAgICAgICAgcXVlcnlfZW1iZWRkaW5nczogcXVlcnlSZWNvcmRTZXQuZW1iZWRkaW5ncyxcbiAgICAgICAgd2hlcmUsXG4gICAgICAgIHdoZXJlX2RvY3VtZW50OiB3aGVyZURvY3VtZW50XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZGVzZXJpYWxpemVkTWV0YWRhdGFzID0gZGVzZXJpYWxpemVNZXRhZGF0YU1hdHJpeChkYXRhLm1ldGFkYXRhcykgPz8gW107XG4gICAgcmV0dXJuIG5ldyBRdWVyeVJlc3VsdCh7XG4gICAgICBkaXN0YW5jZXM6IGRhdGEuZGlzdGFuY2VzID8/IFtdLFxuICAgICAgZG9jdW1lbnRzOiBkYXRhLmRvY3VtZW50cyA/PyBbXSxcbiAgICAgIGVtYmVkZGluZ3M6IGRhdGEuZW1iZWRkaW5ncyA/PyBbXSxcbiAgICAgIGlkczogZGF0YS5pZHMgPz8gW10sXG4gICAgICBpbmNsdWRlOiBkYXRhLmluY2x1ZGUsXG4gICAgICBtZXRhZGF0YXM6IGRlc2VyaWFsaXplZE1ldGFkYXRhcyxcbiAgICAgIHVyaXM6IGRhdGEudXJpcyA/PyBbXVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNlYXJjaChzZWFyY2hlcykge1xuICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuaXNBcnJheShzZWFyY2hlcykgPyBzZWFyY2hlcyA6IFtzZWFyY2hlc107XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIFwiQXQgbGVhc3Qgb25lIHNlYXJjaCBwYXlsb2FkIG11c3QgYmUgcHJvdmlkZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBpdGVtcy5tYXAoYXN5bmMgKHNlYXJjaCkgPT4ge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gdG9TZWFyY2goc2VhcmNoKS50b1BheWxvYWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1iZWRTZWFyY2hQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgfSlcbiAgICApO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuY29sbGVjdGlvblNlYXJjaCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5wYXRoKCksXG4gICAgICBib2R5OiB7IHNlYXJjaGVzOiBwYXlsb2FkcyB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hSZXN1bHQoZGF0YSk7XG4gIH1cbiAgYXN5bmMgbW9kaWZ5KHtcbiAgICBuYW1lLFxuICAgIG1ldGFkYXRhLFxuICAgIGNvbmZpZ3VyYXRpb25cbiAgfSkge1xuICAgIGlmIChuYW1lKSB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgdmFsaWRhdGVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgfVxuICAgIGNvbnN0IHsgdXBkYXRlQ29uZmlndXJhdGlvbiwgdXBkYXRlRW1iZWRkaW5nRnVuY3Rpb24gfSA9IGNvbmZpZ3VyYXRpb24gPyBhd2FpdCBwcm9jZXNzVXBkYXRlQ29sbGVjdGlvbkNvbmZpZyh7XG4gICAgICBjb2xsZWN0aW9uTmFtZTogdGhpcy5uYW1lLFxuICAgICAgY3VycmVudENvbmZpZ3VyYXRpb246IHRoaXMuY29uZmlndXJhdGlvbixcbiAgICAgIG5ld0NvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICBjdXJyZW50RW1iZWRkaW5nRnVuY3Rpb246IHRoaXMuZW1iZWRkaW5nRnVuY3Rpb24sXG4gICAgICBjbGllbnQ6IHRoaXMuY2hyb21hQ2xpZW50XG4gICAgfSkgOiB7fTtcbiAgICBpZiAodXBkYXRlRW1iZWRkaW5nRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuZW1iZWRkaW5nRnVuY3Rpb24gPSB1cGRhdGVFbWJlZGRpbmdGdW5jdGlvbjtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgaG5zdzogeyAuLi50aGlzLmNvbmZpZ3VyYXRpb24uaG5zdywgLi4udXBkYXRlQ29uZmlndXJhdGlvbi5obnN3IH0sXG4gICAgICAgIHNwYW5uOiB7IC4uLnRoaXMuY29uZmlndXJhdGlvbi5zcGFubiwgLi4udXBkYXRlQ29uZmlndXJhdGlvbi5zcGFubiB9LFxuICAgICAgICBlbWJlZGRpbmdGdW5jdGlvbjogdXBkYXRlQ29uZmlndXJhdGlvbi5lbWJlZGRpbmdfZnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLnVwZGF0ZUNvbGxlY3Rpb24oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keToge1xuICAgICAgICBuZXdfbmFtZTogbmFtZSxcbiAgICAgICAgbmV3X21ldGFkYXRhOiBzZXJpYWxpemVNZXRhZGF0YShtZXRhZGF0YSksXG4gICAgICAgIG5ld19jb25maWd1cmF0aW9uOiB1cGRhdGVDb25maWd1cmF0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZm9yayh7IG5hbWUgfSkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuZm9ya0NvbGxlY3Rpb24oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keTogeyBuZXdfbmFtZTogbmFtZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBfQ29sbGVjdGlvbkltcGwoe1xuICAgICAgY2hyb21hQ2xpZW50OiB0aGlzLmNocm9tYUNsaWVudCxcbiAgICAgIGFwaUNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICB0ZW5hbnQ6IHRoaXMudGVuYW50LFxuICAgICAgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2UsXG4gICAgICBpZDogZGF0YS5pZCxcbiAgICAgIGVtYmVkZGluZ0Z1bmN0aW9uOiB0aGlzLl9lbWJlZGRpbmdGdW5jdGlvbixcbiAgICAgIG1ldGFkYXRhOiBkZXNlcmlhbGl6ZU1ldGFkYXRhKGRhdGEubWV0YWRhdGEgPz8gdm9pZCAwKSA/PyB2b2lkIDAsXG4gICAgICBjb25maWd1cmF0aW9uOiBkYXRhLmNvbmZpZ3VyYXRpb25fanNvblxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh7XG4gICAgaWRzLFxuICAgIGVtYmVkZGluZ3MsXG4gICAgbWV0YWRhdGFzLFxuICAgIGRvY3VtZW50cyxcbiAgICB1cmlzXG4gIH0pIHtcbiAgICBjb25zdCByZWNvcmRTZXQgPSB7XG4gICAgICBpZHMsXG4gICAgICBlbWJlZGRpbmdzLFxuICAgICAgZG9jdW1lbnRzLFxuICAgICAgbWV0YWRhdGFzLFxuICAgICAgdXJpc1xuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZWRSZWNvcmRTZXQgPSBhd2FpdCB0aGlzLnByZXBhcmVSZWNvcmRzKHtcbiAgICAgIHJlY29yZFNldCxcbiAgICAgIHVwZGF0ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNvbGxlY3Rpb25VcGRhdGUoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keToge1xuICAgICAgICBpZHM6IHByZXBhcmVkUmVjb3JkU2V0LmlkcyxcbiAgICAgICAgZW1iZWRkaW5nczogcHJlcGFyZWRSZWNvcmRTZXQuZW1iZWRkaW5ncyxcbiAgICAgICAgbWV0YWRhdGFzOiBzZXJpYWxpemVNZXRhZGF0YXMocHJlcGFyZWRSZWNvcmRTZXQubWV0YWRhdGFzKSxcbiAgICAgICAgdXJpczogcHJlcGFyZWRSZWNvcmRTZXQudXJpcyxcbiAgICAgICAgZG9jdW1lbnRzOiBwcmVwYXJlZFJlY29yZFNldC5kb2N1bWVudHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cHNlcnQoe1xuICAgIGlkcyxcbiAgICBlbWJlZGRpbmdzLFxuICAgIG1ldGFkYXRhcyxcbiAgICBkb2N1bWVudHMsXG4gICAgdXJpc1xuICB9KSB7XG4gICAgY29uc3QgcmVjb3JkU2V0ID0ge1xuICAgICAgaWRzLFxuICAgICAgZW1iZWRkaW5ncyxcbiAgICAgIGRvY3VtZW50cyxcbiAgICAgIG1ldGFkYXRhcyxcbiAgICAgIHVyaXNcbiAgICB9O1xuICAgIGNvbnN0IHByZXBhcmVkUmVjb3JkU2V0ID0gYXdhaXQgdGhpcy5wcmVwYXJlUmVjb3Jkcyh7XG4gICAgICByZWNvcmRTZXRcbiAgICB9KTtcbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS5jb2xsZWN0aW9uVXBzZXJ0KHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLnBhdGgoKSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgaWRzOiBwcmVwYXJlZFJlY29yZFNldC5pZHMsXG4gICAgICAgIGVtYmVkZGluZ3M6IHByZXBhcmVkUmVjb3JkU2V0LmVtYmVkZGluZ3MsXG4gICAgICAgIG1ldGFkYXRhczogc2VyaWFsaXplTWV0YWRhdGFzKHByZXBhcmVkUmVjb3JkU2V0Lm1ldGFkYXRhcyksXG4gICAgICAgIHVyaXM6IHByZXBhcmVkUmVjb3JkU2V0LnVyaXMsXG4gICAgICAgIGRvY3VtZW50czogcHJlcGFyZWRSZWNvcmRTZXQuZG9jdW1lbnRzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKHtcbiAgICBpZHMsXG4gICAgd2hlcmUsXG4gICAgd2hlcmVEb2N1bWVudFxuICB9KSB7XG4gICAgdGhpcy52YWxpZGF0ZURlbGV0ZShpZHMsIHdoZXJlLCB3aGVyZURvY3VtZW50KTtcbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS5jb2xsZWN0aW9uRGVsZXRlKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLnBhdGgoKSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgaWRzLFxuICAgICAgICB3aGVyZSxcbiAgICAgICAgd2hlcmVfZG9jdW1lbnQ6IHdoZXJlRG9jdW1lbnRcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL25leHQudHNcbmZ1bmN0aW9uIHdpdGhDaHJvbWEodXNlck5leHRDb25maWcgPSB7fSkge1xuICBjb25zdCBvcmlnaW5hbFdlYnBhY2tGdW5jdGlvbiA9IHVzZXJOZXh0Q29uZmlnLndlYnBhY2s7XG4gIGNvbnN0IG5ld1dlYnBhY2tGdW5jdGlvbiA9IChjb25maWcsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlnLmV4dGVybmFscykpIHtcbiAgICAgIGNvbmZpZy5leHRlcm5hbHMgPSBbXTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZXJuYWxzVG9BZGQgPSBbXCJAaHVnZ2luZ2ZhY2UvdHJhbnNmb3JtZXJzXCIsIFwiY2hyb21hZGJcIl07XG4gICAgZm9yIChjb25zdCBleHQgb2YgZXh0ZXJuYWxzVG9BZGQpIHtcbiAgICAgIGlmICghY29uZmlnLmV4dGVybmFscy5pbmNsdWRlcyhleHQpKSB7XG4gICAgICAgIGNvbmZpZy5leHRlcm5hbHMucHVzaChleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsV2VicGFja0Z1bmN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBvcmlnaW5hbFdlYnBhY2tGdW5jdGlvbihjb25maWcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9O1xuICByZXR1cm4ge1xuICAgIC4uLnVzZXJOZXh0Q29uZmlnLFxuICAgIHdlYnBhY2s6IG5ld1dlYnBhY2tGdW5jdGlvblxuICB9O1xufVxuXG4vLyBzcmMvY2hyb21hLWZldGNoLnRzXG52YXIgb2ZmbGluZUVycm9yID0gKGVycm9yKSA9PiB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIChlcnJvcj8ubmFtZSA9PT0gXCJUeXBlRXJyb3JcIiB8fCBlcnJvcj8ubmFtZSA9PT0gXCJGZXRjaEVycm9yXCIpICYmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcyhcImZldGNoIGZhaWxlZFwiKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcyhcIkVOT1RGT1VORFwiKSlcbiAgKTtcbn07XG52YXIgZ2V0RXJyb3JNZXNzYWdlID0gYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmNsb25lKCkuanNvbigpO1xuICAgIHJldHVybiBib2R5Lm1lc3NhZ2UgfHwgYm9keS5lcnJvciB8fCBgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICB9XG59O1xudmFyIGNocm9tYUZldGNoID0gYXN5bmMgKGlucHV0LCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZTtcbiAgdHJ5IHtcbiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKGlucHV0LCBpbml0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKG9mZmxpbmVFcnJvcihlcnIpKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBjb25uZWN0IHRvIGNocm9tYWRiLiBNYWtlIHN1cmUgeW91ciBzZXJ2ZXIgaXMgcnVubmluZyBhbmQgdHJ5IGFnYWluLiBJZiB5b3UgYXJlIHJ1bm5pbmcgZnJvbSBhIGJyb3dzZXIsIG1ha2Ugc3VyZSB0aGF0IHlvdXIgY2hyb21hZGIgaW5zdGFuY2UgaXMgY29uZmlndXJlZCB0byBhbGxvdyByZXF1ZXN0cyBmcm9tIHRoZSBjdXJyZW50IG9yaWdpbiB1c2luZyB0aGUgQ0hST01BX1NFUlZFUl9DT1JTX0FMTE9XX09SSUdJTlMgZW52aXJvbm1lbnQgdmFyaWFibGUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBDaHJvbWFDb25uZWN0aW9uRXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdCB0byBDaHJvbWFcIik7XG4gIH1cbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgY2FzZSA0MDA6XG4gICAgICBsZXQgc3RhdHVzID0gXCJCYWQgUmVxdWVzdFwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzdGF0dXMgPSByZXNwb25zZUJvZHkubWVzc2FnZSB8fCBzdGF0dXM7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBDaHJvbWFDbGllbnRFcnJvcihcbiAgICAgICAgYEJhZCByZXF1ZXN0IHRvICR7aW5wdXQudXJsIHx8IFwiQ2hyb21hXCJ9IHdpdGggc3RhdHVzOiAke3N0YXR1c31gXG4gICAgICApO1xuICAgIGNhc2UgNDAxOlxuICAgICAgdGhyb3cgbmV3IENocm9tYVVuYXV0aG9yaXplZEVycm9yKGBVbmF1dGhvcml6ZWRgKTtcbiAgICBjYXNlIDQwMzpcbiAgICAgIHRocm93IG5ldyBDaHJvbWFGb3JiaWRkZW5FcnJvcihcbiAgICAgICAgYFlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgcmVxdWVzdGVkIHJlc291cmNlLmBcbiAgICAgICk7XG4gICAgY2FzZSA0MDQ6XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hTm90Rm91bmRFcnJvcihcbiAgICAgICAgYFRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgY291bGQgbm90IGJlIGZvdW5kYFxuICAgICAgKTtcbiAgICBjYXNlIDQwOTpcbiAgICAgIHRocm93IG5ldyBDaHJvbWFVbmlxdWVFcnJvcihcIlRoZSByZXNvdXJjZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICBjYXNlIDQyMjpcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChib2R5ICYmIGJvZHkubWVzc2FnZSAmJiAoYm9keS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJRdW90YSBleGNlZWRlZFwiKSB8fCBib2R5Lm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkJpbGxpbmcgbGltaXQgZXhjZWVkZWRcIikpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENocm9tYVF1b3RhRXhjZWVkZWRFcnJvcihib2R5Py5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hQ2xpZW50RXJyb3IoYm9keT8ubWVzc2FnZSB8fCBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ2hyb21hUXVvdGFFeGNlZWRlZEVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgQ2hyb21hQ2xpZW50RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hQ2xpZW50RXJyb3IoYFVucHJvY2Vzc2FibGUgRW50aXR5OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG4gICAgY2FzZSA0Mjk6XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hUmF0ZUxpbWl0RXJyb3IoXCJSYXRlIGxpbWl0IGV4Y2VlZGVkXCIpO1xuICB9XG4gIGNvbnN0IGVycm9yTWVzc2FnZSA9IGF3YWl0IGdldEVycm9yTWVzc2FnZShyZXNwb25zZSk7XG4gIHRocm93IG5ldyBDaHJvbWFTZXJ2ZXJFcnJvcihlcnJvck1lc3NhZ2UpO1xufTtcblxuLy8gc3JjL2FkbWluLWNsaWVudC50c1xudmFyIEFkbWluQ2xpZW50ID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBBZG1pbkNsaWVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgYWRtaW4gY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgY29uc3QgeyBob3N0LCBwb3J0LCBzc2wsIGhlYWRlcnMsIGZldGNoT3B0aW9ucyB9ID0gYXJncyB8fCBkZWZhdWx0QWRtaW5DbGllbnRBcmdzO1xuICAgIGNvbnN0IGJhc2VVcmwgPSBgJHtzc2wgPyBcImh0dHBzXCIgOiBcImh0dHBcIn06Ly8ke2hvc3R9OiR7cG9ydH1gO1xuICAgIGNvbnN0IGNvbmZpZ09wdGlvbnMgPSB7XG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBtZXRob2Q6IG5vcm1hbGl6ZU1ldGhvZChmZXRjaE9wdGlvbnM/Lm1ldGhvZCksXG4gICAgICBiYXNlVXJsLFxuICAgICAgaGVhZGVyc1xuICAgIH07XG4gICAgdGhpcy5hcGlDbGllbnQgPSBKKHcoY29uZmlnT3B0aW9ucykpO1xuICAgIHRoaXMuYXBpQ2xpZW50LnNldENvbmZpZyh7IGZldGNoOiBjaHJvbWFGZXRjaCB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBkYXRhYmFzZSB3aXRoaW4gYSB0ZW5hbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gRGF0YWJhc2UgY3JlYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gTmFtZSBvZiB0aGUgZGF0YWJhc2UgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBvcHRpb25zLnRlbmFudCAtIFRlbmFudCB0aGF0IHdpbGwgb3duIHRoZSBkYXRhYmFzZVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlRGF0YWJhc2Uoe1xuICAgIG5hbWUsXG4gICAgdGVuYW50XG4gIH0pIHtcbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS5jcmVhdGVEYXRhYmFzZSh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogeyB0ZW5hbnQgfSxcbiAgICAgIGJvZHk6IHsgbmFtZSB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIERhdGFiYXNlIHJldHJpZXZhbCBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhYmFzZSB0byByZXRyaWV2ZVxuICAgKiBAcGFyYW0gb3B0aW9ucy50ZW5hbnQgLSBUZW5hbnQgdGhhdCBvd25zIHRoZSBkYXRhYmFzZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBkYXRhYmFzZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0RGF0YWJhc2Uoe1xuICAgIG5hbWUsXG4gICAgdGVuYW50XG4gIH0pIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmdldERhdGFiYXNlKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiB7IHRlbmFudCwgZGF0YWJhc2U6IG5hbWUgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgZGF0YWJhc2UgYW5kIGFsbCBpdHMgZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBEYXRhYmFzZSBkZWxldGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhYmFzZSB0byBkZWxldGVcbiAgICogQHBhcmFtIG9wdGlvbnMudGVuYW50IC0gVGVuYW50IHRoYXQgb3ducyB0aGUgZGF0YWJhc2VcbiAgICogQHdhcm5pbmcgVGhpcyBvcGVyYXRpb24gaXMgaXJyZXZlcnNpYmxlIGFuZCB3aWxsIGRlbGV0ZSBhbGwgZGF0YVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlRGF0YWJhc2Uoe1xuICAgIG5hbWUsXG4gICAgdGVuYW50XG4gIH0pIHtcbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS5kZWxldGVEYXRhYmFzZSh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogeyB0ZW5hbnQsIGRhdGFiYXNlOiBuYW1lIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIGRhdGFiYXNlcyB3aXRoaW4gYSB0ZW5hbnQuXG4gICAqIEBwYXJhbSBhcmdzIC0gTGlzdGluZyBwYXJhbWV0ZXJzIGluY2x1ZGluZyB0ZW5hbnQgYW5kIHBhZ2luYXRpb25cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgZGF0YWJhc2UgaW5mb3JtYXRpb25cbiAgICovXG4gIGFzeW5jIGxpc3REYXRhYmFzZXMoYXJncykge1xuICAgIGNvbnN0IHsgbGltaXQgPSAxMDAsIG9mZnNldCA9IDAsIHRlbmFudCB9ID0gYXJncztcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmxpc3REYXRhYmFzZXMoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IHsgdGVuYW50IH0sXG4gICAgICBxdWVyeTogeyBsaW1pdCwgb2Zmc2V0IH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0ZW5hbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGVuYW50IGNyZWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIE5hbWUgb2YgdGhlIHRlbmFudCB0byBjcmVhdGVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRlbmFudCh7IG5hbWUgfSkge1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNyZWF0ZVRlbmFudCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgYm9keTogeyBuYW1lIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgdGVuYW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRlbmFudCByZXRyaWV2YWwgb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gTmFtZSBvZiB0aGUgdGVuYW50IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0ZW5hbnQgbmFtZVxuICAgKi9cbiAgYXN5bmMgZ2V0VGVuYW50KHsgbmFtZSB9KSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5nZXRUZW5hbnQoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IHsgdGVuYW50X25hbWU6IG5hbWUgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhLm5hbWU7XG4gIH1cbn07XG5cbi8vIHNyYy9jaHJvbWEtY2xpZW50LnRzXG5pbXBvcnQgKiBhcyBwcm9jZXNzIGZyb20gXCJub2RlOnByb2Nlc3NcIjtcbnZhciByZXNvbHZlU2NoZW1hRW1iZWRkaW5nRnVuY3Rpb24gPSAoc2NoZW1hKSA9PiB7XG4gIGlmICghc2NoZW1hKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBlbWJlZGRpbmdPdmVycmlkZSA9IHNjaGVtYS5rZXlzW0VNQkVERElOR19LRVldPy5mbG9hdExpc3Q/LnZlY3RvckluZGV4Py5jb25maWcuZW1iZWRkaW5nRnVuY3Rpb24gPz8gdm9pZCAwO1xuICBpZiAoZW1iZWRkaW5nT3ZlcnJpZGUpIHtcbiAgICByZXR1cm4gZW1iZWRkaW5nT3ZlcnJpZGU7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYS5kZWZhdWx0cy5mbG9hdExpc3Q/LnZlY3RvckluZGV4Py5jb25maWcuZW1iZWRkaW5nRnVuY3Rpb24gPz8gdm9pZCAwO1xufTtcbnZhciBDaHJvbWFDbGllbnQgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENocm9tYUNsaWVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MgPSB7fSkge1xuICAgIGxldCB7XG4gICAgICBob3N0ID0gZGVmYXVsdENocm9tYUNsaWVudEFyZ3MuaG9zdCxcbiAgICAgIHBvcnQgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy5wb3J0LFxuICAgICAgc3NsID0gZGVmYXVsdENocm9tYUNsaWVudEFyZ3Muc3NsLFxuICAgICAgdGVuYW50ID0gZGVmYXVsdENocm9tYUNsaWVudEFyZ3MudGVuYW50LFxuICAgICAgZGF0YWJhc2UgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy5kYXRhYmFzZSxcbiAgICAgIGhlYWRlcnMgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy5oZWFkZXJzLFxuICAgICAgZmV0Y2hPcHRpb25zID0gZGVmYXVsdENocm9tYUNsaWVudEFyZ3MuZmV0Y2hPcHRpb25zXG4gICAgfSA9IGFyZ3M7XG4gICAgaWYgKGFyZ3MucGF0aCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlRoZSAncGF0aCcgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAnc3NsJywgJ2hvc3QnLCBhbmQgJ3BvcnQnIGluc3RlYWRcIlxuICAgICAgKTtcbiAgICAgIGNvbnN0IHBhcnNlZFBhdGggPSBwYXJzZUNvbm5lY3Rpb25QYXRoKGFyZ3MucGF0aCk7XG4gICAgICBzc2wgPSBwYXJzZWRQYXRoLnNzbDtcbiAgICAgIGhvc3QgPSBwYXJzZWRQYXRoLmhvc3Q7XG4gICAgICBwb3J0ID0gcGFyc2VkUGF0aC5wb3J0O1xuICAgIH1cbiAgICBpZiAoYXJncy5hdXRoKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVGhlICdhdXRoJyBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICdoZWFkZXJzJyBpbnN0ZWFkXCJcbiAgICAgICk7XG4gICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVycyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKCFoZWFkZXJzW1wieC1jaHJvbWEtdG9rZW5cIl0gJiYgYXJncy5hdXRoLnRva2VuSGVhZGVyVHlwZSA9PT0gXCJYX0NIUk9NQV9UT0tFTlwiICYmIGFyZ3MuYXV0aC5jcmVkZW50aWFscykge1xuICAgICAgICBoZWFkZXJzW1wieC1jaHJvbWEtdG9rZW5cIl0gPSBhcmdzLmF1dGguY3JlZGVudGlhbHM7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJhc2VVcmwgPSBgJHtzc2wgPyBcImh0dHBzXCIgOiBcImh0dHBcIn06Ly8ke2hvc3R9OiR7cG9ydH1gO1xuICAgIHRoaXMuX3RlbmFudCA9IHRlbmFudCB8fCBwcm9jZXNzLmVudi5DSFJPTUFfVEVOQU5UO1xuICAgIHRoaXMuX2RhdGFiYXNlID0gZGF0YWJhc2UgfHwgcHJvY2Vzcy5lbnYuQ0hST01BX0RBVEFCQVNFO1xuICAgIHRoaXMuX2hlYWRlcnMgPSBoZWFkZXJzO1xuICAgIGNvbnN0IGNvbmZpZ09wdGlvbnMgPSB7XG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBtZXRob2Q6IG5vcm1hbGl6ZU1ldGhvZChmZXRjaE9wdGlvbnM/Lm1ldGhvZCksXG4gICAgICBiYXNlVXJsLFxuICAgICAgaGVhZGVyc1xuICAgIH07XG4gICAgdGhpcy5hcGlDbGllbnQgPSBKKHcoY29uZmlnT3B0aW9ucykpO1xuICAgIHRoaXMuYXBpQ2xpZW50LnNldENvbmZpZyh7IGZldGNoOiBjaHJvbWFGZXRjaCB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB0ZW5hbnQgbmFtZS5cbiAgICogQHJldHVybnMgVGhlIHRlbmFudCBuYW1lIG9yIHVuZGVmaW5lZCBpZiBub3Qgc2V0XG4gICAqL1xuICBnZXQgdGVuYW50KCkge1xuICAgIHJldHVybiB0aGlzLl90ZW5hbnQ7XG4gIH1cbiAgc2V0IHRlbmFudCh0ZW5hbnQpIHtcbiAgICB0aGlzLl90ZW5hbnQgPSB0ZW5hbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgZGF0YWJhc2UgbmFtZS5cbiAgICogQHJldHVybnMgVGhlIGRhdGFiYXNlIG5hbWUgb3IgdW5kZWZpbmVkIGlmIG5vdCBzZXRcbiAgICovXG4gIGdldCBkYXRhYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YWJhc2U7XG4gIH1cbiAgc2V0IGRhdGFiYXNlKGRhdGFiYXNlKSB7XG4gICAgdGhpcy5fZGF0YWJhc2UgPSBkYXRhYmFzZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcHJlZmxpZ2h0IGNoZWNrc1xuICAgKiBAcmV0dXJucyBUaGUgcHJlZmxpZ2h0IGNoZWNrcyBvciB1bmRlZmluZWQgaWYgbm90IHNldFxuICAgKi9cbiAgZ2V0IHByZWZsaWdodENoZWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlZmxpZ2h0Q2hlY2tzO1xuICB9XG4gIHNldCBwcmVmbGlnaHRDaGVja3MocHJlZmxpZ2h0Q2hlY2tzKSB7XG4gICAgdGhpcy5fcHJlZmxpZ2h0Q2hlY2tzID0gcHJlZmxpZ2h0Q2hlY2tzO1xuICB9XG4gIGdldCBoZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzO1xuICB9XG4gIC8qKiBAaWdub3JlICovXG4gIGFzeW5jIF9wYXRoKCkge1xuICAgIGlmICghdGhpcy5fdGVuYW50IHx8ICF0aGlzLl9kYXRhYmFzZSkge1xuICAgICAgY29uc3QgeyB0ZW5hbnQsIGRhdGFiYXNlcyB9ID0gYXdhaXQgdGhpcy5nZXRVc2VySWRlbnRpdHkoKTtcbiAgICAgIGNvbnN0IHVuaXF1ZURCcyA9IFsuLi5uZXcgU2V0KGRhdGFiYXNlcyldO1xuICAgICAgdGhpcy5fdGVuYW50ID0gdGVuYW50O1xuICAgICAgaWYgKHVuaXF1ZURCcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IENocm9tYVVuYXV0aG9yaXplZEVycm9yKFxuICAgICAgICAgIGBZb3VyIEFQSSBrZXkgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYW55IERCcyBmb3IgdGVuYW50ICR7dGhpcy50ZW5hbnR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHVuaXF1ZURCcy5sZW5ndGggPiAxIHx8IHVuaXF1ZURCc1swXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgICAgXCJZb3VyIEFQSSBrZXkgaXMgc2NvcGVkIHRvIG1vcmUgdGhhbiAxIERCLiBQbGVhc2UgcHJvdmlkZSBhIERCIG5hbWUgdG8gdGhlIENsb3VkQ2xpZW50IGNvbnN0cnVjdG9yXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RhdGFiYXNlID0gdW5pcXVlREJzWzBdO1xuICAgIH1cbiAgICByZXR1cm4geyB0ZW5hbnQ6IHRoaXMuX3RlbmFudCwgZGF0YWJhc2U6IHRoaXMuX2RhdGFiYXNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIgaWRlbnRpdHkgaW5mb3JtYXRpb24gaW5jbHVkaW5nIHRlbmFudCBhbmQgYWNjZXNzaWJsZSBkYXRhYmFzZXMuXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHVzZXIgaWRlbnRpdHkgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcklkZW50aXR5KCkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuZ2V0VXNlcklkZW50aXR5KHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnRcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBoZWFydGJlYXQgcmVxdWVzdCB0byBjaGVjayBzZXJ2ZXIgY29ubmVjdGl2aXR5LlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgc2VydmVyJ3MgbmFub3NlY29uZCBoZWFydGJlYXQgdGltZXN0YW1wXG4gICAqL1xuICBhc3luYyBoZWFydGJlYXQoKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5oZWFydGJlYXQoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhW1wibmFub3NlY29uZCBoZWFydGJlYXRcIl07XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBjb2xsZWN0aW9ucyBpbiB0aGUgY3VycmVudCBkYXRhYmFzZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBPcHRpb25hbCBwYWdpbmF0aW9uIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIGFyZ3MubGltaXQgLSBNYXhpbXVtIG51bWJlciBvZiBjb2xsZWN0aW9ucyB0byByZXR1cm4gKGRlZmF1bHQ6IDEwMClcbiAgICogQHBhcmFtIGFyZ3Mub2Zmc2V0IC0gTnVtYmVyIG9mIGNvbGxlY3Rpb25zIHRvIHNraXAgKGRlZmF1bHQ6IDApXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIENvbGxlY3Rpb24gaW5zdGFuY2VzXG4gICAqL1xuICBhc3luYyBsaXN0Q29sbGVjdGlvbnMoYXJncykge1xuICAgIGNvbnN0IHsgbGltaXQgPSAxMDAsIG9mZnNldCA9IDAgfSA9IGFyZ3MgfHwge307XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5saXN0Q29sbGVjdGlvbnMoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMuX3BhdGgoKSxcbiAgICAgIHF1ZXJ5OiB7IGxpbWl0LCBvZmZzZXQgfVxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIGRhdGEubWFwKGFzeW5jIChjb2xsZWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGF3YWl0IFNjaGVtYS5kZXNlcmlhbGl6ZUZyb21KU09OKFxuICAgICAgICAgIGNvbGxlY3Rpb24uc2NoZW1hID8/IG51bGwsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBzY2hlbWFFbWJlZGRpbmdGdW5jdGlvbiA9IHJlc29sdmVTY2hlbWFFbWJlZGRpbmdGdW5jdGlvbihzY2hlbWEpO1xuICAgICAgICBjb25zdCByZXNvbHZlZEVtYmVkZGluZ0Z1bmN0aW9uID0gYXdhaXQgZ2V0RW1iZWRkaW5nRnVuY3Rpb24oe1xuICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb2xsZWN0aW9uLm5hbWUsXG4gICAgICAgICAgY2xpZW50OiB0aGlzLFxuICAgICAgICAgIGVmQ29uZmlnOiBjb2xsZWN0aW9uLmNvbmZpZ3VyYXRpb25fanNvbi5lbWJlZGRpbmdfZnVuY3Rpb24gPz8gdm9pZCAwXG4gICAgICAgIH0pID8/IHNjaGVtYUVtYmVkZGluZ0Z1bmN0aW9uO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25JbXBsKHtcbiAgICAgICAgICBjaHJvbWFDbGllbnQ6IHRoaXMsXG4gICAgICAgICAgYXBpQ2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgICAgICB0ZW5hbnQ6IGNvbGxlY3Rpb24udGVuYW50LFxuICAgICAgICAgIGRhdGFiYXNlOiBjb2xsZWN0aW9uLmRhdGFiYXNlLFxuICAgICAgICAgIG5hbWU6IGNvbGxlY3Rpb24ubmFtZSxcbiAgICAgICAgICBpZDogY29sbGVjdGlvbi5pZCxcbiAgICAgICAgICBlbWJlZGRpbmdGdW5jdGlvbjogcmVzb2x2ZWRFbWJlZGRpbmdGdW5jdGlvbixcbiAgICAgICAgICBjb25maWd1cmF0aW9uOiBjb2xsZWN0aW9uLmNvbmZpZ3VyYXRpb25fanNvbixcbiAgICAgICAgICBtZXRhZGF0YTogZGVzZXJpYWxpemVNZXRhZGF0YShjb2xsZWN0aW9uLm1ldGFkYXRhID8/IHZvaWQgMCkgPz8gdm9pZCAwLFxuICAgICAgICAgIHNjaGVtYVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIGNvbGxlY3Rpb25zIGluIHRoZSBjdXJyZW50IGRhdGFiYXNlLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBjb3VudFxuICAgKi9cbiAgYXN5bmMgY291bnRDb2xsZWN0aW9ucygpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNvdW50Q29sbGVjdGlvbnMoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMuX3BhdGgoKVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29sbGVjdGlvbiBjcmVhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWd1cmF0aW9uIC0gT3B0aW9uYWwgY29sbGVjdGlvbiBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25zLm1ldGFkYXRhIC0gT3B0aW9uYWwgbWV0YWRhdGEgZm9yIHRoZSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25zLmVtYmVkZGluZ0Z1bmN0aW9uIC0gT3B0aW9uYWwgZW1iZWRkaW5nIGZ1bmN0aW9uIHRvIHVzZS4gRGVmYXVsdHMgdG8gYERlZmF1bHRFbWJlZGRpbmdGdW5jdGlvbmAgZnJvbSBAY2hyb21hLWNvcmUvZGVmYXVsdC1lbWJlZFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCBDb2xsZWN0aW9uIGluc3RhbmNlXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgYSBjb2xsZWN0aW9uIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0c1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlQ29sbGVjdGlvbih7XG4gICAgbmFtZSxcbiAgICBjb25maWd1cmF0aW9uLFxuICAgIG1ldGFkYXRhLFxuICAgIGVtYmVkZGluZ0Z1bmN0aW9uLFxuICAgIHNjaGVtYVxuICB9KSB7XG4gICAgY29uc3QgY29sbGVjdGlvbkNvbmZpZyA9IGF3YWl0IHByb2Nlc3NDcmVhdGVDb2xsZWN0aW9uQ29uZmlnKHtcbiAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbixcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgc2NoZW1hXG4gICAgfSk7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5jcmVhdGVDb2xsZWN0aW9uKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLl9wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IGNvbGxlY3Rpb25Db25maWcsXG4gICAgICAgIG1ldGFkYXRhOiBzZXJpYWxpemVNZXRhZGF0YShtZXRhZGF0YSksXG4gICAgICAgIGdldF9vcl9jcmVhdGU6IGZhbHNlLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYSA/IHNjaGVtYS5zZXJpYWxpemVUb0pTT04oKSA6IHZvaWQgMFxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlcnZlclNjaGVtYSA9IGF3YWl0IFNjaGVtYS5kZXNlcmlhbGl6ZUZyb21KU09OKFxuICAgICAgZGF0YS5zY2hlbWEgPz8gbnVsbCxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGNvbnN0IHNjaGVtYUVtYmVkZGluZ0Z1bmN0aW9uID0gcmVzb2x2ZVNjaGVtYUVtYmVkZGluZ0Z1bmN0aW9uKHNlcnZlclNjaGVtYSk7XG4gICAgY29uc3QgcmVzb2x2ZWRFbWJlZGRpbmdGdW5jdGlvbiA9IGVtYmVkZGluZ0Z1bmN0aW9uID8/IGF3YWl0IGdldEVtYmVkZGluZ0Z1bmN0aW9uKHtcbiAgICAgIGNvbGxlY3Rpb25OYW1lOiBkYXRhLm5hbWUsXG4gICAgICBjbGllbnQ6IHRoaXMsXG4gICAgICBlZkNvbmZpZzogZGF0YS5jb25maWd1cmF0aW9uX2pzb24uZW1iZWRkaW5nX2Z1bmN0aW9uID8/IHZvaWQgMFxuICAgIH0pID8/IHNjaGVtYUVtYmVkZGluZ0Z1bmN0aW9uO1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbkltcGwoe1xuICAgICAgY2hyb21hQ2xpZW50OiB0aGlzLFxuICAgICAgYXBpQ2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIG5hbWUsXG4gICAgICB0ZW5hbnQ6IGRhdGEudGVuYW50LFxuICAgICAgZGF0YWJhc2U6IGRhdGEuZGF0YWJhc2UsXG4gICAgICBjb25maWd1cmF0aW9uOiBkYXRhLmNvbmZpZ3VyYXRpb25fanNvbixcbiAgICAgIG1ldGFkYXRhOiBkZXNlcmlhbGl6ZU1ldGFkYXRhKGRhdGEubWV0YWRhdGEgPz8gdm9pZCAwKSA/PyB2b2lkIDAsXG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbjogcmVzb2x2ZWRFbWJlZGRpbmdGdW5jdGlvbixcbiAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgc2NoZW1hOiBzZXJ2ZXJTY2hlbWFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb24gYnkgbmFtZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb2xsZWN0aW9uIHJldHJpZXZhbCBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29sbGVjdGlvbiB0byByZXRyaWV2ZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5lbWJlZGRpbmdGdW5jdGlvbiAtIE9wdGlvbmFsIGVtYmVkZGluZyBmdW5jdGlvbi4gU2hvdWxkIG1hdGNoIHRoZSBvbmUgdXNlZCB0byBjcmVhdGUgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBDb2xsZWN0aW9uIGluc3RhbmNlXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNvbGxlY3Rpb24gZG9lcyBub3QgZXhpc3RcbiAgICovXG4gIGFzeW5jIGdldENvbGxlY3Rpb24oe1xuICAgIG5hbWUsXG4gICAgZW1iZWRkaW5nRnVuY3Rpb25cbiAgfSkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuZ2V0Q29sbGVjdGlvbih7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogeyAuLi5hd2FpdCB0aGlzLl9wYXRoKCksIGNvbGxlY3Rpb25faWQ6IG5hbWUgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNjaGVtYSA9IGF3YWl0IFNjaGVtYS5kZXNlcmlhbGl6ZUZyb21KU09OKGRhdGEuc2NoZW1hID8/IG51bGwsIHRoaXMpO1xuICAgIGNvbnN0IHNjaGVtYUVtYmVkZGluZ0Z1bmN0aW9uID0gcmVzb2x2ZVNjaGVtYUVtYmVkZGluZ0Z1bmN0aW9uKHNjaGVtYSk7XG4gICAgY29uc3QgcmVzb2x2ZWRFbWJlZGRpbmdGdW5jdGlvbiA9IGVtYmVkZGluZ0Z1bmN0aW9uID8/IGF3YWl0IGdldEVtYmVkZGluZ0Z1bmN0aW9uKHtcbiAgICAgIGNvbGxlY3Rpb25OYW1lOiBkYXRhLm5hbWUsXG4gICAgICBjbGllbnQ6IHRoaXMsXG4gICAgICBlZkNvbmZpZzogZGF0YS5jb25maWd1cmF0aW9uX2pzb24uZW1iZWRkaW5nX2Z1bmN0aW9uID8/IHZvaWQgMFxuICAgIH0pID8/IHNjaGVtYUVtYmVkZGluZ0Z1bmN0aW9uO1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbkltcGwoe1xuICAgICAgY2hyb21hQ2xpZW50OiB0aGlzLFxuICAgICAgYXBpQ2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIG5hbWUsXG4gICAgICB0ZW5hbnQ6IGRhdGEudGVuYW50LFxuICAgICAgZGF0YWJhc2U6IGRhdGEuZGF0YWJhc2UsXG4gICAgICBjb25maWd1cmF0aW9uOiBkYXRhLmNvbmZpZ3VyYXRpb25fanNvbixcbiAgICAgIG1ldGFkYXRhOiBkZXNlcmlhbGl6ZU1ldGFkYXRhKGRhdGEubWV0YWRhdGEgPz8gdm9pZCAwKSA/PyB2b2lkIDAsXG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbjogcmVzb2x2ZWRFbWJlZGRpbmdGdW5jdGlvbixcbiAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgc2NoZW1hXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbiBleGlzdGluZyBjb2xsZWN0aW9uIGJ5IGl0cyBDaHJvbWEgUmVzb3VyY2UgTmFtZSAoQ1JOKS5cbiAgICogQHBhcmFtIGNybiAtIFRoZSBDaHJvbWEgUmVzb3VyY2UgTmFtZSBvZiB0aGUgY29sbGVjdGlvbiB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgQ29sbGVjdGlvbiBpbnN0YW5jZVxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjb2xsZWN0aW9uIGRvZXMgbm90IGV4aXN0XG4gICAqL1xuICBhc3luYyBnZXRDb2xsZWN0aW9uQnlDcm4oY3JuKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5nZXRDb2xsZWN0aW9uQnlDcm4oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IHsgY3JuIH1cbiAgICB9KTtcbiAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBTY2hlbWEuZGVzZXJpYWxpemVGcm9tSlNPTihkYXRhLnNjaGVtYSA/PyBudWxsLCB0aGlzKTtcbiAgICBjb25zdCBzY2hlbWFFbWJlZGRpbmdGdW5jdGlvbiA9IHJlc29sdmVTY2hlbWFFbWJlZGRpbmdGdW5jdGlvbihzY2hlbWEpO1xuICAgIGNvbnN0IHJlc29sdmVkRW1iZWRkaW5nRnVuY3Rpb24gPSBhd2FpdCBnZXRFbWJlZGRpbmdGdW5jdGlvbih7XG4gICAgICBjb2xsZWN0aW9uTmFtZTogZGF0YS5uYW1lLFxuICAgICAgZWZDb25maWc6IGRhdGEuY29uZmlndXJhdGlvbl9qc29uLmVtYmVkZGluZ19mdW5jdGlvbiA/PyB2b2lkIDAsXG4gICAgICBjbGllbnQ6IHRoaXNcbiAgICB9KSA/PyBzY2hlbWFFbWJlZGRpbmdGdW5jdGlvbjtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25JbXBsKHtcbiAgICAgIGNocm9tYUNsaWVudDogdGhpcyxcbiAgICAgIGFwaUNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICB0ZW5hbnQ6IGRhdGEudGVuYW50LFxuICAgICAgZGF0YWJhc2U6IGRhdGEuZGF0YWJhc2UsXG4gICAgICBjb25maWd1cmF0aW9uOiBkYXRhLmNvbmZpZ3VyYXRpb25fanNvbixcbiAgICAgIG1ldGFkYXRhOiBkZXNlcmlhbGl6ZU1ldGFkYXRhKGRhdGEubWV0YWRhdGEgPz8gdm9pZCAwKSA/PyB2b2lkIDAsXG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbjogcmVzb2x2ZWRFbWJlZGRpbmdGdW5jdGlvbixcbiAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgc2NoZW1hXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBtdWx0aXBsZSBjb2xsZWN0aW9ucyBieSBuYW1lLlxuICAgKiBAcGFyYW0gaXRlbXMgLSBBcnJheSBvZiBjb2xsZWN0aW9uIG5hbWVzIG9yIG9iamVjdHMgd2l0aCBuYW1lIGFuZCBvcHRpb25hbCBlbWJlZGRpbmcgZnVuY3Rpb24gKHNob3VsZCBtYXRjaCB0aGUgb25lcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY29sbGVjdGlvbnMpXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIENvbGxlY3Rpb24gaW5zdGFuY2VzXG4gICAqL1xuICBhc3luYyBnZXRDb2xsZWN0aW9ucyhpdGVtcykge1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICBsZXQgcmVxdWVzdGVkQ29sbGVjdGlvbnMgPSBpdGVtcztcbiAgICBpZiAodHlwZW9mIGl0ZW1zWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXF1ZXN0ZWRDb2xsZWN0aW9ucyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICByZXR1cm4geyBuYW1lOiBpdGVtLCBlbWJlZGRpbmdGdW5jdGlvbjogdm9pZCAwIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGNvbGxlY3Rpb25zID0gcmVxdWVzdGVkQ29sbGVjdGlvbnM7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgY29sbGVjdGlvbnMubWFwKGFzeW5jIChjb2xsZWN0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbGxlY3Rpb24oeyAuLi5jb2xsZWN0aW9uIH0pO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb24gb3IgY3JlYXRlcyBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbGxlY3Rpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlndXJhdGlvbiAtIE9wdGlvbmFsIGNvbGxlY3Rpb24gY29uZmlndXJhdGlvbiAodXNlZCBvbmx5IGlmIGNyZWF0aW5nKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIGZvciB0aGUgY29sbGVjdGlvbiAodXNlZCBvbmx5IGlmIGNyZWF0aW5nKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5lbWJlZGRpbmdGdW5jdGlvbiAtIE9wdGlvbmFsIGVtYmVkZGluZyBmdW5jdGlvbiB0byB1c2VcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIENvbGxlY3Rpb24gaW5zdGFuY2VcbiAgICovXG4gIGFzeW5jIGdldE9yQ3JlYXRlQ29sbGVjdGlvbih7XG4gICAgbmFtZSxcbiAgICBjb25maWd1cmF0aW9uLFxuICAgIG1ldGFkYXRhLFxuICAgIGVtYmVkZGluZ0Z1bmN0aW9uLFxuICAgIHNjaGVtYVxuICB9KSB7XG4gICAgY29uc3QgY29sbGVjdGlvbkNvbmZpZyA9IGF3YWl0IHByb2Nlc3NDcmVhdGVDb2xsZWN0aW9uQ29uZmlnKHtcbiAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbixcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgc2NoZW1hXG4gICAgfSk7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5jcmVhdGVDb2xsZWN0aW9uKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLl9wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IGNvbGxlY3Rpb25Db25maWcsXG4gICAgICAgIG1ldGFkYXRhOiBzZXJpYWxpemVNZXRhZGF0YShtZXRhZGF0YSksXG4gICAgICAgIGdldF9vcl9jcmVhdGU6IHRydWUsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hID8gc2NoZW1hLnNlcmlhbGl6ZVRvSlNPTigpIDogdm9pZCAwXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc2VydmVyU2NoZW1hID0gYXdhaXQgU2NoZW1hLmRlc2VyaWFsaXplRnJvbUpTT04oXG4gICAgICBkYXRhLnNjaGVtYSA/PyBudWxsLFxuICAgICAgdGhpc1xuICAgICk7XG4gICAgY29uc3Qgc2NoZW1hRW1iZWRkaW5nRnVuY3Rpb24gPSByZXNvbHZlU2NoZW1hRW1iZWRkaW5nRnVuY3Rpb24oc2VydmVyU2NoZW1hKTtcbiAgICBjb25zdCByZXNvbHZlZEVtYmVkZGluZ0Z1bmN0aW9uID0gZW1iZWRkaW5nRnVuY3Rpb24gPz8gYXdhaXQgZ2V0RW1iZWRkaW5nRnVuY3Rpb24oe1xuICAgICAgY29sbGVjdGlvbk5hbWU6IG5hbWUsXG4gICAgICBlZkNvbmZpZzogZGF0YS5jb25maWd1cmF0aW9uX2pzb24uZW1iZWRkaW5nX2Z1bmN0aW9uID8/IHZvaWQgMCxcbiAgICAgIGNsaWVudDogdGhpc1xuICAgIH0pID8/IHNjaGVtYUVtYmVkZGluZ0Z1bmN0aW9uO1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbkltcGwoe1xuICAgICAgY2hyb21hQ2xpZW50OiB0aGlzLFxuICAgICAgYXBpQ2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIG5hbWUsXG4gICAgICB0ZW5hbnQ6IGRhdGEudGVuYW50LFxuICAgICAgZGF0YWJhc2U6IGRhdGEuZGF0YWJhc2UsXG4gICAgICBjb25maWd1cmF0aW9uOiBkYXRhLmNvbmZpZ3VyYXRpb25fanNvbixcbiAgICAgIG1ldGFkYXRhOiBkZXNlcmlhbGl6ZU1ldGFkYXRhKGRhdGEubWV0YWRhdGEgPz8gdm9pZCAwKSA/PyB2b2lkIDAsXG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbjogcmVzb2x2ZWRFbWJlZGRpbmdGdW5jdGlvbixcbiAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgc2NoZW1hOiBzZXJ2ZXJTY2hlbWFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGNvbGxlY3Rpb24gYW5kIGFsbCBpdHMgZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBEZWxldGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29sbGVjdGlvbiB0byBkZWxldGVcbiAgICovXG4gIGFzeW5jIGRlbGV0ZUNvbGxlY3Rpb24oeyBuYW1lIH0pIHtcbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS5kZWxldGVDb2xsZWN0aW9uKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiB7IC4uLmF3YWl0IHRoaXMuX3BhdGgoKSwgY29sbGVjdGlvbl9pZDogbmFtZSB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgZW50aXJlIGRhdGFiYXNlLCBkZWxldGluZyBhbGwgY29sbGVjdGlvbnMgYW5kIGRhdGEuXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSByZXNldCBpcyBjb21wbGV0ZVxuICAgKiBAd2FybmluZyBUaGlzIG9wZXJhdGlvbiBpcyBpcnJldmVyc2libGUgYW5kIHdpbGwgZGVsZXRlIGFsbCBkYXRhXG4gICAqL1xuICBhc3luYyByZXNldCgpIHtcbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS5yZXNldCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZlcnNpb24gb2YgdGhlIENocm9tYSBzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzZXJ2ZXIgdmVyc2lvbiBzdHJpbmdcbiAgICovXG4gIGFzeW5jIHZlcnNpb24oKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS52ZXJzaW9uKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnRcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcHJlZmxpZ2h0IGNoZWNrc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcHJlZmxpZ2h0IGNoZWNrc1xuICAgKi9cbiAgYXN5bmMgZ2V0UHJlZmxpZ2h0Q2hlY2tzKCkge1xuICAgIGlmICghdGhpcy5wcmVmbGlnaHRDaGVja3MpIHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UucHJlRmxpZ2h0Q2hlY2tzKHtcbiAgICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudFxuICAgICAgfSk7XG4gICAgICB0aGlzLnByZWZsaWdodENoZWNrcyA9IGRhdGE7XG4gICAgICByZXR1cm4gdGhpcy5wcmVmbGlnaHRDaGVja3M7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZWZsaWdodENoZWNrcztcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgbWF4IGJhdGNoIHNpemVcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1heCBiYXRjaCBzaXplXG4gICAqL1xuICBhc3luYyBnZXRNYXhCYXRjaFNpemUoKSB7XG4gICAgY29uc3QgcHJlZmxpZ2h0Q2hlY2tzID0gYXdhaXQgdGhpcy5nZXRQcmVmbGlnaHRDaGVja3MoKTtcbiAgICByZXR1cm4gcHJlZmxpZ2h0Q2hlY2tzLm1heF9iYXRjaF9zaXplID8/IC0xO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgYmFzZTY0X2VuY29kaW5nIGlzIHN1cHBvcnRlZCBieSB0aGUgY29ubmVjdGVkIHNlcnZlclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB3aGV0aGVyIGJhc2U2NF9lbmNvZGluZyBpcyBzdXBwb3J0ZWRcbiAgICovXG4gIGFzeW5jIHN1cHBvcnRzQmFzZTY0RW5jb2RpbmcoKSB7XG4gICAgY29uc3QgcHJlZmxpZ2h0Q2hlY2tzID0gYXdhaXQgdGhpcy5nZXRQcmVmbGlnaHRDaGVja3MoKTtcbiAgICByZXR1cm4gcHJlZmxpZ2h0Q2hlY2tzLnN1cHBvcnRzX2Jhc2U2NF9lbmNvZGluZyA/PyBmYWxzZTtcbiAgfVxufTtcblxuLy8gc3JjL2Nsb3VkLWNsaWVudC50c1xuaW1wb3J0ICogYXMgcHJvY2VzczIgZnJvbSBcIm5vZGU6cHJvY2Vzc1wiO1xudmFyIENsb3VkQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBDaHJvbWFDbGllbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDbG91ZENsaWVudCBpbnN0YW5jZSBmb3IgQ2hyb21hIENsb3VkLlxuICAgKiBAcGFyYW0gYXJncyAtIENsb3VkIGNsaWVudCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGFwaUtleSA9IGFyZ3MuYXBpS2V5IHx8IHByb2Nlc3MyLmVudi5DSFJPTUFfQVBJX0tFWTtcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIFwiTWlzc2luZyBBUEkga2V5LiBQbGVhc2UgcHJvdmlkZSBpdCB0byB0aGUgQ2xvdWRDbGllbnQgY29uc3RydWN0b3Igb3Igc2V0IHlvdXIgQ0hST01BX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdGVuYW50ID0gYXJncy50ZW5hbnQgfHwgcHJvY2VzczIuZW52LkNIUk9NQV9URU5BTlQ7XG4gICAgY29uc3QgZGF0YWJhc2UgPSBhcmdzLmRhdGFiYXNlIHx8IHByb2Nlc3MyLmVudi5DSFJPTUFfREFUQUJBU0U7XG4gICAgc3VwZXIoe1xuICAgICAgaG9zdDogYXJncy5ob3N0IHx8IFwiYXBpLnRyeWNocm9tYS5jb21cIixcbiAgICAgIHBvcnQ6IGFyZ3MucG9ydCB8fCA0NDMsXG4gICAgICBzc2w6IHRydWUsXG4gICAgICB0ZW5hbnQsXG4gICAgICBkYXRhYmFzZSxcbiAgICAgIGhlYWRlcnM6IHsgXCJ4LWNocm9tYS10b2tlblwiOiBhcGlLZXkgfSxcbiAgICAgIGZldGNoT3B0aW9uczogYXJncy5mZXRjaE9wdGlvbnNcbiAgICB9KTtcbiAgICB0aGlzLnRlbmFudCA9IHRlbmFudDtcbiAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2U7XG4gIH1cbn07XG52YXIgQWRtaW5DbG91ZENsaWVudCA9IGNsYXNzIGV4dGVuZHMgQWRtaW5DbGllbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBBZG1pbkNsb3VkQ2xpZW50IGluc3RhbmNlIGZvciBjbG91ZCBhZG1pbiBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0gYXJncyAtIEFkbWluIGNsb3VkIGNsaWVudCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGFwaUtleSA9IGFyZ3MuYXBpS2V5IHx8IHByb2Nlc3MyLmVudi5DSFJPTUFfQVBJX0tFWTtcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIFwiTWlzc2luZyBBUEkga2V5LiBQbGVhc2UgcHJvdmlkZSBpdCB0byB0aGUgQ2xvdWRDbGllbnQgY29uc3RydWN0b3Igb3Igc2V0IHlvdXIgQ0hST01BX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgc3VwZXIoe1xuICAgICAgaG9zdDogYXJncy5ob3N0IHx8IFwiYXBpLnRyeWNocm9tYS5jb21cIixcbiAgICAgIHBvcnQ6IGFyZ3MucG9ydCB8fCA0NDMsXG4gICAgICBzc2w6IHRydWUsXG4gICAgICBoZWFkZXJzOiB7IFwieC1jaHJvbWEtdG9rZW5cIjogYXBpS2V5IH0sXG4gICAgICBmZXRjaE9wdGlvbnM6IGFyZ3MuZmV0Y2hPcHRpb25zXG4gICAgfSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBBYnMsXG4gIEFkbWluQ2xpZW50LFxuICBBZG1pbkNsb3VkQ2xpZW50LFxuICBBZ2dyZWdhdGUsXG4gIEJvb2xJbnZlcnRlZEluZGV4Q29uZmlnLFxuICBCb29sSW52ZXJ0ZWRJbmRleFR5cGUsXG4gIEJvb2xWYWx1ZVR5cGUsXG4gIENocm9tYUNsaWVudCxcbiAgQ2hyb21hQ2xpZW50RXJyb3IsXG4gIENocm9tYUNvbm5lY3Rpb25FcnJvcixcbiAgQ2hyb21hRXJyb3IsXG4gIENocm9tYUZvcmJpZGRlbkVycm9yLFxuICBDaHJvbWFOb3RGb3VuZEVycm9yLFxuICBDaHJvbWFRdW90YUV4Y2VlZGVkRXJyb3IsXG4gIENocm9tYVJhdGVMaW1pdEVycm9yLFxuICBDaHJvbWFTZXJ2ZXJFcnJvcixcbiAgQ2hyb21hVW5hdXRob3JpemVkRXJyb3IsXG4gIENocm9tYVVuaXF1ZUVycm9yLFxuICBDaHJvbWFWYWx1ZUVycm9yLFxuICBDbG91ZENsaWVudCxcbiAgQ21layxcbiAgQ21la1Byb3ZpZGVyLFxuICBET0NVTUVOVF9LRVksXG4gIERpdixcbiAgRU1CRURESU5HX0tFWSxcbiAgRXhwLFxuICBGbG9hdEludmVydGVkSW5kZXhDb25maWcsXG4gIEZsb2F0SW52ZXJ0ZWRJbmRleFR5cGUsXG4gIEZsb2F0TGlzdFZhbHVlVHlwZSxcbiAgRmxvYXRWYWx1ZVR5cGUsXG4gIEZ0c0luZGV4Q29uZmlnLFxuICBGdHNJbmRleFR5cGUsXG4gIEdldFJlc3VsdCxcbiAgR3JvdXBCeSxcbiAgSW5jbHVkZUVudW0sXG4gIEludEludmVydGVkSW5kZXhDb25maWcsXG4gIEludEludmVydGVkSW5kZXhUeXBlLFxuICBJbnRWYWx1ZVR5cGUsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkQ29sbGVjdGlvbkVycm9yLFxuICBLLFxuICBLZXksXG4gIEtubixcbiAgTGltaXQsXG4gIExvZyxcbiAgTWF4LFxuICBNYXhLLFxuICBNaW4sXG4gIE1pbkssXG4gIE11bCxcbiAgUXVlcnlSZXN1bHQsXG4gIFJhbmtFeHByZXNzaW9uLFxuICBScmYsXG4gIFNjaGVtYSxcbiAgU2VhcmNoLFxuICBTZWFyY2hSZXN1bHQsXG4gIFNlbGVjdCxcbiAgU3BhcnNlVmVjdG9ySW5kZXhDb25maWcsXG4gIFNwYXJzZVZlY3RvckluZGV4VHlwZSxcbiAgU3BhcnNlVmVjdG9yVmFsdWVUeXBlLFxuICBTdHJpbmdJbnZlcnRlZEluZGV4Q29uZmlnLFxuICBTdHJpbmdJbnZlcnRlZEluZGV4VHlwZSxcbiAgU3RyaW5nVmFsdWVUeXBlLFxuICBTdWIsXG4gIFN1bSxcbiAgVmFsLFxuICBWYWx1ZVR5cGVzLFxuICBWZWN0b3JJbmRleENvbmZpZyxcbiAgVmVjdG9ySW5kZXhUeXBlLFxuICBXaGVyZUV4cHJlc3Npb24sXG4gIGJhc2VSZWNvcmRTZXRGaWVsZHMsXG4gIGNyZWF0ZUVycm9yQnlUeXBlLFxuICBnZXREZWZhdWx0RUZDb25maWcsXG4gIGdldEVtYmVkZGluZ0Z1bmN0aW9uLFxuICBnZXRTcGFyc2VFbWJlZGRpbmdGdW5jdGlvbixcbiAga25vd25FbWJlZGRpbmdGdW5jdGlvbnMsXG4gIGtub3duU3BhcnNlRW1iZWRkaW5nRnVuY3Rpb25zLFxuICBwcm9jZXNzQ3JlYXRlQ29sbGVjdGlvbkNvbmZpZyxcbiAgcHJvY2Vzc1VwZGF0ZUNvbGxlY3Rpb25Db25maWcsXG4gIHJlY29yZFNldEZpZWxkcyxcbiAgcmVnaXN0ZXJFbWJlZGRpbmdGdW5jdGlvbixcbiAgcmVnaXN0ZXJTcGFyc2VFbWJlZGRpbmdGdW5jdGlvbixcbiAgc2VyaWFsaXplRW1iZWRkaW5nRnVuY3Rpb24sXG4gIHRvU2VhcmNoLFxuICB3aXRoQ2hyb21hXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hyb21hZGIubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/chromadb/dist/chromadb.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __publicField: () => (/* binding */ __publicField)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n//# sourceMappingURL=chunk-NSSMTXJJ.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hyb21hZGIvZGlzdC9jaHVuay1OU1NNVFhKSi5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnVnc2NvdXQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvY2hyb21hZGIvZGlzdC9jaHVuay1OU1NNVFhKSi5tanM/OWYyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuXG5leHBvcnQge1xuICBfX3B1YmxpY0ZpZWxkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstTlNTTVRYSkoubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs\n");

/***/ })

};
;